
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://example.com/notes_repo/rethinking-the-memory-hierarchy-for-modern-languages/paper_notes/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Rethinking the Memory Hierarchy for Modern Languages 论文解析 - BlaBlaCut</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#rethinking-the-memory-hierarchy-for-modern-languages" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="BlaBlaCut" class="md-header__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            BlaBlaCut
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Rethinking the Memory Hierarchy for Modern Languages 论文解析
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到深色模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换到深色模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到浅色模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换到浅色模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="BlaBlaCut" class="md-nav__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    BlaBlaCut
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/Recent/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Recent
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/awesome-data-prefetchers/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Awesome Data Prefetchers
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/micro-2025/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    MICRO 2025
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/dyn-lang-acc/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Dynamic Language Acceleration
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#0" class="md-nav__link">
    <span class="md-ellipsis">
      
        0. 论文基本信息
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. 摘要
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. 背景知识与核心贡献
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. 核心技术和实现细节
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3. 核心技术和实现细节">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#0_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        0. 技术架构概览
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. 隐式、基于对象的数据移动
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. 指针重写以避免关联查找
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-collection-eviction-ce" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. 层次化垃圾回收与驱逐统一（Collection-Eviction, CE）
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. 层级内对象分配
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    <span class="md-ellipsis">
      
        5. 规范层级与不变式
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. 实验方法与实验结果
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="rethinking-the-memory-hierarchy-for-modern-languages">Rethinking the Memory Hierarchy for Modern Languages 论文解析<a class="headerlink" href="#rethinking-the-memory-hierarchy-for-modern-languages" title="Permanent link">&para;</a></h1>
<h2 id="0">0. 论文基本信息<a class="headerlink" href="#0" title="Permanent link">&para;</a></h2>
<p><strong>作者 (Authors)</strong>: Po-An Tsai, Yee Ling Gan, Daniel Sanchez</p>
<p><strong>发表期刊/会议 (Journal/Conference)</strong>: MICRO</p>
<p><strong>发表年份 (Publication Year)</strong>: 2018</p>
<p><strong>研究机构 (Affiliations)</strong>: Massachusetts Institute of Technology</p>
<hr />
<h2 id="1">1. 摘要<a class="headerlink" href="#1" title="Permanent link">&para;</a></h2>
<p><strong>目的</strong></p>
<ul>
<li>为 <strong>Java、Go、Rust</strong> 等现代 <strong>memory-safe languages</strong>（内存安全语言）重新设计内存层次结构，以解决传统基于 <strong>flat address space</strong>（扁平地址空间）的缓存层次与这些语言语义不匹配的问题。</li>
<li>利用内存安全语言 <strong>隐藏内存布局</strong> 的核心特性，将控制权交给硬件，从而消除对 <strong>associative caches</strong>（关联缓存）的需求，提升性能和能效。</li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li>提出 <strong>Hotpads</strong>，一种全新的硬件管理的内存层次结构，其核心是名为 <strong>pads</strong> 的直接寻址存储器层级，类似于 <strong>scratchpads</strong>（暂存器）。</li>
<li>Hotpads 的关键特性包括：<ul>
<li><strong>Implicit, object-based data movement</strong>（隐式、基于对象的数据移动）：数据移动由内存访问隐式触发。</li>
<li><strong>Pointer rewriting</strong>（指针重写）：硬件自动重写指针，使其指向对象在 L1 pad 中的位置，从而避免后续访问的关联查找。</li>
<li><strong>In-hierarchy object allocation</strong>（层级内对象分配）：新对象直接在 L1 pad 的空闲空间中分配，无需主存后备存储。</li>
<li><strong>Unified hierarchical garbage collection and evictions</strong>（统一的分层垃圾回收与驱逐）：通过 <strong>collection-eviction (CE)</strong> 过程，在回收死对象的同时，将非最近使用的活对象驱逐到下一级 pad。</li>
</ul>
</li>
<li>设计了配套的 <strong>Hotpads ISA</strong>，将指针视为 <strong>abstract data types (ADTs)</strong>，禁止程序读取或操作原始指针，并引入 <code>derefptr</code>、<code>seqptr</code>、<code>alloc</code> 等新指令。</li>
<li>采用 <strong>canonical levels</strong>（规范层级）和 <strong>canonical tags (c-tags)</strong>（规范标签）等机制来管理对象在层级中的位置和元数据，确保系统正确性。</li>
</ul>
<p><img alt="" src="../images/8abad735fb6373cc3647d17c2368a2d8ed6447c44fe1b6220320f46194507192.jpg" /> <em>Fig. 4: Example showing Hotpads’s key features.</em></p>
<p><strong>结果</strong></p>
<ul>
<li>通过详细的模拟器评估，Hotpads 相比传统缓存层次展现出显著优势：<ul>
<li><strong>性能</strong>：平均提升 <strong>34%</strong>，最高可达 <strong>86%</strong>。</li>
<li><strong>能效</strong>：内存层次的动态能耗降低 <strong>2.6倍</strong>。</li>
<li><strong>垃圾回收开销</strong>：平均减少 <strong>8倍</strong>。</li>
</ul>
</li>
<li>核心优势来源：<ul>
<li><strong>L1 pad 效率</strong>：得益于指针重写，<strong>80%</strong> 的 L1 访问为直接访问，使其能效比 L1 缓存高 <strong>2.3倍</strong>。</li>
<li><strong>高效利用片上容量</strong>：以可变大小的对象而非固定大小的缓存行进行管理，提高了利用率。</li>
<li><strong>大幅减少数据移动</strong>：主存流量最高可减少 <strong>6.6倍</strong>。</li>
</ul>
</li>
<li>对于不安全的传统程序，Hotpads 的兼容模式仅带来 <strong>4%</strong> 的平均性能损失。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: left;">指标</th>
<th style="text-align: left;">Baseline (Cache)</th>
<th style="text-align: left;">Hotpads</th>
<th style="text-align: left;">提升/降低</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">平均性能</td>
<td style="text-align: left;">1.0x</td>
<td style="text-align: left;"><strong>1.34x</strong></td>
<td style="text-align: left;"><strong>+34%</strong></td>
</tr>
<tr>
<td style="text-align: left;">内存层次动态能耗</td>
<td style="text-align: left;">1.0x</td>
<td style="text-align: left;"><strong>0.38x</strong></td>
<td style="text-align: left;"><strong>-2.6x</strong></td>
</tr>
<tr>
<td style="text-align: left;">GC 开销</td>
<td style="text-align: left;">11% of time</td>
<td style="text-align: left;"><strong>1.5% of time</strong></td>
<td style="text-align: left;"><strong>-8x</strong></td>
</tr>
<tr>
<td style="text-align: left;">Legacy Mode 性能</td>
<td style="text-align: left;">1.0x</td>
<td style="text-align: left;"><strong>0.96x</strong></td>
<td style="text-align: left;"><strong>-4%</strong></td>
</tr>
</tbody>
</table>
<p><img alt="" src="../images/d8b3161760d0f4d021edfc8e0f168343cb2b31f15c927b8b5fe64e29486b84db.jpg" /> <em>Fig. 14: Simulation results for single-threaded workloads.</em></p>
<p><strong>结论</strong></p>
<ul>
<li>将内存安全语言“<strong>隐藏内存布局</strong>”的核心思想扩展到硬件层面是可行且高效的。<strong>Hotpads</strong> 通过摒弃传统的扁平地址空间抽象，成功地将 <strong>garbage collection</strong>（垃圾回收）的原则与 <strong>memory hierarchy</strong>（内存层次）的设计相统一。</li>
<li>Hotpads 不仅在性能和能效上大幅超越了传统缓存，还为未来的内存系统研究开辟了新方向，例如：<ul>
<li><strong>Security</strong>（安全性）：通过消除缓存，可有效规避 <strong>Spectre</strong> 和 <strong>Meltdown</strong> 等基于缓存的侧信道攻击。</li>
<li><strong>Isolation</strong>（隔离）：可简化或消除 <strong>Virtual Memory</strong>（虚拟内存）开销，并提供更廉价的性能隔离。</li>
<li><strong>Concurrency and non-volatility</strong>（并发与非易失性）：其多版本存储特性可用于实现 <strong>transactional memory</strong>（事务内存）或加速 <strong>NVM logging</strong>（非易失内存日志）。</li>
</ul>
</li>
</ul>
<hr />
<h2 id="2">2. 背景知识与核心贡献<a class="headerlink" href="#2" title="Permanent link">&para;</a></h2>
<p><strong>研究背景与动机</strong></p>
<ul>
<li>现代主流编程语言（如 <strong>Java</strong>, <strong>Go</strong>, <strong>Rust</strong>）均为 <strong>memory-safe (内存安全)</strong> 语言，它们通过隐藏底层内存布局、禁止直接指针操作来防止内存错误，并依赖 <strong>Garbage Collection (GC, 垃圾回收)</strong> 进行自动内存管理。</li>
<li>然而，当前的计算机体系结构（特别是 <strong>memory hierarchy, 内存层次结构</strong>）仍为 <strong>C</strong>/<strong>Fortran</strong> 等早期语言设计，其核心是维护一个对程序员透明的 <strong>flat address space (平坦地址空间)</strong> 抽象。</li>
<li>为了在物理上实现这种抽象，现代系统严重依赖 <strong>associative caches (相联缓存)</strong> 和 <strong>virtual memory (虚拟内存)</strong> 等昂贵的硬件机制，这与内存安全语言的语义存在根本性不匹配，导致了显著的性能和能效开销。</li>
</ul>
<p><strong>核心贡献：Hotpads 架构</strong></p>
<ul>
<li>提出 <strong>Hotpads</strong>，一种为内存安全语言从头设计的全新内存层次结构。其核心思想是将“<strong>隐藏内存布局</strong>”这一软件原则延伸至硬件，彻底摒弃平坦地址空间抽象。</li>
<li>Hotpads 使用一个由硬件管理的、层级化的 <strong>directly addressed memories (直接寻址存储器)</strong>，作者称之为 <strong>pads (垫)</strong>，替代传统的相联缓存。</li>
<li>通过以下四个关键特性实现高效的数据管理和访问：<ul>
<li><strong>Implicit, object-based data movement (隐式、基于对象的数据移动)</strong>: 数据移动由内存访问隐式触发，而非显式指令。</li>
<li><strong>Pointer rewriting to avoid associative lookups (指针重写以避免相联查找)</strong>: 硬件在对象被加载到 L1 pad 后，自动重写指向它的指针，使得后续访问变为高效的直接寻址，从而<strong>避免了绝大多数的相联查找</strong>。</li>
<li><strong>In-hierarchy object allocation (层次内对象分配)</strong>: 新创建的对象直接在 L1 pad 的空闲空间中分配，无需预先在主存中分配后备存储。</li>
<li><strong>Unified hierarchical garbage collection and evictions (统一的分层垃圾回收与驱逐)</strong>: 当 pad 空间不足时，触发 <strong>collection-eviction (CE, 收集-驱逐)</strong> 过程。该过程融合了 <strong>tracing GC (追踪式垃圾回收)</strong> 和缓存驱逐逻辑，既能回收死亡对象，又能将存活但非最近使用的对象驱逐到下一级 pad。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/8abad735fb6373cc3647d17c2368a2d8ed6447c44fe1b6220320f46194507192.jpg" /> <em>Fig. 4: Example showing Hotpads’s key features.</em></p>
<p><strong>主要成果与优势</strong></p>
<ul>
<li><strong>性能与能效</strong>: 在 Java 基准测试中，Hotpads 相比传统缓存层次结构，<strong>平均性能提升 34%</strong>，<strong>内存层次能耗降低 2.6 倍</strong>。</li>
<li><strong>GC 开销大幅降低</strong>: 通过硬件并发执行 CE 过程，<strong>GC 开销平均减少了 8 倍</strong>。</li>
<li><strong>兼容性</strong>: 提供兼容模式以支持内存不安全的遗留程序，仅带来 <strong>4%</strong> 的平均性能损失。</li>
<li><strong>开启新优化方向</strong>: 该架构天然规避了基于缓存的侧信道攻击（如 <strong>Spectre</strong>, <strong>Meltdown</strong>），并为未来的 <strong>security (安全)</strong>、<strong>isolation (隔离)</strong> 和 <strong>concurrency (并发)</strong> 技术提供了新的硬件基础。</li>
</ul>
<hr />
<h2 id="3">3. 核心技术和实现细节<a class="headerlink" href="#3" title="Permanent link">&para;</a></h2>
<h3 id="0_1">0. 技术架构概览<a class="headerlink" href="#0_1" title="Permanent link">&para;</a></h3>
<p><strong>整体技术架构</strong></p>
<p>Hotpads 是一种为 <strong>memory-safe languages</strong>（如 Java, Go, Rust）从头设计的新型内存层次结构，其核心思想是将软件中“隐藏内存布局”的原则延伸至硬件，从而摒弃传统的<strong>flat address space</strong>（平坦地址空间）抽象，并用一套由硬件管理的、基于对象的直接寻址内存（称为 <strong>pads</strong>）来替代关联式缓存。</p>
<ul>
<li>
<p><strong>基本组成单元 (Pads)</strong>:</p>
<ul>
<li>Hotpads 由一个多层次的 <strong>pads</strong> 组成，每个 pad 类似于一个硬件管理的 <strong>scratchpad</strong>。</li>
<li>每个 pad 内部包含三个主要部分：<ul>
<li><strong>Data Array</strong>: 用于存储对象的主数据区，采用<strong>循环缓冲区</strong>组织，包含一个连续的已分配对象块和一个连续的空闲空间块。</li>
<li><strong>Canonical Tags (c-tags) Array</strong>: 一个解耦的、类似 <strong>V-way cache</strong> 的关联式标签存储，用于将对象的<strong>canonical address</strong>（规范地址）映射到其在当前 pad 中的物理地址。</li>
<li><strong>Metadata Arrays</strong>: 包含 per-word 和 per-object 的元数据，例如指针位（标识字是否为指针）、有效/脏位、以及用于驱逐决策的<strong>recency bits</strong>。</li>
</ul>
</li>
<li><img alt="" src="../images/83d59ae4636fabe090a94631578c7b57f95ab22d143a2f36d12f6d5a60cac7fe.jpg" /> <em>Fig. 3: Pad organization.</em></li>
</ul>
</li>
<li>
<p><strong>核心运行机制</strong>:</p>
<ul>
<li><strong>隐式、基于对象的数据移动</strong>: 所有数据移动都由硬件在访问时自动触发。当核心访问一个不在 L1 pad 中的对象时，该对象会被完整地复制到 L1 pad 的空闲区域。</li>
<li><strong>指针重写 (Pointer Rewriting)</strong>: 为了规避昂贵的关联式查找，硬件会在对象被复制到 L1 pad 后，自动重写所有指向该对象的指针（包括寄存器和 L1 pad 内的指针），使其直接指向 L1 中的新位置。这使得后续的访问变为高效的<strong>direct access</strong>。<ul>
<li><img alt="" src="../images/8abad735fb6373cc3647d17c2368a2d8ed6447c44fe1b6220320f46194507192.jpg" /> <em>Fig. 4: Example showing Hotpads’s key features.</em></li>
</ul>
</li>
<li><strong>层级内对象分配 (In-hierarchy Allocation)</strong>: 新创建的小对象直接在 L1 pad 的空闲空间中分配，无需在主存中预留后备存储，从而实现极低开销的分配。</li>
<li><strong>统一的层级垃圾回收与驱逐 (Collection-Eviction, CE)</strong>: 当一个 pad 空间不足时，会触发一个类似<strong>moving garbage collection</strong>的过程。该过程同时完成两项任务：<ul>
<li><strong>回收 (Collection)</strong>: 识别并释放不可达（dead）对象的空间。</li>
<li><strong>驱逐 (Eviction)</strong>: 将可达但近期未被访问的（live but non-recently accessed）对象驱逐到下一级 pad。</li>
</ul>
</li>
<li><strong>并发执行</strong>: CE 过程与程序执行并发进行，通过一个简单的<strong>alternating-bit protocol</strong>（交替位协议）来保证一致性，仅引入极短的暂停时间（数十个周期）。</li>
</ul>
</li>
<li>
<p><strong>关键不变性 (Invariants)</strong>:</p>
<ul>
<li><strong>Invariant 1</strong>: 一个对象始终存在于其<strong>canonical level</strong>（规范层级）。</li>
<li><strong>Invariant 2</strong>: 非 L1 层级的对象指针必须是<strong>canonical</strong>的。</li>
<li><strong>Invariant 3</strong>: 一个对象只能指向与其同级或更高级（离核心更远）的对象。</li>
<li><strong>Invariant 4</strong>: 只有 canonical 对象或 L1 中的对象副本可以作为根（roots）。</li>
<li>这些不变性确保了层级化 CE 的正确性和独立性。</li>
</ul>
</li>
<li>
<p><strong>指令集架构 (ISA) 支持</strong>:</p>
<ul>
<li>Hotpads ISA 将指针视为<strong>abstract data types (ADTs)</strong>，禁止程序直接读取或操作原始指针值。</li>
<li>引入了新的指令来支持安全的指针操作：<ul>
<li><code>derefptr</code>: 用于指针解引用，触发指针重写。</li>
<li><code>ldptr</code> / <code>stptr</code>: 用于加载/存储指针，告知硬件该数据是指针。</li>
<li><code>seqptr</code>: 用于安全地比较两个指针是否指向同一对象（即使它们的位模式不同）。</li>
<li><code>alloc</code>: 用于在层级内分配新对象。</li>
</ul>
</li>
<li><img alt="" src="../images/96a820cef9e3ec3b2f47562645eae340dccf5f8bc58fc74536aeef55d0e694e9.jpg" /> <em>TABLE I: HOTPADS ISA.</em></li>
</ul>
</li>
<li>
<p><strong>对复杂场景的支持</strong>:</p>
<ul>
<li><strong>大对象</strong>: 通过<strong>subobjects</strong>（子对象）机制支持任意大小的对象。大对象被分割成固定大小的块（如 64 字节），按需将子对象缓存到 pads 中。</li>
<li><strong>多核一致性</strong>: 在共享的最高级 pad（如 L3）上实现<strong>object-level MESI coherence</strong>，避免了 false sharing，并利用对象首字中的额外位存储 sharer set。</li>
<li><strong>向后兼容</strong>: 提供<strong>legacy mode</strong>，将传统 C/C++ 程序的整个地址空间视为一个大对象，以支持内存不安全的遗留代码，仅带来约 <strong>4%</strong> 的性能损失。</li>
</ul>
</li>
</ul>
<h3 id="1_1">1. 隐式、基于对象的数据移动<a class="headerlink" href="#1_1" title="Permanent link">&para;</a></h3>
<p><strong>隐式、基于对象的数据移动的实现原理与流程</strong></p>
<ul>
<li><strong>核心触发机制</strong>：该机制完全由硬件驱动，其唯一触发条件是<strong>内存访问</strong>（memory access）。当处理器核心发起一次对某个对象的访问请求时，硬件会自动检查该对象是否存在于当前层级的 <strong>pad</strong>（例如 L1 pad）中。</li>
<li><strong>缺失处理 (Miss Handling)</strong>：<ul>
<li>如果目标对象<strong>不在</strong>L1 pad中（即发生“miss”），硬件不会像传统缓存那样去获取一个固定大小的 <strong>cache line</strong>，而是会定位到该对象的<strong>完整数据</strong>。</li>
<li>硬件随后将<strong>整个对象</strong>从其所在位置（可能是更高层级的 L2/L3 pad 或 main memory）<strong>复制</strong>（copy）到 L1 pad 的<strong>空闲空间</strong>（free space）区域。</li>
<li>这个过程对软件完全透明，程序无需执行任何显式的加载（load）或移动（move）指令。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/8abad735fb6373cc3647d17c2368a2d8ed6447c44fe1b6220320f46194507192.jpg" /> <em>Fig. 4: Example showing Hotpads’s key features.</em></p>
<ul>
<li>
<p><strong>对象边界识别</strong>：为了能够精确地移动整个对象而非固定大小的数据块，Hotpads 需要知道每个对象的边界。这通过两种方式实现：</p>
<ul>
<li><strong>指针内嵌元数据</strong>：如图 <code>aa7f421464a9fee508f7ec1751fd796efdee2876a7909da1be9294af99d3053b.jpg</code> 所示，Hotpads 的指针格式在其高16位中嵌入了<strong>对象大小</strong>（size in words）等元数据。这使得硬件在拿到指针后能立即知道对象的长度。</li>
<li><strong>ISA 指令约束</strong>：Hotpads ISA 规定所有内存访问必须采用 <strong>base+offset</strong> 寻址模式，且 <strong>base</strong> 寄存器必须是一个指向<strong>对象起始地址</strong>的指针。这确保了硬件总能从对象头部开始操作。</li>
</ul>
</li>
<li>
<p><strong>与传统缓存的关键区别</strong>：</p>
<ul>
<li><strong>粒度不同</strong>：传统缓存以<strong>固定大小</strong>（fixed-size cache lines）为单位进行数据移动，而 Hotpads 以<strong>可变大小</strong>（variable-size objects）为单位。这避免了因 cache line 内部包含不相关数据而导致的<strong>内部碎片</strong>（internal fragmentation）和<strong>带宽浪费</strong>。</li>
<li><strong>效率提升</strong>：论文评估显示（Fig. 14d），这种基于对象的移动方式显著提高了<strong>片上容量利用率</strong>（on-chip capacity utilization）。L1 pad 的利用率达到 <strong>35%</strong>，而传统 L1 cache 仅为 <strong>29%</strong>。</li>
</ul>
</li>
</ul>
<p><strong>在整体架构中的作用与输入输出关系</strong></p>
<ul>
<li><strong>输入</strong>：来自处理器核心的<strong>内存访问请求</strong>，该请求包含一个<strong>对象指针</strong>（object pointer）和一个<strong>偏移量</strong>（offset）。</li>
<li><strong>输出</strong>：<ul>
<li><strong>数据</strong>：被访问的对象数据被放置在 L1 pad 中，并完成本次访问。</li>
<li><strong>状态</strong>：L1 pad 的<strong>已分配区域</strong>（allocated region）增长，<strong>空闲空间</strong>（free space）相应减少。同时，会在 <strong>canonical tags </strong>(c-tags) 数组中创建一个新的条目，用于记录该对象的<strong>规范地址</strong>（canonical address）到其在 L1 pad 中的物理地址的映射。</li>
</ul>
</li>
<li><strong>核心作用</strong>：<ul>
<li><strong>构建高效内存层次</strong>：这是 Hotpads 整个内存层次结构运作的基础。它使得数据能够根据访问热度自动在层级间流动，将热点对象保留在快速的 L1 pad 中。</li>
<li><strong>支撑指针重写</strong>：只有当对象被成功移动到 L1 pad 后，后续的<strong>指针重写</strong>（pointer rewriting）机制才能生效，从而将后续对该对象的访问转化为高效的<strong>直接寻址</strong>（direct access），避免昂贵的关联查找（associative lookup）。</li>
<li><strong>赋能统一垃圾回收</strong>：当 L1 pad 的空闲空间耗尽时，会触发<strong>收集-驱逐</strong>（collection-eviction, CE）过程。CE 过程依赖于 pad 中存放的是完整的、边界清晰的对象，才能准确地遍历对象图、标记存活对象并进行压缩或驱逐。隐式数据移动确保了 CE 过程的操作对象是语义完整的“对象”，而非无意义的“缓存行”。</li>
</ul>
</li>
</ul>
<h3 id="2_1">2. 指针重写以避免关联查找<a class="headerlink" href="#2_1" title="Permanent link">&para;</a></h3>
<p><strong>指针重写机制的核心原理</strong></p>
<ul>
<li><strong>根本目标</strong>：消除传统缓存中每次内存访问都必须进行的<strong>关联查找 (associative lookup)</strong>，从而降低延迟和能耗。</li>
<li><strong>核心洞察</strong>：在<strong>内存安全语言</strong>中，程序员无法直接读取或操作指针的原始地址值，只能对其进行<strong>解引用 (dereference)</strong> 或<strong>比较 (comparison)</strong>。这为硬件在底层透明地修改指针值提供了可能。</li>
<li><strong>基本策略</strong>：当一个对象被从高层级（如 L2 pad 或主存）复制到 <strong>L1 pad</strong> 时，硬件会自动将所有指向该对象的指针更新为指向其在 L1 pad 中的新地址。后续对该指针的解引用操作将直接命中 L1 pad，无需任何标签查询。</li>
</ul>
<p><strong>算法流程与关键组件</strong></p>
<ul>
<li><strong>触发时机</strong>：<ul>
<li>当核心发起一个内存访问，且其基地址指针（base pointer）指向的对象<strong>不在 L1 pad</strong> 中时。</li>
<li>硬件首先将该对象从其<strong>规范层级 (canonical level)</strong> 复制到 L1 pad 的空闲区域。</li>
</ul>
</li>
<li><strong>重写位置</strong>：<ul>
<li><strong>寄存器中的指针</strong>：如果访问是由 <code>ld</code>/<code>st</code> 指令发起，硬件会在数据返回后，将核心寄存器文件中对应的指针值重写为 L1 地址。</li>
<li><strong>L1 pad 内存中的指针</strong>：如果访问是由 <code>derefptr</code> 指令发起，硬件在将目标对象 B 加载到 L1 后，会<strong>直接修改 L1 pad 中对象 A 的字段</strong>，将其指向 B 的指针更新为 B 在 L1 中的地址。</li>
</ul>
</li>
<li><strong>辅助数据结构</strong>：<ul>
<li><strong>规范标签数组 (canonical tags array, c-tags)</strong>：这是一个小型的、类似缓存标签的<strong>组相联结构</strong>。它存储了从对象的<strong>规范地址</strong>到其在当前 pad 层级（如 L1）中物理地址的映射。只有当对象的副本存在于该 pad 时，才需要 c-tag 条目。</li>
<li><strong>指针格式</strong>：Hotpads 指针的高 16 位包含元数据，其中一位是 <strong>canonical bit</strong>，用于标识该指针是否指向对象的规范层级。这使得硬件能快速判断是否需要进行重写或查询 c-tags。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/b34fd18ec892ba0f4b5a940b025c12965fa5bf12c935d623971e0ab5492d99d8.jpg" /> <em>Fig. 9: Steps in L1 pad access. Wider arrows denote more frequent events.</em></p>
<p><strong>输入输出关系及在整体架构中的作用</strong></p>
<ul>
<li><strong>输入</strong>：<ul>
<li>一个指向非 L1 对象的指针（通常是一个<strong>规范指针</strong>）。</li>
<li>一次内存访问请求（<code>ld</code>/<code>st</code> 或 <code>derefptr</code>）。</li>
</ul>
</li>
<li><strong>输出</strong>：<ul>
<li>对于 <code>ld</code>/<code>st</code>：返回请求的数据，并<strong>重写源寄存器中的指针</strong>。</li>
<li>对于 <code>derefptr</code>：返回请求的数据，并<strong>重写 L1 pad 中源对象内的指针字段</strong>。</li>
<li>对象的一个副本被放置在 L1 pad 中。</li>
</ul>
</li>
<li><strong>在 Hotpads 架构中的作用</strong>：<ul>
<li><strong>性能提升</strong>：通过将昂贵的关联查找（c-tag 查询）从“每次访问”降级为“首次访问”，极大地提升了 L1 访问效率。评估显示，<strong>80% 的 L1 访问</strong>成为直接访问。</li>
<li><strong>能效优化</strong>：直接访问 L1 pad 的动态能耗（<strong>16 pJ</strong>）远低于 L1 缓存命中（<strong>69 pJ</strong>），实现了 <strong>4.3×</strong> 的能效提升。</li>
<li><strong>简化设计</strong>：由于大部分访问变为直接寻址，L1 pad 可以采用更简单的、类似 <strong>scratchpad</strong> 的组织方式，避免了全相联或高相联度缓存的复杂性和面积开销。</li>
<li><strong>与垃圾回收协同</strong>：指针重写确保了在 <strong>collection-eviction (CE)</strong> 过程中移动对象后，所有指向该对象的指针都能被正确更新，维持了系统的正确性。</li>
</ul>
</li>
</ul>
<p><strong>效果与局限性</strong></p>
<ul>
<li><strong>效果显著</strong>：如图所示，指针重写机制成功将 <strong>80%</strong> 的 L1 pad 访问转化为高效的直接访问，这是 Hotpads 相对于传统缓存取得性能和能效优势的关键。</li>
</ul>
<p><img alt="" src="../images/7f52b0241b94504b10c97efba7df1388240b0242b42b60cb47b9276ce21c8eba.jpg" /> <em>Fig. 19: CDFs of lengths and intervals for L1 CEs.</em></p>
<ul>
<li><strong>主要局限</strong>：<ul>
<li><strong>仅限 L1</strong>：为了简化设计和控制开销，指针重写<strong>只在 L1 pad 执行</strong>。更高层级的 pad（如 L2, L3）仍然需要依赖 c-tags 进行关联查找，但由于 L1 的高命中率，这部分开销对整体影响较小。</li>
<li><strong>依赖 ISA 支持</strong>：需要新的指令（如 <code>derefptr</code>, <code>ldptr</code>）来明确告知硬件哪些内存操作涉及指针，以便进行正确的重写和元数据管理。</li>
</ul>
</li>
</ul>
<h3 id="3-collection-eviction-ce">3. 层次化垃圾回收与驱逐统一（Collection-Eviction, CE）<a class="headerlink" href="#3-collection-eviction-ce" title="Permanent link">&para;</a></h3>
<p><strong>CE过程的触发条件与核心目标</strong></p>
<ul>
<li><strong>触发条件</strong>：当一个pad的<strong>空闲空间</strong>降至预设的<strong>低阈值</strong>时，会触发一次Collection-Eviction (CE) 过程。</li>
<li><strong>核心目标</strong>：CE旨在一次性<strong>回收约75%的pad容量</strong>，通过两个互补的操作实现：<ul>
<li><strong>垃圾回收 (Garbage Collection)</strong>: 识别并释放<strong>死亡对象</strong>（即不可达对象）占用的空间。</li>
<li><strong>驱逐 (Eviction)</strong>: 将<strong>存活但非最近访问</strong>的对象移动到下一级pad，以腾出空间给更热的数据。</li>
</ul>
</li>
</ul>
<p><strong>CE算法的详细流程</strong></p>
<p>CE过程在硬件中由一个专用引擎执行，其流程模仿了<strong>移动式垃圾回收器 (moving GC)</strong>，包含四个关键步骤：</p>
<ul>
<li>
<p><strong>1. 寻找根指针 (Find roots)</strong></p>
<ul>
<li><strong>输入</strong>: 对于L1 pad，根指针是当前位于<strong>核心寄存器</strong>中的所有指向该L1 pad内对象的指针。核心会将这些指针提供给CE引擎。</li>
<li><strong>优势</strong>: 与软件GC需要遍历整个调用栈不同，Hotpads的根查找成本<strong>极低</strong>（仅需几十个周期），因为栈帧本身也被分配在堆（pad）中，无需单独扫描。</li>
</ul>
</li>
<li>
<p><strong>2. 标记存活对象 (Mark live objects)</strong></p>
<ul>
<li>使用标准的<strong>三色标记法 (tricolor mark pass)</strong> 来遍历对象图。</li>
<li>利用对象头部的两个<strong>CE标记位</strong>来记录状态（未扫描、待扫描、已扫描）。</li>
<li>为了加速，使用一个小型<strong>FIFO队列</strong>（实现中为16个条目）来缓存待扫描对象，减少对整个数据阵列的线性扫描。</li>
</ul>
</li>
<li>
<p><strong>3. 压缩或驱逐存活对象 (Compact or evict live objects)</strong></p>
<ul>
<li>引擎再次扫描数据阵列，处理每个被标记为存活的对象。</li>
<li><strong>决策依据</strong>: 检查对象的<strong>4位粗粒度LRU时间戳</strong>（recency bits）。如果对象不在最近访问的<strong>25%容量</strong>内，则被<strong>驱逐</strong>到下一级pad；否则，被<strong>移动</strong>到数据阵列的空闲区域前端，形成一个紧凑的存活对象块。</li>
<li><strong>维护层级不变量</strong>: 在驱逐过程中，必须确保<strong>不变量3</strong>（一个对象只能指向同级或更高级的对象）不被破坏。如果一个被驱逐的对象E指向了另一个仍在L1的存活对象P，且P的<strong>规范层级 (canonical level)</strong> 是L1，那么P的规范层级会被提升到L2，以便E能合法地指向它。<img alt="" src="../images/16ecfacf52bb0eaf6a09e0bd725696a59e5008ecbe57a1dd57abf4d29518acf2.jpg" /> <em>Fig. 10: Example of an eviction that requires changing the canonical level of a non-evicted object (P).</em></li>
<li><strong>构建重命名表</strong>: 在移动/驱逐过程中，引擎会构建一个<strong>重命名表 (rename table)</strong>，记录每个存活对象的旧地址到新地址（或新层级地址）的映射。</li>
</ul>
</li>
<li>
<p><strong>4. 更新指针 (Update pointers)</strong></p>
<ul>
<li>引擎遍历整个数据阵列以及核心寄存器中的所有指针。</li>
<li>对于每一个指向已被移动/驱逐对象的旧指针，查询<strong>重命名表</strong>并将其更新为新的正确地址。</li>
<li>完成后，<strong>重命名表</strong>被丢弃。</li>
</ul>
</li>
</ul>
<p><strong>并发执行与空间管理技巧</strong></p>
<ul>
<li><strong>并发操作</strong>: CE过程与程序执行<strong>并发</strong>进行，通过一个简单的<strong>交替位协议 (alternating-bit protocol)</strong> 实现。指针格式中包含一个<strong>epoch位</strong>，用于区分新旧指针版本，确保在CE期间访问旧指针仍能正确找到对象。</li>
<li><strong>双端压缩 (Dual-ended compaction)</strong>: 为了高效地容纳可能很大的重命名表（实现中占pad容量的50%），采用了<strong>双端压缩</strong>策略。<img alt="" src="../images/3f17e5fa2d3758d6c396a9a926148c41309fe24508cd334fd6e4ccd94d544690.jpg" /> <em>Fig. 11: Dual-ended compaction example. All objects are 2 words long, except E, which takes 4 words.</em><ul>
<li>重命名表被放置在旧数据区域的末尾之后。</li>
<li>压缩过程交替从旧区域的<strong>开头</strong>和<strong>末尾</strong>处理对象。</li>
<li>从开头压缩释放的空间用于存放<strong>新的紧凑对象块</strong>。</li>
<li>从末尾压缩释放的空间用于动态增长<strong>重命名表</strong>。</li>
</ul>
</li>
</ul>
<p><strong>在整体系统中的作用</strong></p>
<ul>
<li><strong>统一内存管理</strong>: CE过程是Hotpads设计的核心创新，它<strong>统一了</strong>传统上分离的<strong>缓存驱逐</strong>（基于局部性）和<strong>垃圾回收</strong>（基于可达性）两大机制。</li>
<li><strong>利用双重经验法则</strong>: 它同时利用了<strong>局部性原理 (locality principle)</strong> 和<strong>分代假说 (generational hypothesis)</strong>，使得内存层次结构的管理更加智能和高效。</li>
<li><strong>显著降低开销</strong>: 通过在硬件中并发、高效地执行CE，Hotpads将<strong>GC开销平均降低了8倍</strong>，这是其整体性能提升34%的关键因素之一。<img alt="" src="../images/d8b3161760d0f4d021edfc8e0f168343cb2b31f15c927b8b5fe64e29486b84db.jpg" /> <em>Fig. 14: Simulation results for single-threaded workloads.</em></li>
</ul>
<h3 id="4">4. 层级内对象分配<a class="headerlink" href="#4" title="Permanent link">&para;</a></h3>
<p><strong>核心机制与实现原理</strong></p>
<ul>
<li><strong>直接在L1 pad分配</strong>：Hotpads的<code>alloc</code>指令在创建新对象时，会直接在<strong>L1 pad</strong>的<strong>空闲空间 (free space)</strong> 中进行分配。这利用了L1 pad内部采用的<strong>bump pointer allocation</strong>（指针碰撞分配）机制，即新对象被简单地放置在已分配区域的末尾。</li>
<li><strong>无需主存后备存储</strong>：与传统系统不同，这些在L1 pad中分配的新对象<strong>不需要预先在主存中分配对应的后备存储空间</strong>。这意味着对象从诞生起就位于最快的存储层级，其首次访问就是一次<strong>L1命中</strong>，避免了昂贵的缓存未命中和主存访问开销。</li>
<li><strong>大对象分级处理</strong>：对于超过特定大小阈值的对象，Hotpads会将其分配到更高级别的pad中，以避免耗尽宝贵的L1空间。论文中给出的具体分配策略如下：<ul>
<li>尺寸 ≤ 512 B → 分配至 <strong>L1 pad</strong></li>
<li>512 B &lt; 尺寸 ≤ 4 KB → 分配至 <strong>L2 pad</strong></li>
<li>4 KB &lt; 尺寸 &lt; 128 KB → 分配至 <strong>L3 pad</strong></li>
<li>尺寸 ≥ 128 KB → 直接分配至 <strong>Main memory</strong></li>
</ul>
</li>
<li><strong>对象初始化</strong>：分配完成后，对象的<strong>type id</strong>会被写入其第一个字（word），而后续的所有字都会被<strong>清零</strong>，确保对象处于一个干净、可预测的初始状态。</li>
</ul>
<p><strong>在整体架构中的作用与优势</strong></p>
<ul>
<li><strong>消除分配开销</strong>：传统的内存分配（如<code>malloc</code>）通常涉及复杂的空闲链表管理或系统调用，而Hotpads的bump-pointer分配是<strong>O(1)常数时间</strong>操作，极大地加速了对象创建过程。</li>
<li><strong>提升数据局部性</strong>：新分配的对象天然位于L1，这使得程序在创建对象后立即对其进行初始化和操作时，能获得<strong>最佳的数据局部性</strong>，显著减少内存延迟。</li>
<li><strong>降低主存流量</strong>：由于大量短生命周期的对象（尤其是小对象）在其整个生命周期内都只存在于片上pads中，从未“触达”主存，因此<strong>大幅减少了对主存的读写流量</strong>。这一点在评估部分得到了验证，Hotpads相比基线系统将主存能量消耗降低了<strong>4.1倍</strong>。</li>
<li><strong>与CE过程协同</strong>：这种分配方式与**Collection-Eviction **(CE) 过程无缝衔接。当L1 pad空间不足时，CE过程会回收已死亡的对象，从而释放出连续的空闲空间供新的<code>alloc</code>操作使用，形成了一个高效的、硬件管理的内存循环。</li>
</ul>
<p><img alt="" src="../images/8abad735fb6373cc3647d17c2368a2d8ed6447c44fe1b6220320f46194507192.jpg" /> <em>Fig. 4: Example showing Hotpads’s key features.</em></p>
<p><strong>关键参数与配置</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">对象尺寸范围</th>
<th style="text-align: left;">分配目标层级</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">≤ 512 Bytes</td>
<td style="text-align: left;">L1 pad</td>
</tr>
<tr>
<td style="text-align: left;">512 Bytes – 4 KB</td>
<td style="text-align: left;">L2 pad</td>
</tr>
<tr>
<td style="text-align: left;">4 KB – 128 KB</td>
<td style="text-align: left;">L3 pad</td>
</tr>
<tr>
<td style="text-align: left;">≥ 128 KB</td>
<td style="text-align: left;">Main memory</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>输入输出关系</strong></p>
<ul>
<li><strong>输入</strong>：<ul>
<li><code>alloc</code>指令接收两个寄存器输入：<code>rs1</code>（指定对象大小，单位为word）和<code>rs2</code>（指定type id）。</li>
</ul>
</li>
<li><strong>输出</strong>：<ul>
<li>指令执行后，会在目标pad（通常是L1）的空闲空间中分配一块连续内存。</li>
<li>新分配对象的起始地址（即一个<strong>Hotpads指针</strong>）被写入目标寄存器<code>rp</code>。</li>
<li>该指针包含了嵌入的元数据，如对象大小和层级信息（见下图）。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/aa7f421464a9fee508f7ec1751fd796efdee2876a7909da1be9294af99d3053b.jpg" /> <em>Fig. 5: Hotpads pointer format.</em></p>
<h3 id="5">5. 规范层级与不变式<a class="headerlink" href="#5" title="Permanent link">&para;</a></h3>
<p><strong>规范层级与不变式的核心机制</strong></p>
<p>Hotpads 通过引入 <strong>规范层级 (canonical level)</strong> 的概念，并强制执行一组关键的 <strong>不变式 (invariants)</strong>，从根本上解决了在硬件中高效、安全地管理分层内存和指针重写的问题。这一机制是其能够统一垃圾回收（GC）与数据放置、并实现高效指针重写的基础。</p>
<ul>
<li>
<p><strong>规范层级 (canonical level) 的定义</strong>:</p>
<ul>
<li>每个对象都有一个 <strong>规范层级</strong>，它被定义为该对象自创建以来所达到的 <strong>最大层级</strong>。</li>
<li>对象的 <strong>规范地址 (canonical address)</strong> 是其在规范层级中的地址。</li>
<li>规范层级充当了对象的 <strong>“最终存储位置”</strong> 或 <strong>“后备存储”</strong>，类似于传统缓存层次结构中主存的角色，但任何层级都可以成为对象的规范层级。</li>
<li>对象可以在比其规范层级更小的层级（如 L1）中拥有副本，但其规范层级只会随着时间推移而 <strong>单调递增</strong>（即只能被逐出到更高层级，不能降级）。</li>
</ul>
</li>
<li>
<p><strong>指针格式与元数据</strong>:</p>
<ul>
<li>Hotpads 的指针不仅包含地址，还嵌入了 <strong>元数据</strong>。</li>
<li>如图 <img alt="" src="../images/aa7f421464a9fee508f7ec1751fd796efdee2876a7909da1be9294af99d3053b.jpg" /> <em>Fig. 5: Hotpads pointer format.</em> 所示，指针的高 16 位包含对象大小、以及一个 <strong>规范位 (canonical bit)</strong>。</li>
<li><strong>规范位</strong> 用于标识该指针是否指向对象的规范地址。这对于快速判断指针类型和决定是否需要重写至关重要。</li>
</ul>
</li>
</ul>
<p><strong>关键不变式及其作用</strong></p>
<p>系统强制执行四个核心不变式，其中以下两个对于分层管理和指针操作最为关键：</p>
<ul>
<li>
<p><strong>不变式 1: 对象始终存在于其规范层级</strong>。</p>
<ul>
<li>这确保了对象的规范层级是其数据的权威来源，简化了数据获取和一致性维护。</li>
</ul>
</li>
<li>
<p><strong>不变式 2: 非规范层级的对象副本只能存在于比其规范层级更小的层级中</strong>。</p>
<ul>
<li>这保证了层级结构的清晰性，防止了数据在层级间的混乱分布。</li>
</ul>
</li>
<li>
<p><strong>不变式 3: 一个层级的对象只能指向相同或更高层级的对象</strong>。</p>
<ul>
<li>这是实现 <strong>分层收集-驱逐 (CE)</strong> 过程的关键。它确保了在对某一层级（如 L1）执行 CE 时，无需担心有来自更高层级（如 L2）的指针指向 L1 中即将被移动或驱逐的对象，从而实现了 <strong>层级间的操作独立性</strong>。</li>
<li>当需要驱逐一个对象，而该对象又指向另一个非规范层级（如 L1）的对象时，系统会提升被指向对象的规范层级（例如从 L1 提升到 L2），以维持此不变式。如图 <img alt="" src="../images/16ecfacf52bb0eaf6a09e0bd725696a59e5008ecbe57a1dd57abf4d29518acf2.jpg" /> <em>Fig. 10: Example of an eviction that requires changing the canonical level of a non-evicted object (P).</em> 所示。</li>
</ul>
</li>
<li>
<p><strong>不变式 4: 如果一个对象在某个层级有副本，那么该对象本身或其规范副本必须存在于该层级或更高层级</strong>。</p>
<ul>
<li>这与不变式 3 协同工作，共同保障了 CE 过程的正确性和独立性。</li>
</ul>
</li>
</ul>
<p><strong>在整体系统中的作用</strong></p>
<ul>
<li>
<p><strong>简化指针重写</strong>:</p>
<ul>
<li>由于不变式 3 的存在，指针重写可以安全地 <strong>仅在 L1 层级进行</strong>。因为 L1 中的对象不可能被更高层级的对象引用，重写 L1 中的指针不会破坏其他层级的数据完整性。这使得 L1 能够实现高效的直接寻址，避免了昂贵的关联查找。</li>
</ul>
</li>
<li>
<p><strong>实现分层的收集-驱逐 (CE)</strong>:</p>
<ul>
<li>不变式 3 和 4 共同确保了每个 pad 可以 <strong>独立地</strong> 执行 CE 过程，而无需暂停或协调更高层级的操作。这极大地提高了 GC 的并发性和效率，将传统的 stop-the-world GC 开销降至最低。</li>
</ul>
</li>
<li>
<p><strong>保障内存安全与一致性</strong>:</p>
<ul>
<li>这套机制在硬件层面强制执行了内存安全规则，防止了悬空指针和非法内存访问。同时，它为对象级别的缓存一致性协议（如 MESI）提供了坚实的基础，因为对象的生命周期和移动路径是受控且可预测的。</li>
</ul>
</li>
</ul>
<hr />
<h2 id="4_1">4. 实验方法与实验结果<a class="headerlink" href="#4_1" title="Permanent link">&para;</a></h2>
<p><strong>实验设置</strong></p>
<ul>
<li><strong>硬件平台</strong>：使用 <strong>MaxSim</strong> 仿真平台，模拟一个 <strong>4-core</strong> 处理器。</li>
<li><strong>内存层次结构</strong>：采用三级结构，具体参数见下表。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: left;">Level</th>
<th style="text-align: left;">Cache/Pads Size</th>
<th style="text-align: left;">Associativity / Organization</th>
<th style="text-align: left;">Block/Subobject Size</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">L1</td>
<td style="text-align: left;">64 KB</td>
<td style="text-align: left;">4-way (Cache) / Direct-mapped (Pads)</td>
<td style="text-align: left;">8 bytes (access) / 64 bytes (object)</td>
</tr>
<tr>
<td style="text-align: left;">L2</td>
<td style="text-align: left;">1 MB</td>
<td style="text-align: left;">8-way</td>
<td style="text-align: left;">64 bytes</td>
</tr>
<tr>
<td style="text-align: left;">L3</td>
<td style="text-align: left;">16 MB</td>
<td style="text-align: left;">16-way</td>
<td style="text-align: left;">64 bytes</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>核心模型</strong>：基于 <strong>Westmere</strong> 的乱序执行核心。</li>
<li><strong>ISA 实现</strong>：在 x86 架构上通过未使用的操作码模拟 <strong>Hotpads ISA</strong>，并为物理寄存器添加 <strong>pointer bit</strong> 以区分指针和普通数据。</li>
<li><strong>软件栈</strong>：<ul>
<li>使用 <strong>Maxine JVM</strong> 作为 Java 虚拟机，并修改其 <strong>C1X JIT compiler</strong> 以生成符合 Hotpads ISA 的代码。</li>
<li><strong>Baseline (缓存系统)</strong>：使用经过调优的 <strong>stop-the-world generational GC</strong>，其中 <strong>young heap size</strong> 设为 <strong>16 MB</strong>（约为 LLC 大小的两倍）。</li>
<li><strong>Hotpads 系统</strong>：在硬件中执行并发的 <strong>Collection-Eviction (CE)</strong> 过程，在软件中对主存执行非分代的 <strong>stop-the-world GC</strong>。主存堆大小与 Baseline 保持一致，以确保公平比较。</li>
</ul>
</li>
<li><strong>工作负载</strong>：共 <strong>13</strong> 个 Java 基准测试程序，包括 <strong>10</strong> 个 <strong>DaCapo</strong> 套件、<strong>SPECjbb2005</strong> 以及来自 <strong>JgraphT</strong> 库的 <strong>PageRank</strong> 和 <strong>Coloring</strong>。</li>
</ul>
<p><strong>结果数据</strong></p>
<ul>
<li><strong>性能提升</strong>：<ul>
<li><strong>Hotpads</strong> 相比 <strong>Baseline</strong> 平均提升 <strong>34%</strong> 的性能，最高可达 <strong>86%</strong>（在 <code>lusearch</code> 上）。</li>
<li>性能提升主要来自两方面：<ul>
<li><strong>GC 开销</strong>：从 Baseline 的平均 <strong>11%</strong> 降低到 Hotpads 的 <strong>1.5%</strong>。</li>
<li><strong>应用运行时间</strong>：由于更好的内存性能，减少了 <strong>21%</strong>。</li>
</ul>
</li>
<li>即使与采用了 <strong>DRRIP</strong> 替换策略和 <strong>Nehalem</strong> 流式预取器的增强型缓存基线相比，Hotpads 依然领先 <strong>23%</strong>。</li>
</ul>
</li>
<li><strong>能效提升</strong>：<ul>
<li><strong>Hotpads</strong> 将内存层次结构的<strong>动态能耗</strong>降低了 <strong>2.6倍</strong>。</li>
<li>能耗降低的主要因素：<ul>
<li><strong>L1 pads</strong> 的直接访问能耗极低，比 L1 cache 命中能耗低 <strong>4.3倍</strong>。</li>
<li><strong>主存能耗</strong> 降低了 <strong>4.1倍</strong>。</li>
<li><strong>CE 过程</strong> 的能耗比软件 GC 低 <strong>2.9倍</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>内存访问效率</strong>：<ul>
<li><strong>平均内存访问时间 (AMAT)</strong> 比 Baseline 低 <strong>4%</strong>。</li>
<li><strong>片上容量利用率</strong>：L1 pads 的利用率为 <strong>35%</strong>，高于 Baseline 缓存的 <strong>29%</strong>。</li>
<li><strong>数据移动量</strong>：主存读写流量最高可减少 <strong>6.6倍</strong>，而仅使用 <strong>cache scrubbing</strong> 技术只能减少 <strong>66%</strong>。</li>
</ul>
</li>
<li><strong>多线程性能</strong>：在多线程工作负载上，由于 Maxine GC 本身不是并行的，Hotpads 的性能优势进一步扩大到 <strong>68%</strong>，同时能耗也降低了 <strong>2.7倍</strong>。</li>
<li><strong>对传统程序的支持</strong>：在 <strong>legacy mode</strong> 下运行未修改的 <strong>SPEC CPU2006</strong> 程序，Hotpads 仅比传统缓存慢 <strong>4%</strong>，证明了其良好的兼容性。</li>
</ul>
<p><img alt="" src="../images/d8b3161760d0f4d021edfc8e0f168343cb2b31f15c927b8b5fe64e29486b84db.jpg" /> <em>Fig. 14: Simulation results for single-threaded workloads.</em></p>
<p><strong>消融实验与关键机制分析</strong></p>
<ul>
<li><strong>指针重写 (Pointer Rewriting) 的有效性</strong>：<ul>
<li><strong>80%</strong> 的 L1 pad 访问被转化为<strong>直接访问</strong>，从而避免了关联查找。</li>
<li>这是 L1 pads 能效远超 L1 caches 的根本原因。</li>
<li><img alt="" src="../images/7f52b0241b94504b10c97efba7df1388240b0242b42b60cb47b9276ce21c8eba.jpg" /> <em>Fig. 19: CDFs of lengths and intervals for L1 CEs.</em></li>
</ul>
</li>
<li><strong>统一垃圾回收与驱逐 (Collection-Eviction, CE) 的开销</strong>：<ul>
<li>CE 过程非常轻量且并发执行。</li>
<li><strong>L1 CE</strong> 平均持续时间很短，且活跃周期占总周期的比例极小。</li>
<li>尽管 L1 pads 更小导致 CE 触发更频繁，但每次 CE 的成本也非常低（比 L3 CE 便宜约 <strong>1000倍</strong>）。</li>
<li><img alt="" src="../images/654379b33f525bc74eb9e3062b449f664941630600a3a07bc9cd11fbb5710336.jpg" /> <em>Fig. 17: Allocated, evicted, and collected bytes per pad level.</em></li>
<li><img alt="" src="../images/7f52b0241b94504b10c97efba7df1388240b0242b42b60cb47b9276ce21c8eba.jpg" /> <em>Fig. 19: CDFs of lengths and intervals for L1 CEs.</em></li>
</ul>
</li>
<li><strong>对象粒度 vs. 缓存行粒度</strong>：<ul>
<li><strong>对象粒度</strong>的数据移动显著提高了片上存储的利用率（<strong>35% vs 29%</strong>）。</li>
<li>对于短生命周期的对象，Hotpads 能在它们到达主存前就在片上 pads 中完成分配和回收，大幅减少了主存流量。</li>
<li><img alt="" src="../images/fae458bf2e3e7987056c372c37355e5abd361ec7b67f4a4d425bd0b9f7c601ce.jpg" /> <em>Fig. 16: Breakdown of bytes read and written per level.</em></li>
</ul>
</li>
<li><strong>与现有优化技术的对比</strong>：<ul>
<li><strong>Cache Scrubbing</strong> 技术通过在缓存中直接分配新对象和清理死亡对象，将性能提升了 <strong>17%</strong>，能耗降低了 <strong>22%</strong>。</li>
<li><strong>Hotpads</strong> 在此基础上进一步将性能提升了 <strong>15%</strong>，能耗再降低 <strong>2.1倍</strong>，这主要归功于其<strong>硬件管理的 CE 过程</strong>，它从根本上消除了年轻代 GC 的大部分开销。</li>
</ul>
</li>
<li><strong>对编译型语言的适用性</strong>：<ul>
<li>通过 <strong>GCBench</strong> 案例研究证明，即使对于 C 语言，只要使用 Hotpads ISA，也能获得巨大收益。</li>
<li><strong>Hotpads + Boehm GC</strong> 的性能接近于手动优化的 <strong>Custom Arena Allocator</strong>，同时保持了自动内存管理的简洁性，并实现了最低的内存能耗（比 glibc malloc 低 <strong>4.2倍</strong>）。</li>
</ul>
</li>
</ul>
<hr />












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.sections", "navigation.top", "navigation.indexes", "search.suggest", "search.highlight", "content.code.copy"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../../../javascripts/switcher.js"></script>
      
        <script src="../../../javascripts/smart_back.js"></script>
      
    
  </body>
</html>