
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://example.com/notes_repo/tolerate-it-if-you-cannot-reduce-it-handling-latency-in-tiered-memory/ELI5_notes/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Tolerate It if You Cannot Reduce It: Handling Latency in Tiered Memory 通俗讲解 - BlaBlaCut</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#tolerate-it-if-you-cannot-reduce-it-handling-latency-in-tiered-memory" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="BlaBlaCut" class="md-header__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            BlaBlaCut
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Tolerate It if You Cannot Reduce It: Handling Latency in Tiered Memory 通俗讲解
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到深色模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换到深色模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到浅色模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换到浅色模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="BlaBlaCut" class="md-nav__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    BlaBlaCut
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/Recent/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Recent
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/awesome-data-prefetchers/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Awesome Data Prefetchers
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/micro-2025/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    MICRO 2025
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#0" class="md-nav__link">
    <span class="md-ellipsis">
      
        0. 整体创新点通俗解读
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1-prefetchable-regions-eli5" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. Prefetchable Regions (ELI5)
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-linden-compiler-eli5" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. Linden Compiler (ELI5)
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-linden-runtime-eli5" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. Linden Runtime (ELI5)
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-tier-aware-prefetch-distance-adaptation-eli5" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. Tier-Aware Prefetch Distance Adaptation (ELI5)
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-selective-hardware-prefetcher-control-eli5" class="md-nav__link">
    <span class="md-ellipsis">
      
        5. Selective Hardware Prefetcher Control (ELI5)
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="tolerate-it-if-you-cannot-reduce-it-handling-latency-in-tiered-memory">Tolerate It if You Cannot Reduce It: Handling Latency in Tiered Memory 通俗讲解<a class="headerlink" href="#tolerate-it-if-you-cannot-reduce-it-handling-latency-in-tiered-memory" title="Permanent link">&para;</a></h1>
<h3 id="0">0. 整体创新点通俗解读<a class="headerlink" href="#0" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击 (The "Why")</strong></p>
<p>当前的 <strong>tiered memory</strong>（分层内存）系统，比如结合了本地 DRAM 和 CXL-attached memory 的架构，面临一个根本性的思维盲区：它们只想着“<strong>减少延迟</strong>”（Reduce Latency），也就是通过把热数据迁移到快 tier 来解决问题。这个思路本身没错，但它忽略了一个关键事实——<strong>不是所有延迟都值得或能够被消除</strong>。</p>
<ul>
<li>在 CXL 这种高延迟、低带宽的慢 tier 上，<strong>盲目迁移</strong>会带来巨大开销。更糟的是，现有的 <strong>hardware prefetcher</strong>（硬件预取器）是为同构 DRAM 设计的，在 CXL 上会因为带宽瓶颈而<strong>疯狂制造 contention</strong>（争用），反而让延迟飙升到 <strong>1500ns</strong>（见 Figure 3），性能直接崩盘。</li>
<li>同时，<strong>software prefetching</strong>（软件预取）如果沿用 DRAM 的策略，也会失效。因为 CXL 的延迟几乎是 DRAM 的 <strong>2.1 倍</strong>（237ns vs 112ns），但预取距离却没变，导致数据要么来得太晚（没藏住延迟），要么来得太早（被 cache evict 掉）。</li>
<li>所以，问题的核心在于：<strong>系统只有“迁移”这一招，缺乏“容忍”延迟的第二条腿</strong>。当数据因为各种原因（比如容量限制、迁移开销）不得不留在慢 tier 时，系统就束手无策了。</li>
</ul>
<p><strong>通俗比方 (The Analogy)</strong></p>
<p>想象你管理一个大型仓库，有<strong>近区</strong>（快，但小）和<strong>远区</strong>（慢，但大）两个库房。</p>
<ul>
<li>传统做法就像一个固执的仓库经理，他坚信：“所有热销品必须放近区！”于是他不停地把货搬来搬去。但搬运本身要花时间、占通道，有时候搬着搬去，发现近区满了，或者搬运的车堵在路上（带宽争用），反而耽误了出货。</li>
<li>而这篇论文的思路是：<strong>“既然有些热销品暂时搬不进近区，那就别硬搬了。我们换个思路——提前下单，让货车在客户下单前就把货从远区运到配送站（CPU cache）等着。”</strong></li>
<li>这个“提前下单”的策略就是 <strong>prefetching</strong>（预取）。关键是，给远区下单不能和给近区一样。远区路远，你得<strong>更早下单</strong>（更大的 prefetch distance），而且不能一次性下太多单，否则会把唯一的运输通道（CXL link）堵死。</li>
</ul>
<p>这就是论文标题 <strong>“Tolerate It if You Cannot Reduce It”</strong> 的精髓：<strong>能搬则搬，不能搬就忍（通过聪明地预取来忍）</strong>。</p>
<p><strong>关键一招 (The "How")</strong></p>
<p>作者没有推翻现有的内存分层系统，而是巧妙地在其中<strong>嫁接了一个“感知-决策-执行”的智能预取控制环</strong>，其核心是一个名为 <strong>Linden</strong> 的编译器-运行时协同系统。</p>
<ul>
<li>
<p><strong>感知层</strong>：</p>
<ul>
<li><strong>编译器</strong>在编译时分析代码，找出哪些内存区域是 <strong>prefetchable</strong>（可预取的），并标注其访问模式（如 stride, sequential）和理想的预取距离。这些信息被打包成“hints”注入到二进制程序中。</li>
<li><strong>运行时</strong>则负责动态监控：通过硬件性能计数器（如 <code>L2_RQSTS.ALL_HWPF</code>）感知<strong>硬件预取的有效性</strong>，通过 Intel PEBS 等机制跟踪<strong>页面热度</strong>（hotness），并通过带宽/延迟探针感知<strong>CXL 链路的拥塞状况</strong>。</li>
</ul>
</li>
<li>
<p><strong>决策与执行层</strong>（Listing 1 中的 <code>reduce</code> 和 <code>tolerate</code> 方法）：</p>
<ul>
<li><strong>动态调整预取策略</strong>：当一个被软件预取的页面从 DRAM <strong>migrate</strong>（迁移）到 CXL 时，运行时会<strong>立刻介入</strong>，利用 JIT 技术<strong>重写</strong>对应的预取指令，将其 <strong>prefetch distance</strong> 从 DRAM 最优的 <strong>4</strong> 调整为 CXL 最优的 <strong>7</strong>（见 Figure 4）。这就解决了“timeliness”（及时性）问题。</li>
<li><strong>选择性开关硬件预取</strong>：当检测到 CXL 链路拥塞时，系统<strong>不会一刀切地关掉所有核心的硬件预取器</strong>。它会查自己的 <strong>prefetchability table</strong>（见 Table 1），只关掉那些正在访问 CXL 内存的 core 的硬件预取，让访问 DRAM 的 core 不受影响。这避免了“城门失火，殃及池鱼”。</li>
<li><strong>反直觉的数据放置</strong>：最妙的一招是，对于<strong>既热又高度可预取</strong>的数据，系统甚至会<strong>主动将其 demote</strong>（降级）到 CXL！因为预取器能完美 hide 掉 CXL 的延迟，而把它留在 DRAM 反而浪费了宝贵的快速空间给其他无法被预取的数据。实验显示，这样做能带来 <strong>7%</strong> 的性能提升。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/3809248474e6c7ccbbedb62aa62164adcbf81725375e6f86f4075678f2e15501.jpg" /></p>
<p><em>Figure 5: Linden consists of a compiler and runtime. Compiler takes a program and finds the prefetchable regions in the program. Runtime is responsible for detecting hotness, hardware monitoring, and compiler hints to enforce different policies. Runtime able to migrate pages between the tiers, enable/disable hardware prefetchers and change the software behavior in terms prefetchability.</em></p>
<p>总而言之，Linden 的核心创新在于将 <strong>latency reduction</strong>（通过迁移）和 <strong>latency tolerance</strong>（通过智能预取）<strong>统一到一个协同的框架下</strong>，让系统能根据数据的特性和硬件的实时状态，动态选择最优的延迟应对策略，而不是只会“搬家”这一种笨办法。</p>
<h3 id="1-prefetchable-regions-eli5">1. Prefetchable Regions (ELI5)<a class="headerlink" href="#1-prefetchable-regions-eli5" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击</strong></p>
<ul>
<li>传统的内存分层系统（tiered memory）只想着“<strong>减少延迟</strong>”——把热数据挪到快的 DRAM，冷数据扔到慢的 CXL。这招在带宽充足时挺好用。</li>
<li>但问题来了：CXL 的 <strong>带宽远低于 DRAM</strong>（论文里差了近 6 倍），一旦你疯狂迁移数据或让硬件预取器（hardware prefetcher）瞎猜，就会在 CXL 链路上造成严重<strong>带宽争抢</strong>。</li>
<li>更糟的是，现有软/硬件预取器都是为<strong>同构 DRAM</strong> 设计的。它们不知道 CXL 的延迟更高、带宽更窄，于是：<ul>
<li>硬件预取器会发出太多无效请求，在高并发下反而让延迟<strong>飙升到 1500ns</strong>（见 Figure 3）；</li>
<li>软件预取器用的 <strong>prefetch distance</strong>（预取距离）是为 DRAM 调的，对 CXL 来说太短，根本来不及把数据提前搬进 cache（见 Figure 4）。</li>
</ul>
</li>
</ul>
<p>简言之：<strong>只靠“迁移”来减少延迟，在带宽受限的异构内存里行不通；而盲目“容忍”延迟（靠预取），又会因不匹配硬件特性而适得其反</strong>。</p>
<hr />
<p><strong>通俗比方</strong></p>
<p>想象你在两个仓库之间调度货物：</p>
<ul>
<li><strong>快仓</strong>（DRAM）：离工厂近，运力强（高带宽），但租金贵。</li>
<li><strong>慢仓</strong>（CXL）：离得远（高延迟），卡车少（低带宽），但便宜。</li>
</ul>
<p>传统做法是：把畅销品全塞进快仓。但如果畅销品太多，快仓放不下，你就只能把一部分留在慢仓——这时，如果还按老办法派车（比如每小时派一辆），等货到厂早就停工了。</p>
<p>Linden 的思路是：<strong>别光想着换仓库，先看看哪些货能“精准预约送达”</strong>。\
它把货物分成“<strong>可预约区域</strong>”（prefetchable regions）——比如那些每天固定时间要 100 个螺丝的生产线（顺序访问），你完全可以根据路程（延迟）和车速（带宽），算出<strong>提前多久下单</strong>（prefetch distance = 7 而不是 4）。而对于随机要货的维修组（指针追逐），则用另一种预约方式（软件预取 + JIT 调整）。</p>
<p><img alt="" src="../images/ae1bb199e2a6c62bf74c0e61f6f7a3b45062625cd7e1f5a9eb6485944eef2587.jpg" /></p>
<p><em>Figure 4: DRAM and CXL have different optimal prefetch distances. For example, in the scan microbenchmark, DRAM performs best with a prefetch distance of 4, while CXL requires a longer distance of 7 due to its higher latency.</em></p>
<hr />
<p><strong>关键一招</strong></p>
<p>作者没有抛弃“迁移”，而是<strong>在迁移决策中引入了“预取可行性”作为新维度</strong>。具体来说：</p>
<ul>
<li>
<p><strong>定义了一个结构化的“预取区域”</strong>（prefetchable region），它不只是一页内存，而是一组具有<strong>相似访问模式</strong>的页，并附带四个关键属性：</p>
<ul>
<li><strong>Prefetchability ratio</strong>：这个区域能被预取“拯救”的比例（0~1），越高说明越值得预取；</li>
<li><strong>Access pattern type</strong>：是顺序（stride）、空间局部（spatial）还是指针追逐（irregular）？决定用硬件还是软件预取；</li>
<li><strong>Target &amp; prefetch distance</strong>：明确哪个 load 对应哪个 prefetch，以及当前最优的提前量；</li>
<li><strong>Freshness</strong>：防止用过期的访问模式做决策。</li>
</ul>
</li>
<li>
<p><strong>运行时动态联动</strong>：</p>
<ul>
<li>当一个预取区域被迁移到 CXL 时，runtime <strong>自动把它的 prefetch distance 从 4 改成 7</strong>（见 Figure 4）；</li>
<li>如果检测到 CXL 链路拥塞（通过硬件计数器），就<strong>只关掉访问慢仓的 core 的硬件预取器</strong>，而不是全局关闭（避免误伤 DRAM 访问）；</li>
<li>甚至可以反过来：<strong>如果一个区域又热又高度可预取，干脆把它留在 CXL</strong>——因为预取已经能 hide 掉延迟，省下的 DRAM 空间留给真正无法预取的数据。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/3809248474e6c7ccbbedb62aa62164adcbf81725375e6f86f4075678f2e15501.jpg" /></p>
<p><em>Figure 5: Linden consists of a compiler and runtime. Compiler takes a program and finds the prefetchable regions in the program. Runtime is responsible for detecting hotness, hardware monitoring, and compiler hints to enforce different policies. Runtime able to migrate pages between the tiers, enable/disable hardware prefetchers and change the software behavior in terms prefetchability.</em></p>
<p>本质上，Linden 把“<strong>是否迁移</strong>”这个问题，从单一的“hot/cold”判断，升级成了一个 <strong>多目标优化问题</strong>：在“减少延迟”（迁移）和“容忍延迟”（预取）之间做智能权衡。而 <strong>prefetchable regions 就是实现这种权衡的最小决策单元</strong>。</p>
<h3 id="2-linden-compiler-eli5">2. Linden Compiler (ELI5)<a class="headerlink" href="#2-linden-compiler-eli5" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击 (The "Why")</strong></p>
<ul>
<li>传统的 <strong>tiered memory</strong> 系统（比如 DRAM + CXL）只想着“<strong>把热数据搬快点</strong>”，也就是通过 page migration 来 <strong>reduce latency</strong>。这在数据访问模式简单、局部性好的时候很有效。</li>
<li>但现实是，很多应用的 hot data 并不一定能被高效迁移（比如数据太大、迁移开销高），或者即使迁移到 fast tier，依然有延迟。</li>
<li>更关键的是，现有系统完全忽略了：<strong>有些延迟其实可以“忍”过去</strong>——只要提前把数据拿进 cache，CPU 就不用干等。这就是 <strong>tolerate latency</strong> 的思路。</li>
<li>问题在于，现有的 <strong>hardware/software prefetcher</strong> 都是为 <strong>homogeneous memory</strong>（纯 DRAM）设计的。直接用在 CXL 上会出大问题：<ul>
<li>Hardware prefetcher 不知道 CXL 带宽窄，疯狂发请求反而造成 <strong>bandwidth contention</strong>，让延迟从 237ns 暴涨到 <strong>1500ns</strong>（见 Figure 3）。</li>
<li>Software prefetcher 用的 <strong>prefetch distance</strong> 是为 DRAM 调的（比如距离=4），但在 CXL 上需要更远（比如距离=7）才能 cover 住高延迟（见 Figure 4）。</li>
</ul>
</li>
<li>所以，系统缺一个“<strong>先知</strong>”：能在程序跑之前，就告诉 runtime “<strong>哪些内存区域值得 prefetch，该怎么 prefetch</strong>”。</li>
</ul>
<hr />
<p><strong>通俗比方 (The Analogy)</strong></p>
<ul>
<li>想象你是个快递调度中心经理（runtime），手下有两种仓库：市中心闪电仓（DRAM）和郊区大仓（CXL）。</li>
<li>以前的做法是：看哪个商品卖得火（hotness），就把它挪到闪电仓。但如果闪电仓满了，或者挪货太慢，顾客（CPU）还是得等。</li>
<li>Linden Compiler 就像是你的 <strong>智能订单分析员</strong>。他提前看销售数据（源代码），发现：“哦，每周一早上 9 点，总有一批人要买《周一晨报》，而且他们都是按固定路线来的。”</li>
<li>于是他告诉你：“别急着把报纸全搬进闪电仓，<strong>你只要在周日半夜，提前把下周一的报纸从郊区大仓发车送到配送站（cache）就行</strong>。” 这样，即使报纸还在郊区仓，顾客也感觉不到延迟。</li>
<li>但他不会对“随机购买的限量球鞋”这么做，因为没法预测。</li>
</ul>
<hr />
<p><strong>关键一招 (The "How")</strong></p>
<ul>
<li>Linden Compiler 的核心动作不是自己去做 prefetch，而是 <strong>给 runtime 提供精准的“作战地图”</strong>。</li>
<li>它通过 <strong>pluggable backends</strong>（比如传统编译器 pass 或 ML 模型）扫描源代码，识别出具有 <strong>predictable access pattern</strong> 的循环或数据结构。</li>
<li>然后，它 <strong>instrument</strong> 原始二进制，在关键位置插入轻量级的 <strong>helper functions</strong>。</li>
<li>这些 helper functions 在程序运行时会被触发，向 runtime 报告：<ul>
<li>当前线程 ID</li>
<li>涉及的 <strong>memory region</strong>（一组 pages）</li>
<li>访问模式 <strong>pattern</strong>（如 stride, sequential）</li>
<li>初始的 <strong>prefetchability ratio</strong>（预测能隐藏多少延迟）</li>
</ul>
</li>
<li>这个信息最终填入 runtime 维护的 <strong>prefetchability table</strong>（见 Table 1），成为后续决策（迁移、开关硬件 prefetcher、调整软件 prefetch distance）的依据。</li>
<li><img alt="" src="../images/3809248474e6c7ccbbedb62aa62164adcbf81725375e6f86f4075678f2e15501.jpg" /></li>
</ul>
<p><em>Figure 5: Linden consists of a compiler and runtime. Compiler takes a program and finds the prefetchable regions in the program. Runtime is responsible for detecting hotness, hardware monitoring, and compiler hints to enforce different policies. Runtime able to migrate pages between the tiers, enable/disable hardware prefetchers and change the software behavior in terms prefetchability.</em></p>
<ul>
<li>换句话说，作者并没有让 compiler 直接生成 prefetch 指令，而是巧妙地 <strong>把“能不能 prefetch”这个语义信息，从 compile-time 传递到 runtime</strong>，让 runtime 能结合 <strong>实时的 hotness 和 hardware contention</strong> 做出最合适的 <strong>reduce or tolerate</strong> 决策。</li>
</ul>
<h3 id="3-linden-runtime-eli5">3. Linden Runtime (ELI5)<a class="headerlink" href="#3-linden-runtime-eli5" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击 (The "Why")</strong></p>
<ul>
<li>传统的 <strong>tiered memory</strong> 系统（比如 DRAM + CXL）只做一件事：把热数据迁移到快层，冷数据扔到慢层。这叫 <strong>latency reduction</strong>（延迟削减）。</li>
<li>但问题在于：<strong>不是所有热数据都值得留在快层</strong>。有些热数据访问模式非常规整（比如顺序扫描），即使放在慢层，只要提前预取（prefetch），CPU 根本感觉不到延迟。</li>
<li>更糟的是，现有系统对 <strong>prefetcher</strong> 是“放养”状态：<ul>
<li><strong>Hardware prefetcher</strong> 在 CXL 上会疯狂发请求，但 CXL 带宽只有 DRAM 的 1/6，结果造成 <strong>严重带宽争用</strong>，反而让延迟飙升（如 Figure 3 所示，延迟从 237ns 暴涨到 1500ns）。</li>
<li><strong>Software prefetcher</strong> 用的是为 DRAM 调优的 <strong>prefetch distance</strong>，放到高延迟的 CXL 上就“太晚了”，根本藏不住延迟（Figure 4 显示 CXL 需要距离 7，DRAM 只需 4）。</li>
</ul>
</li>
<li>所以，旧思路是“<strong>能迁就迁</strong>”，但忽略了“<strong>能忍则忍</strong>”——对于可预测的访问，与其费劲迁移，不如让它待在慢层，靠聪明的 prefetch 来容忍延迟。</li>
</ul>
<p><img alt="" src="../images/82e82afcd67dcb0186eb4c930aea9f218f378027d44fe0d2df88d72d5abd4c62.jpg" /></p>
<p><em>Figure 3: Under high load, prefetching causes latency to increase dramatically at lower loads compared to when prefetching is disabled, resulting in up to 6.3× higher latency.</em></p>
<p><img alt="" src="../images/ae1bb199e2a6c62bf74c0e61f6f7a3b45062625cd7e1f5a9eb6485944eef2587.jpg" /></p>
<p><em>Figure 4: DRAM and CXL have different optimal prefetch distances. For example, in the scan microbenchmark, DRAM performs best with a prefetch distance of 4, while CXL requires a longer distance of 7 due to its higher latency.</em></p>
<hr />
<p><strong>通俗比方 (The Analogy)</strong></p>
<p>想象一个图书馆（内存系统）有两个区域：</p>
<ul>
<li><strong>A区（DRAM）</strong>：就在阅览室旁边，取书只要 1 分钟。</li>
<li><strong>B区（CXL）</strong>：在地下室，取书要 2.5 分钟。</li>
</ul>
<p>传统管理员（tiering system）的做法是：谁常看的书，就搬到 A 区。但 Linden 的管理员更聪明：</p>
<ul>
<li>他先问：“这本书是<strong>按顺序读</strong>的（比如字典），还是<strong>随机翻</strong>的（比如查资料）？”<ul>
<li>如果是顺序读，他就说：“别搬了，我让助手<strong>提前下去拿好下一章</strong>，你读完这页，下一页刚好送到。” 这就是 <strong>tolerate latency by prefetching</strong>。</li>
<li>如果是随机翻，那才真的搬上来。</li>
</ul>
</li>
<li>而且，如果发现地下室电梯（CXL link）太挤，他会立刻让助手<strong>暂停下去拿书</strong>（disable hardware prefetcher），避免堵死。</li>
<li>如果书被临时搬到了地下室，他会马上调整助手出发的时间（<strong>动态改 prefetch distance</strong>），确保书还是能准时送到。</li>
</ul>
<p>这个管理员手里有三张表：<strong>读者偏好表</strong>（compiler hints）、<strong>热门书籍排行榜</strong>（hotness）、<strong>电梯实时拥堵监控</strong>（hardware counters）。他根据这三张表动态决策。</p>
<p><img alt="" src="../images/3809248474e6c7ccbbedb62aa62164adcbf81725375e6f86f4075678f2e15501.jpg" /></p>
<p><em>Figure 5: Linden consists of a compiler and runtime. Compiler takes a program and finds the prefetchable regions in the program. Runtime is responsible for detecting hotness, hardware monitoring, and compiler hints to enforce different policies. Runtime able to migrate pages between the tiers, enable/disable hardware prefetchers and change the software behavior in terms prefetchability.</em></p>
<hr />
<p><strong>关键一招 (The "How")</strong></p>
<p>Linden Runtime 的核心创新，是在传统 tiering 的“迁移决策”之外，<strong>增加了一个基于上下文的 prefetch 控制平面</strong>。它没有推翻现有机制，而是在其上叠加了一层智能调度：</p>
<ul>
<li>
<p>它把决策依据从单一的 <strong>hotness</strong>，扩展为三位一体的信号：</p>
<ul>
<li><strong>Compiler hints</strong>：标记哪些内存区域是 <strong>prefetchable</strong>（如 Table 1 所示，包含 pattern, ratio, target 等）。</li>
<li><strong>Page hotness</strong>：沿用传统指标，判断数据是否频繁访问。</li>
<li><strong>Real-time hardware monitoring</strong>：持续采样 <strong>bandwidth utilization</strong>、<strong>useless prefetches</strong>、<strong>tier-specific congestion</strong>。</li>
</ul>
</li>
<li>
<p>基于这三者，Runtime 动态执行三种操作：</p>
<ul>
<li><strong>Page migration</strong>：对<strong>不可预取的热数据</strong>，依然迁移到快层（Reduce）。</li>
<li><strong>Hardware prefetcher control</strong>：通过 MSR 寄存器，<strong>按核粒度开关</strong>硬件预取器。例如，只关掉访问 CXL 的核心的预取，不影响 DRAM 用户。</li>
<li><strong>Software prefetch adaptation</strong>：<ul>
<li>利用 JIT 或二进制重写，<strong>动态调整 prefetch distance</strong>。当页面从 DRAM 迁移到 CXL 时，自动把距离从 4 改成 7。</li>
<li>甚至可以<strong>按需插入新的 prefetch 指令</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>其策略引擎（Listing 1）的核心逻辑是：“<strong>Tolerate it if you cannot reduce it</strong>”：</p>
<ul>
<li>如果一个区域又热又可预取，<strong>反而可以故意把它留在慢层</strong>，省下宝贵的 DRAM 空间给真正需要它的随机访问数据。</li>
<li>实验证明，这样做在特定场景下能带来 <strong>7% 的性能提升</strong>。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/05dde22738dbf5f005fff77c457cc574ca7db2c2bee35b687336c9ac65234763.jpg" /></p>
<p><em>Table 1: An example of a prefetchability table.</em></p>
<p><img alt="" src="../images/4950cea33d775343cb93b18962b015f4b21456804391e0fe6b9d3468dafd7f78.jpg" /></p>
<p><em>Listing 1: Algorithm for policy enforcement in the Linden runtime.</em></p>
<h3 id="4-tier-aware-prefetch-distance-adaptation-eli5">4. Tier-Aware Prefetch Distance Adaptation (ELI5)<a class="headerlink" href="#4-tier-aware-prefetch-distance-adaptation-eli5" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击 (The "Why")</strong></p>
<ul>
<li>传统的 <strong>软件预取（Software Prefetching）</strong> 在设计时，通常假设内存是<strong>同构的（homogeneous）</strong>，即所有数据访问延迟都差不多。因此，它会用一个固定的 <strong>prefetch distance</strong>（比如提前4个元素）来发出预取指令。</li>
<li>但在 <strong>Tiered Memory（分层内存）</strong> 系统里，这个假设崩了。数据可能今天在 <strong>低延迟的 DRAM</strong>（112ns），明天就被迁移到 <strong>高延迟的 CXL</strong>（237ns）。同一个 prefetch distance，在 DRAM 上刚刚好，在 CXL 上就太晚了——数据还没进 Cache，程序就已经卡住等它了。</li>
<li>更糟的是，如果为了 CXL 把距离设得太长，数据又可能在 DRAM 里被<strong>提前太久加载</strong>，结果在真正用到之前就被别的数据挤出 Cache，白忙活一场。这就是 <strong>“timeliness”（及时性）</strong> 的两难困境。</li>
</ul>
<p><strong>通俗比方 (The Analogy)</strong></p>
<ul>
<li>想象你是个快递调度员，要给两个仓库送货：一个是市内<strong>本地仓</strong>（30分钟达），一个是<strong>郊区仓</strong>（90分钟达）。</li>
<li>以前只有一个本地仓，你总是提前30分钟下单，货刚好准时到。</li>
<li>现在系统自动把货在两个仓之间调来调去。如果你还是死板地提前30分钟下单：<ul>
<li>货在郊区仓？那肯定迟到，生产线停工。</li>
<li>货在本地仓但你提前90分钟下单？货早就到了，结果堆在门口被偷了（Cache Eviction）。</li>
</ul>
</li>
<li>Linden 的做法是：<strong>给每个包裹贴个标签，标明它现在在哪个仓</strong>。调度系统一看到标签变了，立刻动态调整下单时间——本地仓提前30分钟，郊区仓提前90分钟。这样，无论货在哪，都能<strong>刚好在需要时送到门口</strong>。</li>
</ul>
<p><strong>关键一招 (The "How")</strong></p>
<ul>
<li>作者没有重新发明预取器，而是巧妙地在 <strong>Page Migration（页面迁移）</strong> 和 <strong>Prefetch Instruction（预取指令）</strong> 之间架了一座桥。</li>
<li>具体来说：<ul>
<li><strong>编译器阶段</strong>：先静态分析代码，识别出哪些内存区域是 <strong>prefetchable</strong> 的，并在二进制里埋点（instrumentation），记录下这些区域的访问模式和初始的 prefetch distance。</li>
<li><strong>运行时阶段</strong>：Linden Runtime 持续监控页面是否在 <strong>DRAM ↔ CXL</strong> 之间迁移。</li>
<li><strong>关键扭转</strong>：一旦检测到某个包含预取指令的页面被迁移到了新 tier，Runtime 就会<strong>立刻介入</strong>，通过 <strong>JIT（Just-In-Time Compilation）</strong> 技术，<strong>动态重写（rewrite）</strong> 那条预取指令里的 distance 参数。<ul>
<li>例如，当数据从 DRAM <strong>demote</strong> 到 CXL 时，把 <code>prefetch(distance=4)</code> 改成 <code>prefetch(distance=7)</code>。</li>
<li>反之，当数据被 <strong>promote</strong> 回 DRAM 时，再改回 <code>distance=4</code>。</li>
</ul>
</li>
</ul>
</li>
<li>这个机制的核心在于，它把 <strong>“数据位置”</strong> 和 <strong>“预取时机”</strong> 绑定成了一个闭环反馈系统，而不是像传统方法那样，让两者脱节。</li>
</ul>
<p><img alt="" src="../images/ae1bb199e2a6c62bf74c0e61f6f7a3b45062625cd7e1f5a9eb6485944eef2587.jpg" /></p>
<p><em>Figure 4: DRAM and CXL have different optimal prefetch distances. For example, in the scan microbenchmark, DRAM performs best with a prefetch distance of 4, while CXL requires a longer distance of 7 due to its higher latency.</em></p>
<p>上图清晰地展示了这个核心思想：<strong>DRAM 和 CXL 有着截然不同的最优 prefetch distance</strong>。Linden 的价值就在于，它能确保系统始终运行在这个“最优值”上，而不是在一个对任何 tier 都不合适的固定值上将就。</p>
<h3 id="5-selective-hardware-prefetcher-control-eli5">5. Selective Hardware Prefetcher Control (ELI5)<a class="headerlink" href="#5-selective-hardware-prefetcher-control-eli5" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击</strong></p>
<ul>
<li>传统的内存分层系统（如 DRAM + CXL）在处理 <strong>硬件预取器（Hardware Prefetcher）</strong> 时，采用的是“一刀切”策略：要么全开，要么全关。</li>
<li>这在 <strong>异构内存带宽</strong> 场景下非常难受。CXL 的带宽只有 DRAM 的约 <strong>1/6</strong>（46 GB/s vs. 271 GB/s），一旦多个核心同时触发大量预取请求，CXL 链路就会严重拥塞。</li>
<li>更糟的是，即使某些核心只访问 <strong>本地 DRAM</strong>（带宽充足、无拥塞），它们也会被连累——因为全局关闭预取器后，这些本可受益于预取的快速访问也失去了加速机会。</li>
<li>结果就是：<strong>慢的没救成，快的还被拖垮了</strong>，整体性能反而下降（论文提到最高恶化 <strong>19%</strong>）。</li>
</ul>
<p><img alt="" src="../images/e80a467b48594078b5b1c12b1d80f001962739efceeed5f8a319375dd13ceb5a.jpg" /></p>
<p><em>Figure 2: When the number of threads increases the prefetching effectiveness of CXL decreases while DRAM being constant, and for high number of threads prefetching hurts the performance on CXL.</em></p>
<hr />
<p><strong>通俗比方</strong></p>
<p>想象一个双车道高速公路收费站：</p>
<ul>
<li><strong>快车道（DRAM）</strong>：ETC 自动抬杆，车流顺畅。</li>
<li><strong>慢车道（CXL）</strong>：人工收费，窗口少、速度慢，高峰期排长队。</li>
</ul>
<p>现在，传统做法是：只要慢车道堵了，就<strong>把整个收费站的所有ETC都关掉</strong>，强制所有车走人工通道。结果？</p>
<ul>
<li>慢车道确实压力小了点（因为没人预取了），</li>
<li>但快车道上那些本来能秒过的车，也被迫排队，<strong>整体通行效率暴跌</strong>。</li>
</ul>
<p>Linden 的做法是：<strong>只关慢车道入口的ETC引导牌</strong>，让去慢车道的车别提前变道插队；而快车道的ETC照常工作，该秒过还是秒过。这样，<strong>各走各的，互不干扰</strong>。</p>
<hr />
<p><strong>关键一招</strong></p>
<p>作者并没有沿用“全局开关”的粗粒度控制，而是巧妙地引入了 <strong>基于访问目标的细粒度预取器调控机制</strong>：</p>
<ul>
<li>Linden 的运行时系统会持续追踪：<ul>
<li>哪些 <strong>core</strong> 正在访问哪些 <strong>memory tier</strong>（通过页表或性能计数器）；</li>
<li>当前 <strong>CXL 链路是否拥塞</strong>（通过带宽/延迟监控）。</li>
</ul>
</li>
<li>一旦检测到 CXL 出现拥塞，它<strong>不会全局关闭硬件预取器</strong>，而是：<ul>
<li><strong>仅对那些正在（或将要）访问 CXL 内存的 core</strong>，通过 <strong>MSR 寄存器</strong> 动态关闭其硬件预取功能；</li>
<li>同时，<strong>允许访问 DRAM 的 core 继续使用硬件预取</strong>，维持其高性能。</li>
</ul>
</li>
<li>这个决策依赖于 Linden 构建的 <strong>prefetchability table</strong>（见下表），其中记录了每个内存区域被哪些线程以何种模式访问。</li>
</ul>
<p><img alt="" src="../images/05dde22738dbf5f005fff77c457cc574ca7db2c2bee35b687336c9ac65234763.jpg" /></p>
<p><em>Table 1: An example of a prefetchability table.</em></p>
<p>这种“<strong>按需禁用、精准隔离</strong>”的策略，本质上是将预取控制从 <strong>系统级（system-wide）</strong> 下沉到了 <strong>核心-内存域级（core-to-tier-aware）</strong>，从而在容忍慢速内存延迟的同时，<strong>保护了快速内存的性能不受牵连</strong>。</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.sections", "navigation.top", "navigation.indexes", "search.suggest", "search.highlight", "content.code.copy"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../../../javascripts/switcher.js"></script>
      
    
  </body>
</html>