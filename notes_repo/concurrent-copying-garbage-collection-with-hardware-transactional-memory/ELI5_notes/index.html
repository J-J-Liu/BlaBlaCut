
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://example.com/notes_repo/concurrent-copying-garbage-collection-with-hardware-transactional-memory/ELI5_notes/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Concurrent Copying Garbage Collection with Hardware Transactional Memory 通俗讲解 - BlaBlaCut</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#concurrent-copying-garbage-collection-with-hardware-transactional-memory" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="BlaBlaCut" class="md-header__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            BlaBlaCut
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Concurrent Copying Garbage Collection with Hardware Transactional Memory 通俗讲解
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到深色模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换到深色模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到浅色模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换到浅色模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="BlaBlaCut" class="md-nav__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    BlaBlaCut
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/Recent/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Recent
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/awesome-data-prefetchers/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Awesome Data Prefetchers
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/micro-2025/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    MICRO 2025
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/dyn-lang-acc/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Dynamic Language Acceleration
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#0" class="md-nav__link">
    <span class="md-ellipsis">
      
        0. 整体创新点通俗解读
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1-htm-eli5" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. 基于HTM的并发复制垃圾回收算法 (ELI5)
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-collector-mutator-eli5" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. Collector-Mutator协调协议 (ELI5)
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-optimistic-copying-eli5" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. 乐观复制优化 (Optimistic Copying) (ELI5)
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-cache-warmup-eli5" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. 缓存预热优化 (Cache Warmup) (ELI5)
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-htm-eli5" class="md-nav__link">
    <span class="md-ellipsis">
      
        5. HTM容量特性分析 (ELI5)
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="concurrent-copying-garbage-collection-with-hardware-transactional-memory">Concurrent Copying Garbage Collection with Hardware Transactional Memory 通俗讲解<a class="headerlink" href="#concurrent-copying-garbage-collection-with-hardware-transactional-memory" title="Permanent link">&para;</a></h1>
<h3 id="0">0. 整体创新点通俗解读<a class="headerlink" href="#0" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击 (The "Why")</strong></p>
<ul>
<li>传统的 <strong>concurrent copying garbage collection (并发复制式垃圾回收)</strong> 虽然能有效减少应用暂停时间（latency）并解决内存碎片问题，但它需要确保在回收器（collector）移动对象时，应用程序（mutator）看到的堆内存视图是一致的。</li>
<li>为了保证这种一致性，现有方案主要依赖两种机制：<strong>read barriers (读屏障)</strong> 或 <strong>page protection (页面保护)</strong>。</li>
<li>这两种机制的代价都非常高：<ul>
<li><strong>Read barriers</strong> 会在每次从堆中读取引用时插入额外的检查代码。由于读操作极其频繁，这会给 mutator 带来持续且显著的性能开销（论文提到可能高达10%），即使在没有进行 GC 的时候也无法轻易移除。</li>
<li><strong>Page protection</strong> 则通过触发 page fault 来捕获对“陈旧”内存页的访问，其上下文切换和内核态处理的开销同样巨大。</li>
</ul>
</li>
</ul>
<p><strong>通俗比方 (The Analogy)</strong></p>
<ul>
<li>想象一个图书馆（堆内存）正在进行图书（对象）搬迁。管理员（collector）要把一批书从A区搬到B区，并更新所有指向这些书的索引卡片（指针）。</li>
<li>传统方法就像是给每个读者（mutator）配一个监督员（read barrier），每当读者想看书时，监督员都要先检查这本书是不是已经搬走了，如果是，就带他去新位置。或者，直接把A区的门锁上（page protection），任何想进A区的人都会被保安拦下，然后由保安带他去B区找书。</li>
<li>这篇论文提出的思路是：与其给每个读者配监督员或锁门，不如让读者在进入图书馆前，先戴上一副特殊的“事务性眼镜”（HTM transaction）。在这副眼镜的视野里，图书馆要么完全是搬迁前的样子，要么完全是搬迁后的样子，绝不会出现一半在A区一半在B区的混乱状态。如果管理员恰好在他戴着眼镜时完成了搬迁，他的这次阅读尝试就会“作废”（transaction abort），他摘下眼镜重新看一眼公告牌（检查全局状态），再决定是否要重新戴上眼镜尝试。这样，大部分时间读者都是自由活动的，只有在极少数“撞车”时刻才需要重试。</li>
</ul>
<p><strong>关键一招 (The "How")</strong></p>
<ul>
<li>作者的核心洞察是利用 <strong>Hardware Transactional Memory (HTM)</strong> 的原子性和隔离性来替代昂贵的 read barrier。</li>
<li>具体来说，他们并没有让 mutator 永远运行在事务中，而是设计了一个精巧的协调协议：<ul>
<li><strong>Collector 端</strong>：当 collector 准备开始一个区域的复制工作时，它会先将一个<strong>全局单调计数器</strong>（<code>CollectorCopyingState</code>）设为奇数，然后通过 <strong>yieldpoints</strong> 通知所有 mutator 线程。</li>
<li><strong>Mutator 端</strong>：Mutator 在 yieldpoint 处收到通知后，知道 collector 即将开始工作。此后，直到下一个 yieldpoint 之前，mutator 会将自己的执行包裹在一个 HTM 事务中。</li>
<li><strong>Gap Covering</strong>：这个事务的关键在于，在事务提交前，它会再次检查那个全局计数器。如果发现计数器已经变成偶数（意味着 collector 已经完成了复制并提交了事务），那么当前 mutator 的事务就会<strong>主动中止</strong>（<code>XABORT</code>）。</li>
<li>这个中止操作保证了：任何在 collector 完成复制之后、mutator 更新其栈上引用之前的“间隙期”（problematic gap）内发生的 mutator 执行都会被回滚。随后，mutator 会在下一个 yieldpoint 处安全地更新其栈上的陈旧引用。</li>
</ul>
</li>
<li>因此，作者巧妙地将原本需要在<strong>每一次读操作</strong>上都付出的高昂成本，转化成了只在<strong>GC活跃期间</strong>、并且只在<strong>极少数发生冲突的代码路径</strong>上才需要付出的、一次性的事务启动和可能的重试成本。<img alt="" src="../images/8b375db05156e9ea8aed0dff8505f95304e194664632086d16ecd5828f5cebc3.jpg" /> <em>Table 4.1: Machines used in the evaluation.</em></li>
</ul>
<h3 id="1-htm-eli5">1. 基于HTM的并发复制垃圾回收算法 (ELI5)<a class="headerlink" href="#1-htm-eli5" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击</strong></p>
<ul>
<li>传统的 <strong>并发复制垃圾回收 (Concurrent Copying GC)</strong> 面临一个两难困境：既要让应用程序（<strong>mutator</strong>）和垃圾回收器（<strong>collector</strong>）同时运行以减少停顿，又要保证 <strong>mutator</strong> 在任何时候看到的堆内存都是<strong>一致且正确</strong>的。</li>
<li>为了实现这种一致性，现有方案主要依赖两种机制：<ul>
<li><strong>读屏障 (Read Barriers)</strong>：每次从堆中读取一个对象引用时，都要先检查该对象是否已被移动，并可能触发同步逻辑。这就像给每次内存读操作都加了一道安检门，<strong>开销巨大且无法轻易关闭</strong>。</li>
<li><strong>页保护 (Page Protection)</strong>：通过操作系统将包含旧对象的内存页设为只读或不可访问，一旦 <strong>mutator</strong> 访问就会触发缺页中断，由中断处理程序来修复引用。这种方式涉及昂贵的<strong>内核态/用户态切换</strong>，同样带来很高的性能损耗。</li>
</ul>
</li>
<li>这两种方法的核心问题在于，它们都是<strong>持续性、侵入式</strong>的开销，无论回收器是否正在工作，只要GC系统启动了，这些开销就一直存在。</li>
</ul>
<p><strong>通俗比方</strong></p>
<ul>
<li>想象一个图书馆（堆内存）正在进行图书（对象）搬迁。管理员（<strong>collector</strong>）要把A区的书搬到B区。</li>
<li>传统方法就像是在A区每个书架前都安排一个保安（<strong>读屏障</strong>），每当有读者（<strong>mutator</strong>）想拿书时，保安必须先确认这本书是不是已经搬走了，如果搬走了，还得告诉读者新位置。或者，直接把A区所有书架都锁起来（<strong>页保护</strong>），读者一碰就报警，然后管理员跑过来开锁并告知新位置。</li>
<li>而这篇论文提出的新方法更像是这样：管理员在开始大规模搬迁前，会广播一个通知。在此期间，任何进入图书馆的读者都会被要求戴上一个特殊的“<strong>事务眼镜</strong>”（<strong>HTM</strong>）。这个眼镜有一个神奇的功能：它能记录下读者在馆内所有的行动。如果在读者阅读期间，管理员恰好完成了某批书的搬迁并更新了目录，那么这位读者刚才所看到的一切（基于旧目录的）就会被瞬间“<strong>回滚</strong>”，他会被要求重新进入图书馆，这次就能看到最新的、正确的目录了。这个“眼镜”的成本只在佩戴和摘下时产生，而不是在每一次翻书时都产生。</li>
</ul>
<p><strong>关键一招</strong></p>
<ul>
<li>作者的核心洞察是：<strong>不需要时刻监控 mutator 的每一次读操作，只需要确保在 collector 完成一次关键的“发布”动作（即提交对象移动和指针更新）时，没有任何 mutator 正在基于旧状态执行错误的逻辑。</strong></li>
<li>为了实现这一点，他们设计了一个精巧的协调协议：<ul>
<li><strong>Collector 端</strong>：使用 <strong>HTM 事务</strong>来原子地完成“复制对象 + 更新堆内所有相关指针”这一系列操作。事务提交的那一刻，就是“发布”新状态的时刻。</li>
<li><strong>Mutator 端</strong>：引入一个全局的<strong>单调递增计数器</strong>（<code>CollectorCopyingState</code>）来标记回收阶段。当计数器为奇数时，表示 <strong>collector</strong> 即将或正在尝试进行事务性复制。</li>
<li><strong>Mutator 的执行被 yieldpoint 切分成小段</strong>。在每一段开始前，<strong>mutator</strong> 会检查计数器。如果发现计数器是奇数，它就会<strong>将自己的整段执行包裹在一个 HTM 事务中</strong>。</li>
<li><strong>最关键的逻辑转换在于</strong>：在事务结束提交前，<strong>mutator</strong> 会再次检查全局计数器。如果发现计数器已经变为偶数（意味着 <strong>collector</strong> 的事务已经成功提交），那么 <strong>mutator</strong> 的事务就会<strong>主动中止 (XABORT)</strong>。HTM 的硬件机制会自动回滚这段执行期间的所有副作用，确保错误的状态不会被提交。</li>
</ul>
</li>
<li>这样，通过让 <strong>mutator</strong> 在潜在的危险窗口期<strong>短暂地、批量地</strong>在事务中执行，巧妙地利用了 <strong>HTM</strong> 的<strong>原子性</strong>和<strong>回滚能力</strong>，替代了细粒度、持续性的<strong>读屏障</strong>。开销从“<strong>每次读都付费</strong>”变成了“<strong>每次执行片段开始时尝试开启事务，并在必要时回滚</strong>”，在大多数情况下能显著降低平均开销。</li>
</ul>
<p><img alt="" src="../images/fca77d7a9e12d5dad7efe61d5344235db8aeb939383bcc018089466fd3496ab0.jpg" /> <em>Figure 5.1: Success rate curves on Haswell.</em></p>
<h3 id="2-collector-mutator-eli5">2. Collector-Mutator协调协议 (ELI5)<a class="headerlink" href="#2-collector-mutator-eli5" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击 (The "Why")</strong></p>
<ul>
<li>传统的 <strong>concurrent copying GC</strong> 面临一个两难困境：要么用昂贵的 <strong>read barrier</strong>（每次读对象都要检查），要么用复杂的 <strong>page protection</strong>（触发页错误来修复指针）。这两种方法都会给 <strong>mutator</strong>（应用程序）带来持续且显著的性能开销。</li>
<li>核心难点在于 <strong>“问题间隙” (Problematic Gap)</strong>：当 <strong>collector</strong>（垃圾回收器）在后台把一个对象从 <strong>fromspace</strong> 复制到 <strong>tospace</strong> 并提交事务后，到 <strong>mutator</strong> 线程发现这个变化并更新自己栈上的旧指针之前，存在一个微小但致命的时间窗口。在这个窗口里，<strong>mutator</strong> 可能会使用栈上已经失效的 <strong>fromspace</strong> 指针，导致读取到错误数据或丢失写入。</li>
</ul>
<p><strong>通俗比方 (The Analogy)</strong></p>
<ul>
<li>想象你在和朋友玩一个“同步画画”的游戏。你（<strong>collector</strong>）负责把画布A上的画作原样搬到画布B上。你的朋友（<strong>mutator</strong>）则根据他脑子里记住的坐标（<strong>stack reference</strong>）在画布上作画。</li>
<li>以前的做法是：要么让你朋友每次下笔前都打电话问你“画搬完了吗？”（<strong>read barrier</strong>，很烦人）；要么直接把画布A盖起来，等他想用时再告诉他去画布B（<strong>page protection</strong>，有延迟）。</li>
<li>这篇论文的新思路是：你搬完画后，立刻按下一个<strong>全局喇叭</strong>（<strong>CollectorCopyingState</strong> 计数器）。你朋友每隔一小会儿（在 <strong>yieldpoint</strong>）就会抬头看一眼喇叭有没有响。如果响了，他就知道刚才那几笔可能画错地方了，于是立刻<strong>擦掉重画</strong>（<strong>abort transaction</strong>）。这样，他大部分时间都可以自由作画，只有在你搬画的关键时刻才需要额外检查。</li>
</ul>
<p><strong>关键一招 (The "How")</strong></p>
<ul>
<li>作者没有给 <strong>mutator</strong> 的每一次内存访问都加上检查，而是巧妙地利用了 **Hardware Transactional Memory **(HTM) 和 <strong>yieldpoint</strong> 机制，在 <strong>collector</strong> 和 <strong>mutator</strong> 之间建立了一个轻量级的协调协议。</li>
<li>具体来说，这个协议通过以下几步扭转了局面：<ul>
<li><strong>引入一个全局信号</strong>：使用一个单调递增的 <strong>CollectorCopyingState</strong> 计数器。<strong>collector</strong> 在开始和结束一次复制事务时，都会让计数器加1。因此，<strong>奇数</strong>表示“正在搬家”，<strong>偶数</strong>表示“刚刚搬完”。</li>
<li><strong>Mutator 主动握手</strong>：<strong>mutator</strong> 只在 <strong>yieldpoint</strong>（如循环回边、函数返回等预设的安全点）检查这个计数器。如果发现自上次检查以来，计数器变成过<strong>偶数</strong>，就意味着它可能在“问题间隙”里执行过代码。</li>
<li><strong>用事务包裹执行</strong>：当 <strong>mutator</strong> 发现 <strong>CollectorCopyingState</strong> 是奇数（即 <strong>collector</strong> 正在工作）时，它会将自己的下一段执行逻辑包裹在一个 <strong>HTM transaction</strong> 里。</li>
<li><strong>自动回滚错误</strong>：如果在这段事务执行期间，<strong>collector</strong> 完成了搬家（计数器变为偶数），那么 <strong>mutator</strong> 事务在提交前会检查计数器。一旦发现计数器变了，就<strong>主动 abort</strong>。HTM 的硬件特性会自动回滚这段执行，确保任何基于旧指针的错误操作都被抹去。之后 <strong>mutator</strong> 会在下一个 <strong>yieldpoint</strong> 更新自己的栈指针，并重试。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/8b375db05156e9ea8aed0dff8505f95304e194664632086d16ecd5828f5cebc3.jpg" /> <em>Table 4.1: Machines used in the evaluation.</em></p>
<h3 id="3-optimistic-copying-eli5">3. 乐观复制优化 (Optimistic Copying) (ELI5)<a class="headerlink" href="#3-optimistic-copying-eli5" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击 (The "Why")</strong></p>
<ul>
<li>作者想用 <strong>HTM (Hardware Transactional Memory)</strong> 来做并发垃圾回收，核心想法是在一个事务里完成对象复制和所有指针更新，保证原子性。</li>
<li>但 <strong>HTM 的写容量 (write capacity) 极其有限</strong>（论文第五章实验证明，通常只有 <strong>20-25KB</strong> 左右），而直接在事务里复制对象会产生海量的写操作（把源对象每个字节都写到新位置）。</li>
<li>这导致一个很“难受”的局面：即使要复制的对象总大小没超过读容量，也因为<strong>写操作太多</strong>而频繁触发事务 <strong>abort</strong>，让整个方案变得不切实际。</li>
</ul>
<p><strong>通俗比方 (The Analogy)</strong></p>
<ul>
<li>想象你要把一个装满文件的保险柜（fromspace 对象）搬到另一个新保险柜（tospace 对象）。传统做法是，在一个上锁的房间里（事务内）完成所有搬运工作。但这个房间太小，你搬几份文件就满了（写缓冲区溢出），只能不断放弃重来。</li>
<li>“乐观复制”就像这样：你先在房间外找一个临时桌子（<strong>shadow region</strong>），快速把旧保险柜里的文件原样摆一份在桌子上。然后，你只带着一张清单（比较逻辑）进那个小房间。在房间里，你只需要核对旧保险柜和桌子上的文件是否完全一致。如果一致，说明没人动过旧柜子，你的“搬运计划”是有效的，就可以安全地宣布新保险柜正式启用；如果不一致，说明有人在你准备期间修改了旧柜子，这次搬运作废，下次再来。</li>
<li>关键在于，<strong>真正费力气的搬运工作（写操作）被挪到了房间外</strong>，而房间里只做轻松的核对工作（读操作），从而完美适应了小房间（HTM）的空间限制。</li>
</ul>
<p><strong>关键一招 (The "How")</strong></p>
<ul>
<li>作者并没有在 HTM 事务内部执行昂贵的对象复制（<code>copy(object)</code>），而是巧妙地将流程拆解为事务内外两部分：<ul>
<li><strong>事务外 (Optimistic Phase)</strong>:<ul>
<li>将待移动的 fromspace 对象 <strong>O</strong> 完整地复制一份到一个临时的 <strong>shadow region</strong>，得到快照 <strong>Os</strong>。</li>
<li>然后，用这个快照 <strong>Os</strong> 作为模板，在 tospace 中创建最终的目标对象 <strong>O'</strong>。</li>
</ul>
</li>
<li><strong>事务内 (Validation Phase)</strong>:<ul>
<li>不再进行任何实质性的数据复制（写操作）。</li>
<li>只做一件事：<strong>逐字节比较</strong>原始对象 <strong>O</strong> 和它的快照 <strong>Os</strong>。</li>
<li>如果 <strong>O == Os</strong>，证明在准备阶段没有发生并发修改，<strong>O'</strong> 是有效的，事务提交，发布 <strong>O'</strong>。</li>
<li>如果 <strong>O != Os</strong>，证明有并发写入导致数据不一致，事务主动 <strong>abort</strong>，丢弃 <strong>O'</strong>，下次重试。</li>
</ul>
</li>
</ul>
</li>
<li>这一招的精髓在于，它把事务内的 <strong>大量写操作</strong>（复制 O 到 O'）成功转换成了 <strong>大量读操作</strong>（比较 O 和 Os）。由于 HTM 的 <strong>读容量远大于写容量</strong>（论文显示读容量可达数 MB），这极大地提高了事务的成功率，使整个并发 GC 方案变得可行。</li>
</ul>
<h3 id="4-cache-warmup-eli5">4. 缓存预热优化 (Cache Warmup) (ELI5)<a class="headerlink" href="#4-cache-warmup-eli5" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击</strong></p>
<ul>
<li>传统的 <strong>HTM (Hardware Transactional Memory)</strong> 事务在执行时，其成功与否严重依赖于底层 <strong>CPU缓存</strong>的状态。</li>
<li>问题在于 <strong>伪LRU (pseudo-LRU)</strong> 替换策略：即使一个事务访问的数据总量小于缓存容量，但如果这些数据在事务开始前不在缓存里，它们在被加载进来的同时，可能会因为替换算法的“不完美”而挤掉其他同样属于该事务的、刚刚被加载的数据。</li>
<li>这导致了一个非常难受的局面：一个本应能成功的 <strong>大读取事务 (large read-only transaction)</strong>，仅仅因为初始缓存是“冷”的（充满了无关数据），就在执行过程中因缓存行被错误地驱逐而触发了 <strong>非必要的容量中止 (spurious capacity abort)</strong>。这使得 HTM 的有效容量变得不可预测且远低于理论值。</li>
</ul>
<p><strong>通俗比方</strong></p>
<ul>
<li>想象你要在一个拥挤的图书馆（CPU缓存）里完成一项研究（HTM事务）。你的研究需要查阅100本书（数据），而图书馆恰好有100个空位。</li>
<li>但是，图书管理员（<strong>伪LRU替换策略</strong>）用的是一套不完美的记忆法。当你开始找第一本书时，它被放在了架子上。但当你去找第二本时，管理员可能错误地认为第一本“不重要”了，把它拿走给第二本腾位置。</li>
<li>结果就是，尽管图书馆物理空间足够，你却永远无法同时拥有所有100本书来完成研究，因为你总是在找新书的时候弄丢旧书。</li>
<li><strong>缓存预热</strong> 就像是在正式研究开始前，你先派一个助手快速地把这100本书都借一遍再还回去。这样，当管理员看到你正式开始研究时，这100本书已经在他的“近期借阅”名单顶部了，他就会尽力把它们都留在架子上供你使用。</li>
</ul>
<p><strong>关键一招</strong></p>
<ul>
<li>作者没有去修改复杂的 CPU 缓存硬件或替换策略（这显然不可能），而是巧妙地在软件层面增加了一个预备步骤。</li>
<li>具体来说，在真正启动那个关键的 <strong>收集器事务 (collector transaction)</strong> 之前，系统会<strong>预先执行一遍该事务的主体代码逻辑</strong>（特别是其中大量的内存比较操作），但会<strong>主动丢弃这次执行的所有结果</strong>。</li>
<li>这个“空跑”过程的唯一目的，就是让 CPU 的缓存子系统将事务即将频繁访问的所有内存地址（缓存行）都提前加载到高速缓存中，并通过多次访问让它们在 <strong>伪LRU</strong> 队列中获得很高的优先级。</li>
<li>通过这个简单的“<strong>预演</strong>”操作，当真正的事务开始时，它所依赖的数据已经“热”在缓存里了，从而极大地降低了因缓存抖动而导致的非必要中止，有效<strong>放大了HTM的实际可用读取容量</strong>。</li>
</ul>
<p><img alt="" src="../images/3205642b8258cabc26576371092cc40f6fe045f106fec3d6a9e56798a14eb2d6.jpg" /> <em>Figure 5.10: Success rate curves on Coffee Lake when warming up caches.</em></p>
<h3 id="5-htm-eli5">5. HTM容量特性分析 (ELI5)<a class="headerlink" href="#5-htm-eli5" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击</strong></p>
<ul>
<li>之前研究HTM（Hardware Transactional Memory）容量时，大家报告的数字五花八门，甚至互相矛盾。有的说读事务能到7.5MB，有的却说连L1缓存大小都撑不住。这让想用HTM做系统设计的人非常难受：我到底能指望它处理多大的原子操作？这种不确定性直接阻碍了HTM在像垃圾回收这类对事务大小有要求的场景中的应用。</li>
<li>根本原因在于，大家都忽略了<strong>缓存状态</strong>这个“隐藏变量”。HTM的底层实现严重依赖CPU缓存来追踪事务内的读写集，而缓存的行为（比如替换策略）会极大地影响一个事务能否成功提交。之前的实验方法不统一，有的重用内存，有的不用，导致结果无法横向比较，造成了文献中的混乱局面。</li>
</ul>
<p><strong>通俗比方</strong></p>
<ul>
<li>想象HTM事务就像一个需要在一张<strong>有限大小的白板</strong>上完成所有草稿计算的数学家。这张白板就是CPU缓存。</li>
<li><strong>清空缓存</strong>（Invalidation）就像是把白板彻底擦干净，给新计算腾出最大、最连续的空间。</li>
<li><strong>预热缓存</strong>（Warmup）则像是提前把需要用到的公式和数据抄到白板的固定位置上，确保计算时伸手就能拿到，不会因为临时去找而把其他重要内容挤掉。</li>
<li><strong>重用内存区域</strong>就像是反复在白板的同一块区域演算，虽然没特意准备，但因为内容相似，旧的草稿和新的计算能很好地共存，不容易超出白板范围。</li>
<li>之前的实验者，有的用的是干净白板，有的用的是乱糟糟的旧白板，自然得出的“最大计算量”就完全不同。这篇论文的贡献就是揭示了“白板的初始状态”才是关键，并给出了让白板发挥最大效用的方法。</li>
</ul>
<p><strong>关键一招</strong></p>
<ul>
<li>作者没有停留在复现矛盾数据上，而是设计了一套精巧的对照实验，系统地操控<strong>缓存的初始状态</strong>这个变量。</li>
<li>他通过三种方式验证了自己的猜想：<ul>
<li><strong>重用内存</strong>：让不同大小的事务测试都跑在同一块内存区域上。</li>
<li><strong>清空缓存</strong>：在每次事务开始前，用<code>wbinvd</code>指令强制清空所有级别的缓存。</li>
<li><strong>预热缓存</strong>：在事务开始前，先非事务性地多次访问即将在事务中读取的数据。</li>
</ul>
</li>
<li>实验结果惊人地一致：这三种看似不同的操作，都能<strong>显著提升大读事务的成功率</strong>。这背后的核心逻辑是，它们都绕过了CPU缓存（特别是<strong>pseudo-LRU</strong>替换策略）的缺陷。在正常情况下，即使事务工作集小于缓存总容量，伪LRU算法也可能错误地驱逐掉事务刚访问过的缓存行，导致不必要的容量溢出（Capacity Abort）。而这三种方法要么提供了完全干净的空间，要么让所需数据牢牢占据缓存，从而避免了这种“假溢出”。</li>
<li>这个发现完美解释了文献中的矛盾：那些报告高容量的实验，很可能无意中采用了类似“重用内存”或“预热”的模式；而报告低容量的，则可能是在冷缓存或不利的内存访问模式下进行的。<img alt="" src="../images/5e6c6cb543e2599d4e8c5f0989ed846ab5137bcd7a6d78dd13489e494445c681.jpg" /> <em>Figure 5.9: Success rate curves on Coffee Lake when invalidating caches.</em>
    <img alt="" src="../images/3205642b8258cabc26576371092cc40f6fe045f106fec3d6a9e56798a14eb2d6.jpg" /> <em>Figure 5.10: Success rate curves on Coffee Lake when warming up caches.</em></li>
</ul>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.sections", "navigation.top", "navigation.indexes", "search.suggest", "search.highlight", "content.code.copy"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../../../javascripts/switcher.js"></script>
      
        <script src="../../../javascripts/smart_back.js"></script>
      
    
  </body>
</html>