
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://example.com/notes_repo/concurrent-copying-garbage-collection-with-hardware-transactional-memory/paper_notes/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Concurrent Copying Garbage Collection with Hardware Transactional Memory 论文解析 - BlaBlaCut</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#concurrent-copying-garbage-collection-with-hardware-transactional-memory" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="BlaBlaCut" class="md-header__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            BlaBlaCut
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Concurrent Copying Garbage Collection with Hardware Transactional Memory 论文解析
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到深色模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换到深色模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到浅色模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换到浅色模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="BlaBlaCut" class="md-nav__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    BlaBlaCut
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/Recent/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Recent
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/awesome-data-prefetchers/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Awesome Data Prefetchers
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/micro-2025/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    MICRO 2025
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/dyn-lang-acc/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Dynamic Language Acceleration
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#0" class="md-nav__link">
    <span class="md-ellipsis">
      
        0. 论文基本信息
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. 摘要
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. 背景知识与核心贡献
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. 核心技术和实现细节
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3. 核心技术和实现细节">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#0_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        0. 技术架构概览
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-htm" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. 基于HTM的并发复制垃圾回收算法
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-collector-mutator" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. Collector-Mutator协调协议
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-optimistic-copying" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. 乐观复制优化 (Optimistic Copying)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-cache-warmup" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. 缓存预热优化 (Cache Warmup)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5-htm" class="md-nav__link">
    <span class="md-ellipsis">
      
        5. HTM容量特性分析
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. 实验方法与实验结果
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="concurrent-copying-garbage-collection-with-hardware-transactional-memory">Concurrent Copying Garbage Collection with Hardware Transactional Memory 论文解析<a class="headerlink" href="#concurrent-copying-garbage-collection-with-hardware-transactional-memory" title="Permanent link">&para;</a></h1>
<h2 id="0">0. 论文基本信息<a class="headerlink" href="#0" title="Permanent link">&para;</a></h2>
<p><strong>作者 (Authors)</strong>: Zixian Cai</p>
<p><strong>发表期刊/会议 (Journal/Conference)</strong>: unknown</p>
<p><strong>发表年份 (Publication Year)</strong>: 2020</p>
<p><strong>研究机构 (Affiliations)</strong>: The Australian National University</p>
<hr />
<h2 id="1">1. 摘要<a class="headerlink" href="#1" title="Permanent link">&para;</a></h2>
<p><strong>目的</strong>
- 探索利用 <strong>Hardware Transactional Memory (HTM)</strong> 来实现 <strong>concurrent copying garbage collection (GC)</strong>，旨在解决现有方案（如 <strong>read barriers</strong> 或 <strong>page protection</strong>）带来的高 <strong>mutator overhead</strong> 问题，从而为延迟敏感型应用提供更低暂停时间的垃圾回收方案。</p>
<p><strong>方法</strong>
- <strong>HTM 容量研究</strong>：
  - 系统性地复现并分析了文献中关于 <strong>Intel TSX</strong> 容量的矛盾报告。
  - 设计并执行了一系列实验，探究不同因素对 HTM 有效容量的影响，包括：
    - <strong>内存区域复用</strong> vs. 使用独立内存区域。
    - <strong>缓存状态</strong>的影响，具体测试了 <strong>缓存无效化 (cache invalidation)</strong> 和 <strong>缓存预热 (cache warmup)</strong> 两种策略。
  - 采用 <strong>success rate curves</strong> 作为评估指标，并在多种 Intel 微架构（Haswell, Broadwell, Skylake, Coffee Lake）上进行测试。
- <strong>HTM-GC 算法设计与实现</strong>：
  - 提出了一种新颖的并发复制 GC 算法，其核心思想是让 <strong>mutator</strong> 在关键时期短暂地 <strong>transactionally execute</strong>，以获得堆的一致性视图。
  - 该算法仅使用一个廉价的 <strong>write barrier</strong> 来维护 <strong>remembered set</strong>，避免了昂贵的 read barrier。
  - 引入了一个 <strong>monotonic counter</strong> 机制和 <strong>yieldpoints</strong> 来协调 collector 与 mutator，解决了 collector 事务提交后、mutator 栈上引用更新前的 <strong>problematic gap</strong>。
  - 基于对 HTM 容量的理解，提出了两项优化：
    - <strong>Optimistic Copying</strong>：将对象复制操作移出事务，仅在事务内进行验证，以减少事务内的写操作数量。
    - <strong>Cache Warmup</strong>：在执行 collector 事务前预热缓存，以提高大事务的成功率。
  - 在 <strong>MMTk</strong> 框架中实现了该算法，并通过一系列精心设计的 <strong>linked-list</strong> 测试程序验证其核心机制。</p>
<p><strong>结果</strong>
- <strong>HTM 容量研究发现</strong>：
  - 文献中报告的 HTM 容量差异主要源于不同的实验方法。<strong>内存访问模式</strong>和<strong>缓存状态</strong>对有效容量有显著影响。
  - <strong>复用内存区域</strong>、<strong>无效化缓存</strong>和<strong>预热缓存</strong>均能显著提升 <strong>read-only transaction</strong> 的容量。
  - 实验结果表明，<strong>write-set</strong> 容量稳定在 <strong>20-25KB</strong> 左右（接近 L1 cache 大小），而 <strong>read-set</strong> 容量则受缓存状态影响巨大。
  - 关键图表如下：
    <img alt="" src="../images/fca77d7a9e12d5dad7efe61d5344235db8aeb939383bcc018089466fd3496ab0.jpg" /> <em>Figure 5.1: Success rate curves on Haswell.</em>
    <img alt="" src="../images/5e6c6cb543e2599d4e8c5f0989ed846ab5137bcd7a6d78dd13489e494445c681.jpg" /> <em>Figure 5.9: Success rate curves on Coffee Lake when invalidating caches.</em>
    <img alt="" src="../images/3205642b8258cabc26576371092cc40f6fe045f106fec3d6a9e56798a14eb2d6.jpg" /> <em>Figure 5.10: Success rate curves on Coffee Lake when warming up caches.</em>
- <strong>HTM-GC 算法验证</strong>：
  - 实现的测试程序成功验证了算法的核心功能，包括：
    - 正确更新 <strong>stack roots</strong> 上的引用。
    - 在并发写入场景下，通过事务保证 <strong>atomicity</strong>，防止 <strong>lost updates</strong>。
    - 正确追踪和更新 <strong>transitively reachable</strong> 对象的堆内引用。
  - 结果证明，该算法在概念上是 <strong>viable</strong> 的，能够利用 HTM 实现低开销的并发复制。</p>
<p><strong>结论</strong>
- 利用 <strong>HTM</strong> 实现低 mutator 开销的 <strong>concurrent copying GC</strong> 是可行的。
- 该工作不仅提出了一种新颖的 GC 算法，还通过深入的实验分析，<strong>澄清了关于 HTM 容量的文献矛盾</strong>，并揭示了 <strong>缓存状态</strong> 对 HTM 性能的关键影响。
- 所提出的 <strong>optimistic copying</strong> 和 <strong>cache warmup</strong> 优化策略，为未来设计更高效的 HTM 应用提供了重要指导。
- 该研究为在支持 HTM 的硬件上构建高性能、低延迟的垃圾回收器奠定了基础。</p>
<hr />
<h2 id="2">2. 背景知识与核心贡献<a class="headerlink" href="#2" title="Permanent link">&para;</a></h2>
<p><strong>研究背景</strong>
- 现代许多<strong>latency-critical</strong>（延迟敏感）应用（如视频、交易系统）越来越多地采用<strong>managed languages</strong>（如 Java, C#）开发，以提升生产力和可靠性。
- <strong>Garbage Collection </strong>(GC) 是托管语言的核心特性，但其执行过程会引入<strong>pauses</strong>（停顿），严重影响用户体验和系统性能。
- <strong>Concurrent copying GC</strong> 是一种理想的解决方案，它既能通过并发执行减少停顿，又能通过对象复制（copying）改善内存<strong>locality</strong>（局部性）并减少<strong>heap fragmentation</strong>（堆碎片）。
- 然而，实现并发复制 GC 需要复杂的同步机制来保证 mutator（应用程序）在 collector（回收器）移动对象时能获得<strong>consistent view</strong>（一致的堆视图）。现有方案主要依赖<strong>read barriers</strong>（读屏障）或<strong>page protections</strong>（页保护），但这些机制会给 mutator 带来<strong>high overhead</strong>（高开销）。</p>
<p><strong>研究动机</strong>
- <strong>Hardware Transactional Memory </strong>(HTM)，特别是 Intel 的 TSX，提供了一种硬件级的乐观并发控制机制，能够在事务提交时保证一系列内存操作的原子性和隔离性。
- 作者提出核心假设：利用 HTM 可以让 mutator 在关键时期<strong>transactionally</strong>（事务性地）执行，从而自然地获得堆的一致性视图，同时避免传统 read barrier 或 page protection 带来的持续性高开销。
- 在探索该假设的过程中，作者发现 HTM 的实际效能高度依赖于其<strong>transaction capacity</strong>（事务容量），而文献中关于 Intel TSX 容量的报告存在<strong>apparent contradiction</strong>（明显矛盾），这阻碍了 HTM-GC 算法的有效设计。</p>
<p><strong>核心贡献</strong>
- <strong>对 HTM 容量的深入分析与澄清</strong>：
  - 系统性地复现并对比了文献中关于 Intel TSX 容量的矛盾结果。
  - 通过精心设计的实验，揭示了<strong>cache status</strong>（缓存状态）是影响 HTM 有效容量的关键因素。实验表明，无论是<strong>invalidating caches</strong>（清空缓存）还是<strong>warming up caches</strong>（预热缓存），都能显著提升大型只读事务的成功率，这解释了先前研究结果的差异。
  - <img alt="" src="../images/5e6c6cb543e2599d4e8c5f0989ed846ab5137bcd7a6d78dd13489e494445c681.jpg" /> <em>Figure 5.9: Success rate curves on Coffee Lake when invalidating caches.</em>
  - <img alt="" src="../images/3205642b8258cabc26576371092cc40f6fe045f106fec3d6a9e56798a14eb2d6.jpg" /> <em>Figure 5.10: Success rate curves on Coffee Lake when warming up caches.</em>
- <strong>提出并实现了一种新颖的 HTM-based Concurrent Copying GC 算法</strong>：
  - 该算法仅使用一个廉价的<strong>write barrier</strong>（写屏障）来维护<strong>remembered set</strong>（记忆集），用于追踪跨区域引用。
  - 为了解决 collector 事务提交后、mutator 栈上引用更新前的<strong>problematic gap</strong>（问题间隙），创新性地让 mutator 在此期间<strong>execute transactionally</strong>（事务性地执行）。
  - 如果 mutator 的事务在 gap 期间执行，它会因检测到全局状态变化或与 collector 事务冲突而<strong>abort</strong>（中止），从而回滚错误的执行，确保了正确性。
  - 这种方法将高昂的、持续性的 read barrier 开销，转变为仅在 GC 活动期间才可能发生的、一次性的事务启动和潜在中止开销。
- <strong>基于 HTM 容量洞察的算法优化</strong>：
  - <strong>Optimistic Copying</strong>（乐观复制）：将对象复制的实际写操作移出 collector 事务，在事务内仅进行验证性读取，从而大幅减少事务内的<strong>write-set</strong>大小，规避了 HTM 写容量远小于读容量的限制。
  - <strong>Cache Warmup</strong>（缓存预热）：在启动 collector 事务前，预先执行一遍事务逻辑（丢弃结果），以将所需数据预热到缓存中，减少因<strong>pseudo-LRU</strong>替换策略导致的非必要容量中止。</p>
<hr />
<h2 id="3">3. 核心技术和实现细节<a class="headerlink" href="#3" title="Permanent link">&para;</a></h2>
<h3 id="0_1">0. 技术架构概览<a class="headerlink" href="#0_1" title="Permanent link">&para;</a></h3>
<p><strong>整体技术架构</strong></p>
<p>本文提出了一种利用 <strong>Hardware Transactional Memory (HTM)</strong> 来实现低开销 <strong>concurrent copying garbage collection (GC)</strong> 的新型算法。其核心思想是，让 <strong>mutator</strong>（应用程序线程）在垃圾回收器（collector）进行对象移动的关键窗口期内，以事务性方式执行，从而保证堆视图的一致性，同时避免了传统方案中高开销的 <strong>read barrier</strong> 或 <strong>page protection</strong>。</p>
<ul>
<li><strong>基础组件</strong>:</li>
<li><strong>Region-based Heap Organization</strong>: 将堆划分为多个 <strong>region</strong>，使得 GC 可以针对单个 region 进行独立的并发回收，而非全局停顿。</li>
<li><strong>Write Barrier</strong>: 使用一个轻量级的 <strong>write barrier</strong> 来动态维护每个 region 的 <strong>remembered set</strong>。该 barrier 仅记录从 region 外部指向内部的引用（inter-region references），为后续的并发复制提供必要的根集信息。</li>
<li>
<p><strong>Yieldpoints</strong>: 利用运行时系统中已有的 <strong>yieldpoint</strong> 机制，作为 mutator 与 collector 之间进行协调和状态同步的安全点。</p>
</li>
<li>
<p><strong>核心 HTM GC 算法流程</strong>:</p>
</li>
<li><strong>Collector Side</strong>:<ul>
<li>Collector 在开始复制前，将一个全局的 <strong>CollectorCopyingState</strong> 计数器设为奇数，并通过 <strong>handshake</strong> 机制通知所有 mutator 线程。</li>
<li>Collector 在一个 <strong>HTM transaction</strong> 内执行 <code>copyRegion</code> 操作：将 fromspace 中的存活对象复制到 tospace，并原子地更新 remembered set 中的所有引用。</li>
<li>如果事务成功提交，则将 <code>CollectorCopyingState</code> 计数器加一变为偶数，宣告本次复制完成；如果失败，则同样更新计数器但不改变堆状态。</li>
</ul>
</li>
<li>
<p><strong>Mutator Side</strong>:</p>
<ul>
<li>Mutator 在 yieldpoint 处通过 handshake 检查 <code>CollectorCopyingState</code>。</li>
<li>如果发现计数器为奇数（表示 collector 正在尝试复制），mutator 会将其下一段应用代码（直到下一个 yieldpoint）包裹在一个 <strong>HTM transaction</strong> 中执行。</li>
<li>在事务提交前，mutator 会再次检查 <code>CollectorCopyingState</code>。如果在此期间 collector 已完成复制（计数器变为偶数），则 mutator 的事务会主动 <strong>abort</strong>，从而回滚任何可能基于过时堆状态（stale reference）的错误执行。</li>
<li>事务成功提交后，mutator 继续正常执行。</li>
</ul>
</li>
<li>
<p><strong>关键优化</strong>:</p>
</li>
<li><strong>Optimistic Copying</strong>: 为了减少 collector 事务中的写操作（因为 HTM 的 <strong>write-set capacity</strong> 远小于 read-set capacity），collector 首先在事务外将对象复制到一个 <strong>shadow region</strong> 作为快照。然后在事务内，仅比较原对象与快照是否一致。若一致，则说明复制有效；否则事务 abort。这将大量的事务性写操作转换为事务性读操作。</li>
<li><strong>Cache Warmup</strong>: 基于对 HTM 容量的深入分析（见下文），发现 <strong>cache 状态</strong> 对事务成功率有显著影响。因此，在启动 collector 事务前，会预先执行一次“预热”操作（执行事务逻辑但丢弃结果），将相关数据加载到 cache 中，以减少因 <strong>pseudo-LRU</strong> 替换策略导致的非必要事务 abort。</li>
</ul>
<p><strong>HTM 容量分析与洞察</strong></p>
<p>本文的第一部分对 <strong>Intel TSX</strong> 的 HTM 容量进行了详尽的实验分析，为上述 GC 算法的设计和优化提供了理论基础。</p>
<ul>
<li><strong>核心发现</strong>:</li>
<li>HTM 的 <strong>read-set capacity</strong> 和 <strong>write-set capacity</strong> 并非固定值，而是受到多种因素的显著影响。</li>
<li><strong>Write-set capacity</strong> 相对稳定，主要受限于 <strong>L1 data cache</strong> 的大小（约 20-25KB）。</li>
<li>
<p><strong>Read-set capacity</strong> 变化极大，其有效容量高度依赖于 <strong>cache 的初始状态</strong> 和 <strong>内存访问模式</strong>。</p>
</li>
<li>
<p><strong>影响容量的关键因素</strong>:</p>
</li>
<li><strong>Memory Reuse</strong>: 重用同一块内存区域进行测试，相比使用全新内存，能显著提升 read-set 容量。这是因为之前的访问已经将数据预热到 cache 中。</li>
<li><strong>Cache State</strong>: 实验表明，无论是 <strong>invalidating the cache</strong>（清空缓存）还是 <strong>warming up the cache</strong>（预热缓存），都能比 baseline（冷缓存）获得更大的 read-set 容量。这揭示了 <strong>pseudo-LRU</strong> 替换策略的局限性：在缓存未满或已预热的情况下，事务所需的数据更不容易被错误地驱逐。</li>
</ul>
<p><img alt="" src="../images/fca77d7a9e12d5dad7efe61d5344235db8aeb939383bcc018089466fd3496ab0.jpg" /> <em>Figure 5.1: Success rate curves on Haswell.</em>
<img alt="" src="../images/573ff1d98148715e9ecdc109fc6fd39d4c0e260749622f993a571e0e8399bb0b.jpg" /> <em>Figure 5.2: Success rate curves on Broadwell.</em>
<img alt="" src="../images/3e7ac435f47b2ee0991a4572a95522ad9c5ba4bbd81f69f34cc88f178b219055.jpg" /> <em>Figure 5.3: Success rate curves on Skylake.</em>
<img alt="" src="../images/06532af4750ccb7976030552dd6e5c5ebfcd550dc236c7c0eb5fc12de7760f0d.jpg" /> <em>Figure 5.4: Success rate curves on Coffee Lake.</em></p>
<ul>
<li><strong>解决文献矛盾</strong>: 通过上述实验，本文解释了为何先前研究中报告的 HTM 容量存在巨大差异（从 22KB 到 7.5MB）。这些差异主要源于不同的 <strong>实验方法论</strong>（如是否重用内存、是否控制 cache 状态）。</li>
</ul>
<p><strong>实现与验证</strong></p>
<ul>
<li><strong>实现平台</strong>: 算法在 <strong>MMTk</strong>（Memory Management Toolkit）框架中实现。</li>
<li><strong>验证方法</strong>: 由于工程复杂度高，作者设计了一系列精巧的 <strong>handcrafted test programs</strong>（基于链表结构）来验证算法的核心机制：</li>
<li>验证栈上引用（stack roots）能否被正确更新。</li>
<li>验证在并发复制期间，mutator 对对象的写入不会丢失（lost update）。</li>
<li>验证非直接可达的对象也能被正确追踪和复制。</li>
<li><strong>结论</strong>: 测试结果证明了该 HTM-based concurrent copying GC 算法的 <strong>viability</strong>（可行性）。</li>
</ul>
<h3 id="1-htm">1. 基于HTM的并发复制垃圾回收算法<a class="headerlink" href="#1-htm" title="Permanent link">&para;</a></h3>
<p><strong>核心观点</strong></p>
<ul>
<li>该论文提出了一种新颖的 <strong>并发复制垃圾回收 (Concurrent Copying GC)</strong> 算法，其核心思想是利用 <strong>硬件事务内存 (HTM)</strong> 来协调 <strong>mutator</strong>（应用程序线程）和 <strong>collector</strong>（垃圾回收器线程）之间的操作，从而在保证堆一致性的前提下，显著降低传统方案（如读屏障或页保护）带来的 <strong>mutator开销</strong>。</li>
<li>该算法的关键创新在于，它不要求 mutator 在整个 GC 周期都处于某种特殊状态，而是在 collector 完成对象移动后的一个<strong>极短且关键的时间窗口</strong>内，让 mutator 的执行被包裹在一个 HTM 事务中。这个事务充当了一个“安全网”，确保任何在此窗口期内发生的、基于旧引用（fromspace reference）的错误操作都会被自动回滚。</li>
</ul>
<p><strong>算法设计与流程</strong></p>
<ul>
<li>
<p><strong>基础设置</strong>：</p>
<ul>
<li>算法基于一个简单的 <strong>stop-the-world 复制式GC</strong>（如 semispace），但将其应用于堆的一个<strong>连续子区域 (region)</strong>，而非整个堆，以适应 HTM 的容量限制。</li>
<li>引入一个轻量级的 <strong>写屏障 (write barrier)</strong>。当 mutator 创建一个从 region 外部指向内部的引用时，该屏障会将这个引用的位置记录到该 region 的 <strong>remembered set</strong> 中。这是唯一需要的屏障，开销远低于读屏障。</li>
</ul>
</li>
<li>
<p><strong>解决丢失更新问题 (Avoiding Lost Updates)</strong>：</p>
<ul>
<li>Collector 在一个 HTM 事务中执行 <code>copyRegion</code> 操作。</li>
<li>该事务包含两个原子步骤：<ol>
<li>将 fromspace 中所有存活对象复制到 tospace，并在原对象头中设置 <strong>forwarding pointer</strong>。</li>
<li>遍历 remembered set，将所有指向 fromspace 对象的引用更新为指向 tospace 的新对象。</li>
</ol>
</li>
<li>由于 HTM 的原子性，这两个步骤要么全部成功，要么全部失败，从而避免了 mutator 在复制过程中向 fromspace 对象写入数据而导致的 <strong>丢失更新 (lost update)</strong> 问题。</li>
</ul>
</li>
<li>
<p><strong>处理栈上引用的“问题间隙” (The Problematic Gap)</strong>：</p>
<ul>
<li>上述 collector 事务只能更新堆内的引用，无法处理 <strong>mutator 栈上的引用</strong>，因为扫描栈需要暂停 mutator，这违背了并发GC的初衷。</li>
<li>这就产生了一个 <strong>“问题间隙”</strong>：从 collector 事务提交（发布新对象）到 mutator 下次有机会修复其栈上引用之间的时间窗口。在此间隙内，mutator 可能会使用栈上的旧引用，导致读取过时数据或写入丢失。</li>
</ul>
</li>
<li>
<p><strong>覆盖“问题间隙”的机制 (Covering the Gap)</strong>：</p>
<ul>
<li><strong>全局状态信号</strong>：引入一个全局单调递增的计数器 <strong><code>CollectorCopyingState</code></strong>。collector 在开始事务前将其设为奇数，在事务成功提交或失败后将其设为偶数。<strong>奇偶变化</strong>（特别是变为偶数）即向 mutator 发出信号：一个潜在的“问题间隙”已经出现。</li>
<li><strong>握手协议 (Handshaking)</strong>：<ul>
<li>Collector 在启动事务前，通过 <strong>yieldpoint</strong> 机制请求所有 mutator 线程进行一次同步。</li>
<li>Mutator 在 yieldpoint 中执行 <code>mutatorHandshake</code>，检查 <code>CollectorCopyingState</code>。如果发现自上次检查以来计数器变为过偶数，则立即调用 <code>fixStack()</code> 来修复其栈上的所有 fromspace 引用。</li>
</ul>
</li>
<li><strong>Mutator 事务化执行 (Transactional Execution)</strong>：<ul>
<li>在 <code>mutatorHandshake</code> 之后，如果当前 <code>CollectorCopyingState</code> 是奇数（意味着 collector 即将或正在尝试一个事务），mutator 会将其接下来的执行（直到下一个 yieldpoint）包裹在一个 HTM 事务中。</li>
<li>在事务提交前，mutator 会再次检查 <code>CollectorCopyingState</code>。如果发现计数器已改变（意味着 collector 事务已提交，间隙已发生），则显式中止 (<code>XABORT</code>) 当前事务。</li>
<li><strong>正确性保证</strong>：通过这种方式，任何在“问题间隙”内发生的 mutator 执行都会导致其事务中止并回滚。mutator 随后会在重试中通过 handshake 修复栈引用，从而保证了执行的正确性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>关键优化策略</strong></p>
<ul>
<li>
<p><strong>乐观复制 (Optimistic Copying)</strong>：</p>
<ul>
<li><strong>动机</strong>：HTM 的 <strong>写集 (write-set) 容量</strong>（约20-25KB）远小于读集容量。直接在事务中复制对象会产生大量写操作，极易超出容量限制导致中止。</li>
<li><strong>方法</strong>：将实际的对象复制操作移出事务。在事务外，先在 <strong>shadow region</strong> 中创建一个源对象的快照，然后基于快照创建目标对象。在 HTM 事务中，仅比较源对象和快照是否一致。如果一致，说明复制期间无并发修改，事务提交；否则，事务中止。</li>
<li><strong>效果</strong>：将事务内的大量 <strong>写操作</strong> 转化为 <strong>读操作</strong>，极大地降低了因超出写容量而中止的概率。</li>
</ul>
</li>
<li>
<p><strong>缓存预热 (Cache Warmup)</strong>：</p>
<ul>
<li><strong>动机</strong>：实验（见下文）表明，HTM 的有效容量受 <strong>缓存状态</strong> 影响巨大。即使事务工作集小于 L1 缓存，<strong>伪LRU (pseudo-LRU)</strong> 替换策略也可能错误地驱逐事务所需的缓存行，导致不必要的容量中止。</li>
<li><strong>方法</strong>：在启动 collector 事务前，预先执行一遍事务的核心逻辑（如快照比较），但丢弃结果。这会将相关数据 <strong>预热 (warm up)</strong> 到缓存中。</li>
<li><strong>效果</strong>：提高了事务执行时所需数据在缓存中的命中率，减少了因缓存抖动导致的中止，从而提升了大事务的成功率。</li>
</ul>
</li>
</ul>
<p><strong>HTM容量实验洞察</strong></p>
<ul>
<li>论文首先对 Intel TSX 的 HTM 容量进行了详尽的基准测试，以指导算法设计。实验揭示了文献中关于容量报告相互矛盾的原因。</li>
<li><strong>关键发现</strong>：<ul>
<li><strong>写集容量</strong> 相对稳定，受限于 <strong>L1 数据缓存</strong>（约20-25KB）。</li>
<li><strong>读集容量</strong> 变化极大，受 <strong>内存访问模式</strong> 和 <strong>缓存初始状态</strong> 影响显著。</li>
<li><strong>复用内存区域</strong>、<strong>无效化缓存</strong> 或 <strong>预热缓存</strong> 都能显著提升读事务的成功率和最大容量。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/fca77d7a9e12d5dad7efe61d5344235db8aeb939383bcc018089466fd3496ab0.jpg" /> <em>Figure 5.1: Success rate curves on Haswell.</em>
<img alt="" src="../images/573ff1d98148715e9ecdc109fc6fd39d4c0e260749622f993a571e0e8399bb0b.jpg" /> <em>Figure 5.2: Success rate curves on Broadwell.</em>
<img alt="" src="../images/3e7ac435f47b2ee0991a4572a95522ad9c5ba4bbd81f69f34cc88f178b219055.jpg" /> <em>Figure 5.3: Success rate curves on Skylake.</em>
<img alt="" src="../images/06532af4750ccb7976030552dd6e5c5ebfcd550dc236c7c0eb5fc12de7760f0d.jpg" /> <em>Figure 5.4: Success rate curves on Coffee Lake.</em></p>
<ul>
<li>特别地，在 <strong>Coffee Lake</strong> 平台上，无论是 <strong>无效化缓存</strong> 还是 <strong>预热缓存</strong>，都能使最大读事务容量远超基线，接近文献中报告的较高值（如几MB）。</li>
</ul>
<p><img alt="" src="../images/5e6c6cb543e2599d4e8c5f0989ed846ab5137bcd7a6d78dd13489e494445c681.jpg" /> <em>Figure 5.9: Success rate curves on Coffee Lake when invalidating caches.</em>
<img alt="" src="../images/3205642b8258cabc26576371092cc40f6fe045f106fec3d6a9e56798a14eb2d6.jpg" /> <em>Figure 5.10: Success rate curves on Coffee Lake when warming up caches.</em></p>
<p><strong>输入输出关系及整体作用</strong></p>
<ul>
<li><strong>输入</strong>：<ul>
<li><strong>Mutator</strong>：正常的应用程序代码，带有轻量级的写屏障。</li>
<li><strong>Collector</strong>：需要被回收的堆区域 (fromspace)，及其 remembered set。</li>
</ul>
</li>
<li><strong>输出</strong>：<ul>
<li><strong>Mutator</strong>：在无 GC 干扰时，以接近原生的速度运行；在 GC 关键窗口期，其执行被 HTM 事务保护，确保一致性。</li>
<li><strong>Collector</strong>：成功地将 fromspace 区域中的存活对象原子地移动到 tospace，并更新了所有堆内和栈上的引用。</li>
</ul>
</li>
<li><strong>在整体系统中的作用</strong>：<ul>
<li>该算法提供了一种 <strong>低开销</strong> 的并发复制GC实现路径。它通过将高成本的持续性屏障（如读屏障）替换为低成本的、仅在必要时触发的 HTM 事务，有效降低了 <strong>mutator的性能损耗</strong>。</li>
<li>其设计充分利用了现代 CPU 的 HTM 特性，并通过深入理解 HTM 的底层行为（如缓存交互）来指导优化，使得该方案在支持 HTM 的硬件上具有很高的实用潜力。</li>
</ul>
</li>
</ul>
<h3 id="2-collector-mutator">2. Collector-Mutator协调协议<a class="headerlink" href="#2-collector-mutator" title="Permanent link">&para;</a></h3>
<p><strong>Collector-Mutator协调协议的核心目标</strong>
- 解决<strong>并发复制垃圾回收</strong>（Concurrent Copying GC）中的一个根本性难题：在收集器（collector）完成对象移动（即提交事务）后，到mutator线程感知到这一变化并修正其栈上引用之前的这段时间窗口（称为“<strong>问题间隙</strong>”或“problematic gap”）内，mutator可能使用过时的<strong>fromspace引用</strong>，导致读取陈旧数据或写入丢失。
- 该协议通过一种巧妙的、基于<strong>硬件事务内存</strong>（HTM）的机制，避免了传统方案中高开销的<strong>读屏障</strong>（read barrier），仅在必要时让mutator短暂地在事务中执行，从而以较低的代价保证了堆的一致性。</p>
<p><strong>协议的关键组件与数据结构</strong>
- <strong>全局单调计数器 <code>CollectorCopyingState</code></strong>:
  - 这是一个全局共享的整型变量，用于向所有mutator线程广播收集器的当前状态。
  - 其值的<strong>奇偶性</strong>具有特定语义：
    - <strong>奇数值</strong>：表示收集器<strong>正在尝试</strong>进行一个复制事务。mutator看到此状态时，必须在其下一次执行中进入事务模式。
    - <strong>偶数值</strong>：表示一个（或多个）收集器事务<strong>已经完成</strong>（无论成功或失败）。mutator看到从奇数变为偶数的变化，就知道“问题间隙”可能已经发生，需要采取行动。
- <strong>线程本地快照 <code>t.copyingState</code></strong>:
  - 每个mutator线程都维护一个本地副本，记录它最后一次观察到的<code>CollectorCopyingState</code>的值。
  - 通过比较本地快照和全局计数器，mutator可以判断是否有新的收集器事务在自己上次检查后完成。
- <strong>Yieldpoint</strong>:
  - 这是运行时系统中预设的安全点，如方法入口、循环回边等，允许mutator在此处被安全地中止或执行额外逻辑。
  - 在本协议中，yieldpoint是mutator与收集器进行<strong>握手</strong>（handshake）和执行栈修复（<code>fixStack</code>）的唯一场所。</p>
<p><strong>收集器端的协议流程</strong>
- 收集器在启动一个新的复制事务前，会执行以下步骤：
  1. <strong>递增计数器</strong>：将全局<code>CollectorCopyingState</code>加1，使其变为<strong>奇数</strong>，向世界宣告一个新事务即将开始。
  2. <strong>发起握手</strong>：通过设置一个全局标志，请求所有活跃的mutator线程在下一个<strong>yieldpoint</strong>处执行<code>mutatorHandshake</code>。
  3. <strong>等待确认</strong>：收集器会<strong>自旋等待</strong>，直到所有mutator线程都更新了它们的本地<code>copyingState</code>快照，确认已知晓新的奇数状态。这确保了在事务开始前，所有mutator都已进入“警戒”状态。
  4. <strong>执行事务</strong>：在HTM事务中执行<code>copyRegion</code>操作，原子地移动对象并更新堆中的引用。
  5. <strong>发布结果</strong>：如果事务<strong>成功提交</strong>，再次将<code>CollectorCopyingState</code>加1，使其变为<strong>偶数</strong>，宣告事务完成。如果事务<strong>中途中止</strong>（abort），同样会将计数器加1（变为偶数），但此时堆并未发生实际变化。</p>
<p><strong>Mutator端的协议流程</strong>
- Mutator的执行被组织成一系列由<strong>yieldpoint</strong>分隔的片段。在每个yieldpoint，mutator会执行<code>mutatorHandshake</code>，然后根据状态决定是否在事务中执行下一段代码。
- <strong><code>mutatorHandshake</code> 的逻辑</strong>:
  - 获取当前的全局<code>CollectorCopyingState</code>快照（<code>csSnapshot</code>）。
  - 如果<code>csSnapshot</code>大于本地<code>copyingState</code>，说明有新事件发生。
  - 检查<code>(t.copyingState, csSnapshot]</code>这个区间内是否包含<strong>偶数</strong>。如果包含，则意味着至少有一个收集器事务<strong>已经完成</strong>。
  - 如果检测到已完成的事务，mutator会立即调用<code>fixStack()</code>，遍历自己的调用栈，将任何指向<strong>fromspace</strong>的引用更新为指向<strong>tospace</strong>的新地址。
  - 最后，用<code>csSnapshot</code>更新本地的<code>copyingState</code>。
- <strong>Mutator主执行协议</strong> (<code>mutator</code>):
  - 在<code>mutatorHandshake</code>之后，检查本地<code>copyingState</code>是否为<strong>奇数</strong>。
  - 如果是奇数，mutator会将其接下来的执行（直到下一个yieldpoint）包裹在一个HTM事务中。
  - 在事务提交前，会再次检查全局<code>CollectorCopyingState</code>。如果发现其值已大于本地<code>copyingState</code>（即计数器已被收集器再次递增，变为偶数），则<strong>显式中止</strong>（<code>XABORT</code>）当前mutator事务。
  - 这个显式中止或由HTM硬件检测到的冲突中止，会<strong>回滚</strong>mutator在“问题间隙”内的所有错误执行，并强制其回到yieldpoint重新执行<code>mutatorHandshake</code>，从而安全地修复栈并继续。</p>
<p><strong>输入输出关系及在整体中的作用</strong>
- <strong>输入</strong>:
  - 对于<strong>收集器</strong>：需要回收的<strong>region</strong>（堆区域）及其<strong>remembered set</strong>（记录了所有从外部指向该区域的引用）。
  - 对于<strong>mutator</strong>：普通的应用程序字节码/指令流。
- <strong>输出</strong>:
  - 对于<strong>收集器</strong>：一个被清空的<strong>fromspace region</strong>，以及一个包含所有存活对象的<strong>tospace region</strong>。全局<code>CollectorCopyingState</code>被更新以反映操作结果。
  - 对于<strong>mutator</strong>：正确、一致的程序执行。其栈上的所有引用始终指向有效的对象（<strong>tospace</strong>版本），且不会丢失任何在对象移动期间发生的写入。
- <strong>在整体中的作用</strong>:
  - 该协议是整个HTM GC算法的<strong>核心同步机制</strong>，它优雅地解决了并发复制中最棘手的“<strong>问题间隙</strong>”难题。
  - 它成功地将保证一致性的重担，从对<strong>每一次堆读取</strong>都施加开销的<strong>读屏障</strong>，转移到了仅在<strong>收集器活跃时</strong>才触发的、相对低频的<strong>事务性执行</strong>和<strong>yieldpoint握手</strong>上。
  - 这种设计极大地<strong>降低了mutator的常规执行开销</strong>，使得低暂停时间的并发复制GC在通用硬件上变得更为可行。<img alt="" src="../images/8b375db05156e9ea8aed0dff8505f95304e194664632086d16ecd5828f5cebc3.jpg" /> <em>Table 4.1: Machines used in the evaluation.</em></p>
<h3 id="3-optimistic-copying">3. 乐观复制优化 (Optimistic Copying)<a class="headerlink" href="#3-optimistic-copying" title="Permanent link">&para;</a></h3>
<p><strong>乐观复制优化 (Optimistic Copying) 的实现原理与流程</strong></p>
<ul>
<li><strong>核心动机</strong>：Intel TSX 等 HTM 实现的 <strong>写集 (write-set) 容量</strong> 远小于 <strong>读集 (read-set) 容量</strong>（如论文第5章实验所示，写容量通常被限制在 L1 cache 大小，约20-30KB）。在 collector transaction 中直接执行对象复制会产生大量事务性写操作，极易因超出写容量而 abort。</li>
<li>
<p><strong>核心思想</strong>：将耗时的、产生大量写操作的 <strong>实际复制 (actual copying)</strong> 步骤移出 HTM 事务，在事务外完成。HTM 事务仅负责一个轻量级的 <strong>验证 (validation)</strong> 步骤，该步骤主要由读操作构成，从而极大地降低了对 HTM 写容量的需求。</p>
</li>
<li>
<p><strong>算法详细流程</strong>：</p>
<ul>
<li><strong>阶段一：事务外的乐观复制</strong><ul>
<li>对于 fromspace 中每一个待回收的可达对象 <strong>O</strong>，Collector 在一个专用的 <strong>影子区域 (shadow region)</strong> 中创建其逐字节的副本 <strong>Os</strong>。<strong>Os</strong> 充当了 <strong>O</strong> 在复制开始时刻的快照。</li>
<li>接着，Collector 使用 <strong>Os</strong> 作为源数据，在 tospace 中创建目标对象 <strong>O'</strong>。这一步完成了所有繁重的内存写入工作，但完全在 HTM 事务之外进行，因此不消耗任何 HTM 写容量。</li>
</ul>
</li>
<li><strong>阶段二：事务内的验证与提交</strong><ul>
<li>Collector 启动一个 HTM 事务。</li>
<li>在事务内，Collector <strong>逐字节比较</strong> 原始对象 <strong>O</strong> 和其影子副本 <strong>Os</strong>。</li>
<li><strong>验证成功</strong>：如果 <strong>O</strong> 和 <strong>Os</strong> 完全一致，说明在事务外的复制过程中，Mutator <strong>没有修改 O</strong>。此时，<strong>O'</strong> 是 <strong>O</strong> 的一个有效且完整的副本。Collector 可以安全地在事务内执行以下原子操作：<ul>
<li>将 <strong>O</strong> 的 <strong>转发指针 (forwarding pointer)</strong> 设置为指向 <strong>O'</strong>。</li>
<li>遍历 <strong>O</strong> 的 <strong>remembered set</strong>，将所有指向 <strong>O</strong> 的堆内引用更新为指向 <strong>O'</strong>。</li>
</ul>
</li>
<li><strong>验证失败</strong>：如果 <strong>O</strong> 和 <strong>Os</strong> 不一致，说明 Mutator 在复制过程中修改了 <strong>O</strong>，导致 <strong>O'</strong> 是一个过时的、不正确的副本。此时，Collector <strong>显式中止 (XABORT)</strong> 当前事务。整个过程可以重试，或者采用更复杂的修复策略（如论文所述，可以在事务内通过比较差异来修补 <strong>O'</strong>）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>输入输出关系及在整体系统中的作用</strong></p>
<ul>
<li><strong>输入</strong>：<ul>
<li><strong>fromspace</strong> 中的一组待移动的可达对象。</li>
<li>一个空闲的 <strong>影子区域 (shadow region)</strong> 用于存放快照。</li>
</ul>
</li>
<li><strong>输出</strong>：<ul>
<li><strong>tospace</strong> 中正确、完整的新对象副本。</li>
<li><strong>fromspace</strong> 对象头中的 <strong>转发指针</strong> 被原子地设置。</li>
<li>所有相关的 <strong>堆内引用</strong> 被原子地更新。</li>
<li><strong>fromspace</strong> 的原始区域被释放。</li>
</ul>
</li>
<li><strong>在整体 GC 算法中的作用</strong>：<ul>
<li><strong>降低 HTM 事务负载</strong>：这是该优化最直接的作用。通过将写密集型操作移出事务，显著提高了 collector transaction 的 <strong>成功率 (success rate)</strong>，尤其是在需要移动大量或大型对象时。</li>
<li><strong>维持并发安全性</strong>：该方案巧妙地利用了 HTM 的原子性和隔离性来解决 <strong>lost update problem</strong>。验证步骤确保了只有在对象未被 Mutator 并发修改的情况下，引用更新才是安全的。如果发生并发修改，事务会 abort，保证了系统的强一致性。</li>
<li><strong>提升吞吐量</strong>：更高的事务成功率意味着 Collector 能够更高效地完成区域回收工作，减少了因事务反复 abort 而造成的 CPU 周期浪费，从而提升了整体的 GC 吞吐量和应用性能。</li>
</ul>
</li>
</ul>
<hr />
<p><img alt="" src="../images/6cfaa4e583958ba2970f31ac7b07255d9be2c8e86ed9ace96340668c8b1117e5.jpg" /> <em>Figure 5.8: Success rate curves on Coffee Lake when reusing memory.</em>
<img alt="" src="../images/3205642b8258cabc26576371092cc40f6fe045f106fec3d6a9e56798a14eb2d6.jpg" /> <em>Figure 5.10: Success rate curves on Coffee Lake when warming up caches.</em></p>
<p><strong>关键参数与设计考量</strong></p>
<ul>
<li><strong>影子区域 (shadow region) 管理</strong>：需要一个高效的机制来分配和回收影子区域的内存。其生命周期很短，仅在一个 collector transaction 的上下文中存在。</li>
<li><strong>比较粒度</strong>：逐字节比较虽然简单可靠，但可能不是最高效的。未来可以考虑基于对象字段或缓存行的比较，以减少不必要的内存访问。</li>
<li><strong>修复策略</strong>：论文提到了一种高级优化，即在验证失败时，不是简单地 abort，而是在事务内根据 <strong>O</strong> 和 <strong>Os</strong> 的差异来 <strong>修复 (repair)</strong> <strong>O'</strong>。这可以避免一次完整的重试，但会增加事务内的逻辑复杂度和潜在的写操作。</li>
</ul>
<h3 id="4-cache-warmup">4. 缓存预热优化 (Cache Warmup)<a class="headerlink" href="#4-cache-warmup" title="Permanent link">&para;</a></h3>
<p><strong>缓存预热优化 (Cache Warmup) 的实现原理与作用</strong></p>
<ul>
<li><strong>核心动机</strong>：该优化旨在解决 <strong>HTM (Hardware Transactional Memory)</strong> 事务因 <strong>伪LRU (pseudo-LRU)</strong> 缓存替换策略而导致的非必要中止。如论文第5.3节所述，即使事务的工作集小于缓存容量，伪LRU算法也可能错误地驱逐最近访问过的、属于当前事务的缓存行，从而触发 <strong>容量中止 (capacity abort)</strong>。</li>
<li><strong>根本洞察</strong>：论文通过实验（图5.10）发现，<strong>预热缓存 (warming up the cache)</strong> 能显著提升大型只读事务的成功率。其原理在于，通过预先将事务所需的数据加载到缓存中，可以避免在事务执行期间因缓存未命中而触发伪LRU替换逻辑，从而保护事务的关键数据不被意外驱逐。</li>
</ul>
<p><strong>算法流程与具体实现</strong></p>
<ul>
<li><strong>触发时机</strong>：该优化在 <strong>收集器事务 (collector transaction)</strong> 正式启动之前执行。</li>
<li><strong>执行内容</strong>：<ul>
<li>预先执行一遍 <strong>收集器事务的主体代码逻辑</strong>，特别是那些涉及大量内存读取的操作（例如，在“乐观复制”优化中，对 <strong>shadow objects</strong> 与原始对象的比较操作）。</li>
<li><strong>关键约束</strong>：此预热执行阶段产生的所有计算结果和内存修改都会被 <strong>丢弃 (discarded)</strong>，它唯一的目的就是产生内存访问，以填充CPU缓存。</li>
</ul>
</li>
<li><strong>重复执行</strong>：为了确保高概率命中，预热代码通常会 <strong>执行多次</strong>。这能最大化地将事务所需的所有相关 <strong>缓存行 (cache lines)</strong> 提升到缓存层次结构的高层（如L1/L2），并更新它们在伪LRU状态机中的“新鲜度”。</li>
</ul>
<p><img alt="" src="../images/3205642b8258cabc26576371092cc40f6fe045f106fec3d6a9e56798a14eb2d6.jpg" /> <em>Figure 5.10: Success rate curves on Coffee Lake when warming up caches.</em></p>
<p><strong>输入输出关系及在整体系统中的作用</strong></p>
<ul>
<li><strong>输入</strong>：待执行的 <strong>收集器事务</strong> 的代码路径及其所要访问的内存区域（主要是 <strong>fromspace</strong> 对象和 <strong>shadow region</strong> 中的副本）。</li>
<li><strong>输出</strong>：一个被 <strong>预热 (warmed-up)</strong> 的CPU缓存状态，其中包含了即将在事务中被频繁访问的数据。</li>
<li><strong>在整体GC算法中的作用</strong>：<ul>
<li><strong>提升事务成功率</strong>：通过减少由缓存子系统引起的非冲突性中止，使得 <strong>收集器事务</strong> 能够成功提交，从而顺利完成对象的并发复制和指针更新。</li>
<li><strong>增强算法实用性</strong>：更高的事务成功率意味着 <strong>HTM-based GC</strong> 算法在真实硬件上更加稳定和可靠，这是证明其 <strong>可行性 (viability)</strong> 的关键一步。</li>
<li><strong>与“乐观复制”协同</strong>：此优化特别适用于第8.6节提出的 <strong>乐观复制 (Optimistic Copying)</strong> 优化。因为乐观复制将事务内的大量写操作转换为读操作（用于比较），使得事务变成了一个大型的只读工作负载，而这正是 <strong>缓存预热</strong> 最能发挥效用的场景。</li>
</ul>
</li>
</ul>
<hr />
<p><strong>与其他缓存策略的对比</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">策略</th>
<th style="text-align: left;">操作</th>
<th style="text-align: left;">对HTM事务成功率的影响</th>
<th style="text-align: left;">对系统整体性能的副作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>无操作 (Baseline)</strong></td>
<td style="text-align: left;">无</td>
<td style="text-align: left;">基准水平，易受伪LRU影响</td>
<td style="text-align: left;">无</td>
</tr>
<tr>
<td style="text-align: left;"><strong>缓存无效化 (Invalidation)</strong></td>
<td style="text-align: left;">使用 <code>wbinvd</code> 指令清空所有缓存</td>
<td style="text-align: left;"><strong>提升</strong>（图5.9）</td>
<td style="text-align: left;"><strong>极高</strong>，会清空指令和数据缓存，导致所有线程性能严重下降</td>
</tr>
<tr>
<td style="text-align: left;"><strong>缓存预热 (Warmup)</strong></td>
<td style="text-align: left;">预执行事务代码（丢弃结果）</td>
<td style="text-align: left;"><strong>显著提升</strong>（图5.10）</td>
<td style="text-align: left;"><strong>较低</strong>，仅在GC线程上增加一次性的、可预测的预热开销</td>
</tr>
</tbody>
</table>
<p><strong>结论</strong>：<strong>缓存预热</strong> 是一种巧妙且实用的优化手段。它利用了对底层硬件（特别是缓存替换策略）的深刻理解，以一种低成本的方式，有效规避了 <strong>Intel TSX</strong> 等HTM实现中的一个关键限制，从而为构建低开销的 <strong>并发复制垃圾回收器 (concurrent copying GC)</strong> 铺平了道路。</p>
<h3 id="5-htm">5. HTM容量特性分析<a class="headerlink" href="#5-htm" title="Permanent link">&para;</a></h3>
<p><strong>HTM容量特性分析的核心发现</strong></p>
<ul>
<li>论文通过一系列精心设计的实验，揭示了 <strong>Intel TSX</strong> 的有效容量并非一个固定值，而是受到 <strong>缓存状态 (cache status)</strong> 和 <strong>内存访问模式 (memory access pattern)</strong> 的显著影响。</li>
<li>这一发现成功解释了为何先前文献中关于 <strong>读集 (read-set)</strong> 容量的报告存在巨大差异（从22KB到7.5MB不等），而 <strong>写集 (write-set)</strong> 容量则相对稳定（约20-25KB），始终受限于 <strong>L1数据缓存</strong> 的大小。</li>
</ul>
<p><strong>基线实验与跨平台验证</strong></p>
<ul>
<li>实验复现了 <code>rtm-bench</code> 基准测试，在 <strong>Haswell</strong> 平台上观察到读/写事务的成功率在 <strong>16KB</strong> 附近急剧下降，最大成功事务大小约为22-25KB，与Ritson和Barnes的早期结果一致。</li>
<li>在更新的微架构（<strong>Broadwell</strong>, <strong>Skylake</strong>, <strong>Coffee Lake</strong>）上重复实验，发现 <strong>读集容量随微架构演进而增大</strong>，但依然远未达到L3缓存的理论上限。这表明Intel对TSX的实现进行了改进，但其容量仍受硬件限制。</li>
<li><img alt="" src="../images/fca77d7a9e12d5dad7efe61d5344235db8aeb939383bcc018089466fd3496ab0.jpg" /> <em>Figure 5.1: Success rate curves on Haswell.</em></li>
<li><img alt="" src="../images/573ff1d98148715e9ecdc109fc6fd39d4c0e260749622f993a571e0e8399bb0b.jpg" /> <em>Figure 5.2: Success rate curves on Broadwell.</em></li>
<li><img alt="" src="../images/3e7ac435f47b2ee0991a4572a95522ad9c5ba4bbd81f69f34cc88f178b219055.jpg" /> <em>Figure 5.3: Success rate curves on Skylake.</em></li>
<li><img alt="" src="../images/06532af4750ccb7976030552dd6e5c5ebfcd550dc236c7c0eb5fc12de7760f0d.jpg" /> <em>Figure 5.4: Success rate curves on Coffee Lake.</em></li>
</ul>
<p><strong>内存重用实验：揭示文献矛盾的关键</strong></p>
<ul>
<li>大多数先前研究在测试不同大小的事务时，<strong>重用同一块内存区域</strong>。论文通过修改基准测试来模拟此行为。</li>
<li>结果显示，<strong>重用内存区域能显著提升读事务的容量</strong>。这是因为无论事务是否提交，其执行过程都会影响缓存内容。后续在同一区域上的事务更可能命中缓存，从而避免因缓存行被驱逐而导致的 <strong>容量中止 (capacity abort)</strong>。</li>
<li>这直接解释了为何一些报告了超大读容量（如数MB）的研究得出了看似矛盾的结论：他们的测试方法无意中利用了缓存预热效应。</li>
<li><img alt="" src="../images/285727733597f3a323012def6824b75ad555152879fa5c9c96af26f0cf96d698.jpg" /> <em>Fig. 5.5, Fig. 5.6, Fig. 5.7, and Fig. 5.8 for Haswell, Broadwell, Skylake and Coffee Lake respectively. Figure 5.5: Success rate curves on Haswell when reusing memory.</em></li>
<li><img alt="" src="../images/ed375a170dc9add684be03c249f0760793d4cccae22ac348f32adbe664a98a69.jpg" /> <em>Figure 5.6: Success rate curves on Broadwell when reusing memory.</em></li>
<li><img alt="" src="../images/ba35df4a1299a082ce069a3573c97208ee02b02f4a3d61c595d565f158b3644f.jpg" /> <em>Figure 5.7: Success rate curves on Skylake when reusing memory.</em></li>
<li><img alt="" src="../images/6cfaa4e583958ba2970f31ac7b07255d9be2c8e86ed9ace96340668c8b1117e5.jpg" /> <em>Figure 5.8: Success rate curves on Coffee Lake when reusing memory.</em></li>
</ul>
<p><strong>缓存状态操控实验：深入机理</strong></p>
<ul>
<li>为验证缓存状态是根本原因，论文在 <strong>Coffee Lake</strong> 平台上进行了更直接的操控实验：</li>
<li><strong>缓存清空 (Invalidation)</strong>: 在每次事务前使用 <code>wbinvd</code> 指令清空所有级别的缓存。</li>
<li><strong>缓存预热 (Warmup)</strong>: 在每次事务前，将事务将要读取的内存区域预先读取五次，以确保其驻留在缓存中。</li>
<li>实验结果出人意料：<strong>无论是清空缓存还是预热缓存，都比基线（无操作）获得了更大的最大事务容量</strong>，甚至接近了文献中报告的最大值。</li>
<li><img alt="" src="../images/5e6c6cb543e2599d4e8c5f0989ed846ab5137bcd7a6d78dd13489e494445c681.jpg" /> <em>Figure 5.9: Success rate curves on Coffee Lake when invalidating caches.</em></li>
<li><img alt="" src="../images/3205642b8258cabc26576371092cc40f6fe045f106fec3d6a9e56798a14eb2d6.jpg" /> <em>Figure 5.10: Success rate curves on Coffee Lake when warming up caches.</em></li>
</ul>
<p><strong>根本原因：伪LRU替换策略</strong></p>
<ul>
<li>论文提出假说，认为这一现象的根本原因在于现代CPU普遍采用的 <strong>伪LRU (pseudo-LRU)</strong> 缓存替换策略，而非理想的 <strong>LRU (Least Recently Used)</strong>。</li>
<li>在理想LRU下，只要事务工作集小于缓存，其访问的缓存行就不会被驱逐。</li>
<li>但在 <strong>伪LRU</strong> 下，由于硬件实现的近似性，即使一个缓存行最近被访问过，也可能在缓存压力下被错误地驱逐，从而触发HTM的容量中止。</li>
<li><strong>缓存清空</strong> 之所以有效，是因为它清除了所有无效或无关的缓存行，为事务的工作集提供了“干净”的空间，避免了伪LRU算法的错误决策。</li>
<li><strong>缓存预热</strong> 之所以有效，是因为它提前将事务所需的数据加载到缓存中，并通过多次访问“巩固”了它们在伪LRU年龄队列中的位置，降低了在事务执行期间被驱逐的概率。</li>
</ul>
<hr />
<p><strong>对HTM-GC算法设计的指导意义</strong></p>
<ul>
<li>这些关于HTM容量的深刻洞察，直接指导了后续 <strong>HTM-GC</strong> 算法的优化设计。</li>
<li>论文提出的 <strong>缓存预热 (Cache Warmup)</strong> 优化（见8.7节）正是基于此发现：在启动关键的 <strong>收集器事务 (collector transaction)</strong> 之前，先非事务性地执行一遍事务主体（特别是对象比较逻辑），以预热相关缓存行，从而<strong>显著降低因缓存驱逐导致的事务中止率</strong>，提升大事务的成功概率。</li>
<li>这种将底层硬件特性（HTM容量、缓存行为）与上层算法（垃圾回收）紧密结合的设计思路，是本研究的重要贡献之一。</li>
</ul>
<hr />
<h2 id="4">4. 实验方法与实验结果<a class="headerlink" href="#4" title="Permanent link">&para;</a></h2>
<p><strong>实验设置</strong></p>
<ul>
<li><strong>硬件平台</strong>: 实验在多种 Intel 微架构上进行，包括 <strong>Haswell</strong>, <strong>Broadwell</strong>, <strong>Skylake</strong>, 和 <strong>Coffee Lake</strong>。所有机器均关闭频率缩放（Intel Turbo Boost），但开启超线程（Hyper-Threading）。</li>
<li><strong>软件平台</strong>: 统一使用 <strong>Ubuntu 18.04.5</strong> (内核 5.4.0-47-generic) 和 <strong>GCC 7.5.0</strong> (编译标志 <code>-O2</code>)。系统在测试期间保持尽可能空闲。</li>
<li><strong>基准测试</strong>: 主要基于 <strong>rtm-bench</strong> 基准测试，并对其进行了修改以探究不同因素对 HTM 容量的影响。</li>
<li><strong>GC 算法实现</strong>: 在 <strong>MMTk</strong> 框架中实现。为了简化，一次只允许一个 <strong>region</strong> 进行并发复制回收，并通过 <code>System.gc()</code> 手动触发。只有带有 <code>@ConcurrentCollection</code> 注解的类的对象才会被分配到该 region 中，便于精确控制和调试。</li>
</ul>
<p><strong>结果数据分析</strong></p>
<ul>
<li>
<p><strong>HTM 容量基线测量</strong>:</p>
<ul>
<li>在 <strong>Haswell</strong> 上复现了 rtm-bench 的结果，读/写事务的成功率在 <strong>16KB</strong> 左右急剧下降，最大成功读/写事务分别约为 <strong>22KB</strong> 和 <strong>25KB</strong>。</li>
<li>在更新的微架构（Broadwell, Skylake, Coffee Lake）上，<strong>读容量</strong>有所增加，但<strong>写容量</strong>始终稳定在 <strong>20-25KB</strong> 范围内，与 L1 数据缓存大小一致。</li>
<li>这些结果解释了文献中看似矛盾的报告：早期工作（如 Ritson &amp; Barnes）使用隔离内存区域，测得较低容量；而后期工作可能无意中利用了缓存效应，测得了更高容量。</li>
</ul>
</li>
<li>
<p><strong>影响 HTM 容量的关键因素</strong>:</p>
<ul>
<li><strong>内存区域复用</strong>: 当为不同大小的事务重用同一块内存区域时，<strong>读容量</strong>在所有平台上都显著增加。这表明先前的事务（无论成功与否）会影响缓存状态，从而有利于后续大事务的提交。
    <img alt="" src="../images/285727733597f3a323012def6824b75ad555152879fa5c9c96af26f0cf96d698.jpg" /> <em>Fig. 5.5, Fig. 5.6, Fig. 5.7, and Fig. 5.8 for Haswell, Broadwell, Skylake and Coffee Lake respectively. Figure 5.5: Success rate curves on Haswell when reusing memory.</em>
    <img alt="" src="../images/ed375a170dc9add684be03c249f0760793d4cccae22ac348f32adbe664a98a69.jpg" /> <em>Figure 5.6: Success rate curves on Broadwell when reusing memory.</em>
    <img alt="" src="../images/ba35df4a1299a082ce069a3573c97208ee02b02f4a3d61c595d565f158b3644f.jpg" /> <em>Figure 5.7: Success rate curves on Skylake when reusing memory.</em>
    <img alt="" src="../images/6cfaa4e583958ba2970f31ac7b07255d9be2c8e86ed9ace96340668c8b1117e5.jpg" /> <em>Figure 5.8: Success rate curves on Coffee Lake when reusing memory.</em></li>
<li><strong>缓存状态操作</strong>: 在 <strong>Coffee Lake</strong> 上的实验表明，无论是<strong>无效化缓存</strong> (<code>wbinvd</code>) 还是<strong>预热缓存</strong>（在事务前多次读取目标内存），都能大幅提升<strong>读容量</strong>，使其更接近文献中报告的较高值（如接近 L3 缓存大小）。
    <img alt="" src="../images/5e6c6cb543e2599d4e8c5f0989ed846ab5137bcd7a6d78dd13489e494445c681.jpg" /> <em>Figure 5.9: Success rate curves on Coffee Lake when invalidating caches.</em>
    <img alt="" src="../images/3205642b8258cabc26576371092cc40f6fe045f106fec3d6a9e56798a14eb2d6.jpg" /> <em>Figure 5.10: Success rate curves on Coffee Lake when warming up caches.</em></li>
<li><strong>根本原因</strong>: 作者推测这与 CPU 使用的 <strong>pseudo-LRU</strong> 缓存替换策略有关。在完美 LRU 下，小于缓存的事务数据不会被驱逐，但 pseudo-LRU 可能会错误地驱逐最近使用的行。<strong>无效化</strong>确保了缓存完全为空，而<strong>预热</strong>则确保了所需数据已在缓存中，两者都避免了因替换策略不佳而导致的非必要驱逐和事务中止。</li>
</ul>
</li>
<li>
<p><strong>GC 算法可行性验证</strong>:</p>
<ul>
<li>通过三个精心设计的手工测试程序验证了核心机制：<ol>
<li><strong>栈根引用更新</strong>: 验证了当对象直接从栈根可达时，GC 后其引用能被正确更新。</li>
<li><strong>避免更新丢失</strong>: 验证了在 GC 过程中对对象的并发写入不会丢失，证明了收集器事务的原子性。</li>
<li><strong>传递可达对象处理</strong>: 验证了非直接栈根可达的对象也能被正确追踪、复制，且堆内引用被正确更新。</li>
</ol>
</li>
<li>这些测试成功证明了所提出算法的核心机制——<strong>通过 mutator 事务覆盖“问题间隙”</strong>——是<strong>可行</strong>的。</li>
</ul>
</li>
</ul>
<p><strong>消融实验</strong></p>
<p>论文并未进行传统意义上的、针对最终 GC 性能的完整消融研究（例如，移除某个优化后测量吞吐量或暂停时间的变化）。然而，在 HTM 容量分析部分，其实验设计本身就构成了一系列关键的“消融”或对比实验，用于分离不同变量的影响：</p>
<ul>
<li>
<p><strong>内存访问模式的影响</strong>:</p>
<ul>
<li><strong>对照组</strong>: 使用<strong>隔离的、对齐的</strong>内存区域进行每次事务测试（基线）。</li>
<li><strong>实验组</strong>: <strong>重用</strong>同一块内存区域进行不同大小的事务测试。</li>
<li><strong>结论</strong>: 内存访问模式（特别是缓存行的复用）对观测到的 HTM <strong>读容量</strong>有巨大影响。</li>
</ul>
</li>
<li>
<p><strong>缓存初始状态的影响</strong>:</p>
<ul>
<li><strong>对照组</strong>: <strong>No-op</strong>（即基线设置）。</li>
<li><strong>实验组 1</strong>: 在每次事务前执行 <strong><code>wbinvd</code></strong> 以<strong>无效化</strong>所有缓存。</li>
<li><strong>实验组 2</strong>: 在每次事务前<strong>预热</strong>缓存（多次读取目标内存）。</li>
<li><strong>结论</strong>: 缓存的初始状态（空、满但无关、满且相关）是决定大读事务能否成功的关键因素，这解释了文献中的差异并为优化提供了依据。</li>
</ul>
</li>
<li>
<p><strong>针对 GC 算法本身的优化</strong>:</p>
<ul>
<li>论文提出了两项基于 HTM 容量洞察的优化：<strong>Optimistic Copying</strong>（将事务内大量写操作转为读操作）和 <strong>Cache Warmup</strong>（在收集器事务前预热缓存）。</li>
<li><strong>未来工作</strong>部分明确指出，需要对这些优化进行<strong>性能评估</strong>，以量化它们对单次事务可处理对象数量的影响。这表明这些优化尚未经过严格的消融实验验证其在完整 GC 工作负载下的实际效益。</li>
</ul>
</li>
</ul>
<hr />












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.sections", "navigation.top", "navigation.indexes", "search.suggest", "search.highlight", "content.code.copy"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../../../javascripts/switcher.js"></script>
      
        <script src="../../../javascripts/smart_back.js"></script>
      
    
  </body>
</html>