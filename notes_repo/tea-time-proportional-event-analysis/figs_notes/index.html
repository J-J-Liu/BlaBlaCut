
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://example.com/notes_repo/tea-time-proportional-event-analysis/figs_notes/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>TEA: Time-Proportional Event Analysis 图表详解 - BlaBlaCut</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#tea-time-proportional-event-analysis" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="BlaBlaCut" class="md-header__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            BlaBlaCut
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              TEA: Time-Proportional Event Analysis 图表详解
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到深色模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换到深色模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到浅色模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换到浅色模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="BlaBlaCut" class="md-nav__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    BlaBlaCut
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/Recent/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Recent
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/awesome-data-prefetchers/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Awesome Data Prefetchers
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/micro-2025/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    MICRO 2025
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#figure-1-example-explaining-how-tea-creates-pics-tea-explains-how-performance-events-cause-performance-loss" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 1: Example explaining how TEA creates PICS. TEA explains how performance events cause performance loss.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-2-example-comparing-tea-to-dispatch-tagging-tea-is-time-proportional-whereas-dispatch-tagging-is-not" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 2: Example comparing TEA to dispatch-tagging. TEA is time-proportional whereas dispatch-tagging is not.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-3-performance-event-hierarchy-for-the-stalled-st-commit-state" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 3: Performance event hierarchy for the Stalled (ST) commit state.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#table-1-the-performance-events-of-tea-ibs-spe-and-ris" class="md-nav__link">
    <span class="md-ellipsis">
      
        Table 1: The performance events of TEA, IBS, SPE, and RIS.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-4-tea-microarchitecture" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 4: TEA microarchitecture.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#table-2-baseline-architecture-configuration" class="md-nav__link">
    <span class="md-ellipsis">
      
        Table 2: Baseline architecture configuration.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-5-quantifying-the-error-for-the-pics-obtained-through-ibs-spe-ris-nci-tea-and-tea-tea-achieves-the-highest-accuracy-within-21-and-at-most-77-compared-to-the-golden-reference" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 5: Quantifying the error for the PICS obtained through IBS, SPE, RIS, NCI-TEA, and TEA. TEA achieves the highest accuracy within 2.1% (and at most 7.7%) compared to the golden reference.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-6-pics-for-the-top-3-instructions-as-provided-by-ibs-tea-and-the-golden-reference-gr-the-pics-provided-by-tea-are-accurate-compared-to-the-golden-reference-in-contrast-to-ibs" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 6: PICS for the top-3 instructions as provided by IBS, TEA, and the golden reference (GR). The PICS provided by TEA are accurate compared to the golden reference, in contrast to IBS.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-7-quantifying-the-correlation-between-event-count-and-its-impact-on-performance-some-event-counts-correlate-strongly-with-their-impact-on-performance-while-others-do-not" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 7: Quantifying the correlation between event count and its impact on performance. Some event counts correlate strongly with their impact on performance while others do not.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-8-error-versus-sampling-frequency" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 8: Error versus sampling frequency.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-9-errors-at-instruction-and-function-granularity" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 9: Errors at instruction and function granularity.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-10-lbm-performance-analysis-tea-identifies-the-performance-critical-load-whereas-ibs-does-not" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 10: Lbm performance analysis. TEA identifies the performance-critical load whereas IBS does not.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-11-pics-and-speedup-for-the-most-performancecritical-load-instruction-and-store-instruction-of-lbm-across-a-range-of-prefetch-distances" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 11: PICS and speedup for the most performancecritical load instruction and store instruction of lbm across a range of prefetch distances.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-12-nab-performance-analysis-tea-identifies-that-the-fsqrtd-instruction-issues-too-late-to-hide-its-execution-latency" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 12: Nab performance analysis. TEA identifies that the fsqrt.d instruction issues too late to hide its execution latency.
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="tea-time-proportional-event-analysis">TEA: Time-Proportional Event Analysis 图表详解<a class="headerlink" href="#tea-time-proportional-event-analysis" title="Permanent link">&para;</a></h1>
<h3 id="figure-1-example-explaining-how-tea-creates-pics-tea-explains-how-performance-events-cause-performance-loss">Figure 1: Example explaining how TEA creates PICS. TEA explains how performance events cause performance loss.<a class="headerlink" href="#figure-1-example-explaining-how-tea-creates-pics-tea-explains-how-performance-events-cause-performance-loss" title="Permanent link">&para;</a></h3>
<p><img alt="6ab3d4d6d062d567eaece089793fa0b9b45668c215a54846790eeae0de6930ad.jpg" src="../images/6ab3d4d6d062d567eaece089793fa0b9b45668c215a54846790eeae0de6930ad.jpg" /></p>
<ul>
<li>图片展示了 <strong>TEA</strong> 如何通过采样和 <strong>Performance Signature Vector (PSV)</strong> 生成 <strong>Per-Instruction Cycle Stacks (PICS)</strong>，以解释性能损失的根源。</li>
<li>
<p>图中分为三个部分：(a) TEA 采样数据表、(b) 示例代码、(c) 最终生成的 PICS 图表。</p>
</li>
<li>
<p><strong>图 (a) TEA samples</strong>：</p>
</li>
<li>表格记录了 5 次采样（Sample 1 至 Sample 5），每行包含：<ul>
<li><strong>Timestamp</strong>：采样发生的时间点（单位：时钟周期）。</li>
<li><strong>Instruction address</strong>：被采样的指令地址（如 I1, I4 等）。</li>
<li><strong>PSV</strong>：三位二进制向量，分别对应三种性能事件：</li>
<li>第一位：<strong>I$ miss</strong>（指令缓存未命中）</li>
<li>第二位：<strong>D$ miss</strong>（数据缓存未命中）</li>
<li>第三位：<strong>Branch mispredict</strong>（分支预测错误）</li>
</ul>
</li>
<li>PSV 中“1”表示该指令在采样时刻正受此事件影响，“0”表示无影响。</li>
<li>
<p>示例：</p>
<ul>
<li>Sample 1：I1 被采样，PSV 为 <code>1 0 0</code> → 仅受 <strong>I$ miss</strong> 影响。</li>
<li>Sample 2：I4 被采样，PSV 为 <code>0 1 0</code> → 仅受 <strong>D$ miss</strong> 影响。</li>
<li>Sample 3：I1 被采样，PSV 为 <code>0 0 1</code> → 仅受 <strong>Branch mispredict</strong> 影响。</li>
<li>Sample 4 &amp; 5：I1–I4 并行提交，PSV 全为 <code>0 0 0</code> → 无性能事件，归入 <strong>Base</strong> 类别。</li>
</ul>
</li>
<li>
<p><strong>图 (b) Example code</strong>：</p>
</li>
<li>展示了一段简短循环代码，包含四条核心指令：<ul>
<li><code>I1 lw a4, (a5)</code>：加载指令，可能触发 <strong>D$ miss</strong>。</li>
<li><code>I2 addw a0, a0, a4</code>：算术运算。</li>
<li><code>I3 addi a5, a5, 4</code>：地址递增。</li>
<li><code>I4 bne a5, a3, I1</code>：条件跳转，可能触发 <strong>Branch mispredict</strong>。</li>
</ul>
</li>
<li>
<p>代码结构说明了为何 I1 和 I4 是性能关键指令。</p>
</li>
<li>
<p><strong>图 (c) Time-proportional PICS</strong>：</p>
</li>
<li>横轴为 <strong>Clock Cycles</strong>，纵轴为 <strong>Static instructions</strong>（I1–I4）。</li>
<li>每个指令的柱状图按 PSV 分类，显示其贡献的周期数：<ul>
<li><strong>Base</strong>（浅蓝）：无性能事件，正常执行。</li>
<li><strong>I$ miss</strong>（橙色）：I1 因指令缓存未命中消耗约 1k 周期。</li>
<li><strong>D$ miss</strong>（青色）：I1 因数据缓存未命中消耗约 1k 周期。</li>
<li><strong>Branch mispredict</strong>（黄色）：I4 因分支预测错误消耗约 1k 周期。</li>
</ul>
</li>
<li>总计：I1 占用约 3k 周期（含两次事件），I4 占用约 1k 周期，I2/I3 各占约 0.5k 周期（并行执行分摊）。</li>
<li>
<p><strong>关键结论</strong>：TEA 准确将性能损失归因于具体指令及其触发的事件，实现时间比例分配。</p>
</li>
<li>
<p><strong>核心机制总结</strong>：</p>
</li>
<li>TEA 在 <strong>commit stage</strong> 采样，确保时间比例性。</li>
<li>通过 <strong>PSV</strong> 记录每个动态指令所经历的性能事件组合。</li>
<li>
<p>最终聚合所有采样，按静态指令和事件类型构建 <strong>PICS</strong>，直观揭示性能瓶颈。</p>
</li>
<li>
<p><strong>对比传统方法</strong>：</p>
</li>
<li>若使用 <strong>dispatch-tagging</strong>（如 IBS/SPE/RIS），可能错误采样 I5 或 I8，而非实际阻塞提交的 I1。</li>
<li>TEA 避免此类偏差，提供更准确的性能归因。</li>
</ul>
<h3 id="figure-2-example-comparing-tea-to-dispatch-tagging-tea-is-time-proportional-whereas-dispatch-tagging-is-not">Figure 2: Example comparing TEA to dispatch-tagging. TEA is time-proportional whereas dispatch-tagging is not.<a class="headerlink" href="#figure-2-example-comparing-tea-to-dispatch-tagging-tea-is-time-proportional-whereas-dispatch-tagging-is-not" title="Permanent link">&para;</a></h3>
<p><img alt="74ab2ef30a3ba5d969cd61f92fd8e514ab517907f123077b196ef3f913d14afe.jpg" src="../images/74ab2ef30a3ba5d969cd61f92fd8e514ab517907f123077b196ef3f913d14afe.jpg" /></p>
<ul>
<li>图片展示了 <strong>TEA</strong> 与 <strong>Dispatch-tagging</strong>（如 IBS）在性能事件追踪机制上的核心差异，旨在说明为何 TEA 是 <strong>time-proportional</strong> 而后者不是。</li>
<li>图中包含两个子图：(a) TEA 的工作流程；(b) Dispatch-tagging 的工作流程。两者均基于一个典型的乱序执行处理器流水线，包括 Fetch、Decode、Rename、Dispatch、Issue Buffers、Commit 等阶段。</li>
<li>在 (a) TEA 部分：</li>
<li><strong>Performance Signature Vector (PSV)</strong> 格式位于顶部，包含多个性能事件位，如 ICACHE/TLB miss、L1I miss、ITLB miss、Branch mispredict、LLC miss、L1D miss、DTLB miss。</li>
<li>PSV 在指令进入流水线时被初始化并随指令流动，在不同阶段根据发生的事件更新相应位。</li>
<li><strong>Sampler</strong> 位于 <strong>Re-Order Buffer (ROB)</strong> 头部之后，采样的是当前暴露延迟的指令（即 ROB 头部指令），确保采样点反映真实性能瓶颈。</li>
<li>示例中，指令 I1 因 L1D miss 和 DTLB miss 被阻塞在 ROB 头部，Sampler 采样 I1 及其 PSV（1000000），正确归因于该指令。</li>
<li>在 (b) Dispatch-tagging 部分：</li>
<li>采样器位于 <strong>Dispatch</strong> 阶段，标记的是当前被调度的指令（如 I5），而非 ROB 头部指令。</li>
<li>尽管此时 I1 仍在 ROB 头部阻塞，但采样器却记录了 I5 的 PSV（1000000），这导致性能事件被错误归因到非关键指令。</li>
<li>这种机制忽略了指令在 commit 阶段的实际影响，因此 <strong>不具备 time-proportionality</strong>。</li>
<li>关键对比表格：</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>TEA</th>
<th>Dispatch-tagging</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>采样点</strong></td>
<td>ROB 头部（commit 阶段）</td>
<td>Dispatch 阶段</td>
</tr>
<tr>
<td><strong>采样对象</strong></td>
<td>当前暴露延迟的指令</td>
<td>当前被调度的指令</td>
</tr>
<tr>
<td><strong>Time-proportional</strong></td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td><strong>事件归因准确性</strong></td>
<td>高（归因于实际造成延迟的指令）</td>
<td>低（可能归因于无关指令）</td>
</tr>
<tr>
<td><strong>代表性示例</strong></td>
<td>I1（阻塞指令）被采样</td>
<td>I5（调度指令）被采样</td>
</tr>
</tbody>
</table>
<ul>
<li>图中数字标注了关键步骤：</li>
<li>①～⑤ 为 TEA 流程中的事件传播与采样；</li>
<li>⑥～⑦ 为 Dispatch-tagging 中的错误采样点。</li>
<li>总结：该图通过直观对比揭示了 TEA 的核心优势——<strong>在 commit 阶段采样以确保时间比例性</strong>，从而准确识别性能瓶颈指令及其相关事件，而传统 dispatch-tagging 方法因采样点前置导致归因偏差，无法提供准确的性能分析。</li>
</ul>
<h3 id="figure-3-performance-event-hierarchy-for-the-stalled-st-commit-state">Figure 3: Performance event hierarchy for the Stalled (ST) commit state.<a class="headerlink" href="#figure-3-performance-event-hierarchy-for-the-stalled-st-commit-state" title="Permanent link">&para;</a></h3>
<p><img alt="a4284d00fc9253f43ab27e72c7760d5e67d36ff852e7b04dbc1205345da8368e.jpg" src="../images/a4284d00fc9253f43ab27e72c7760d5e67d36ff852e7b04dbc1205345da8368e.jpg" /></p>
<ul>
<li>图片展示了 <strong>Stalled (ST) commit state</strong> 下的性能事件层级结构，旨在说明如何通过选择关键事件来平衡分析的可解释性与硬件开销。</li>
<li>该图分为三个主要层级（Level 1, Level 2, Level 3），从底层的通用事件逐步向上抽象为更具体的依赖或独立事件。</li>
<li><strong>Level 1</strong> 包含最基础的事件：<strong>Data Load Stall (DLS)</strong>，代表所有数据加载相关的停顿。</li>
<li><strong>Level 2</strong> 分为两类：</li>
<li><strong>Independent events</strong>：如 <strong>L1 data cache miss</strong> 和 <strong>L1 data TLB miss</strong>，它们可独立发生，互不影响。</li>
<li><strong>Dependent events</strong>：如 <strong>L2 data TLB miss</strong>，它依赖于 L1 TLB miss 的发生。</li>
<li><strong>Level 3</strong> 展示了更高层的依赖事件，例如 <strong>LLC miss</strong>，它依赖于 L1 数据缓存未命中。</li>
<li>图中用虚线框标出 <strong>Dependent events</strong>，强调其依赖关系；实线箭头表示事件之间的因果或依赖路径。</li>
<li>右侧部分展示了不同事件集合对应的 <strong>PSV (Performance Signature Vector)</strong> 格式，每个 PSV 由多个位组成，每位对应一个事件。</li>
<li>PSV 示例包括：</li>
<li>仅包含 DLS 的单一位 PSV。</li>
<li>包含 L1D 和 L1TLB 的两位 PSV。</li>
<li>包含 L1D、L1TLB 和 LLC 的三位 PSV。</li>
<li>包含 L1D、L1TLB、LLC 和 L2TLB 的四位 PSV。</li>
<li>通过选择不同层级的事件组合，可以在保持低开销的同时提升分析的粒度和可解释性。</li>
<li>作者指出，保留根事件（如 L1 miss）对于避免丢失可解释性至关重要，即使捕获了更高级别的事件（如 LLC miss）。</li>
</ul>
<h3 id="table-1-the-performance-events-of-tea-ibs-spe-and-ris">Table 1: The performance events of TEA, IBS, SPE, and RIS.<a class="headerlink" href="#table-1-the-performance-events-of-tea-ibs-spe-and-ris" title="Permanent link">&para;</a></h3>
<p><img alt="eb6db800b0743fd8564fb4a8f11a2c335ff65e65a3eaf511e8e7806f0bc37165.jpg" src="../images/eb6db800b0743fd8564fb4a8f11a2c335ff65e65a3eaf511e8e7806f0bc37165.jpg" /></p>
<ul>
<li>该图片为 <strong>Table 1</strong>，标题为 “The performance events of TEA, IBS, SPE, and RIS”，用于对比四种性能分析工具所支持的性能事件。</li>
<li>表格包含四列：<strong>Event</strong>（事件名称）、<strong>Description</strong>（事件描述）、以及三列分别对应 <strong>TEA</strong>、<strong>IBS</strong>、<strong>SPE</strong> 和 <strong>RIS</strong> 的支持情况（用勾号 √ 或叉号 × 表示）。</li>
<li>所有事件按其所属的 <strong>commit state</strong> 分组：</li>
<li><strong>DR-</strong>（Drained 状态）：包括 DR-L1（L1 instruction cache miss）、DR-TLB（L1 instruction TLB miss）、DR-SQ（Store instruction stalled at dispatch）。</li>
<li><strong>FL-</strong>（Flushed 状态）：包括 FL-MB（Mispredicted branch）、FL-EX（Instruction caused exception）、FL-MO（Memory ordering violation）。</li>
<li><strong>ST-</strong>（Stalled 状态）：包括 ST-L1（L1 data cache miss）、ST-TLB（L1 data TLB miss）、ST-LLC（LLC miss caused by a load instruction）。</li>
</ul>
<p>以下是各工具对事件的支持情况汇总：</p>
<table>
<thead>
<tr>
<th>Event</th>
<th>Description</th>
<th>TEA</th>
<th>IBS</th>
<th>SPE</th>
<th>RIS</th>
</tr>
</thead>
<tbody>
<tr>
<td>DR-L1</td>
<td>L1 instruction cache miss</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>DR-TLB</td>
<td>L1 instruction TLB miss</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>DR-SQ</td>
<td>Store instruction stalled at dispatch</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>FL-MB</td>
<td>Mispredicted branch</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>FL-EX</td>
<td>Instruction caused exception</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>FL-MO</td>
<td>Memory ordering violation</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>ST-L1</td>
<td>L1 data cache miss</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>ST-TLB</td>
<td>L1 data TLB miss</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>ST-LLC</td>
<td>LLC miss caused by a load instruction</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>TEA</strong> 支持全部九个事件，是唯一覆盖所有三类 commit state（Drained, Flushed, Stalled）完整事件集的工具。</li>
<li><strong>IBS</strong> 缺少对 DR-SQ、FL-EX、FL-MO 的支持。</li>
<li><strong>SPE</strong> 缺少对 DR-L1、DR-TLB、FL-EX、FL-MO 的支持。</li>
<li><strong>RIS</strong> 缺少对 DR-SQ、FL-EX、FL-MO 的支持。</li>
<li>从表格可见，<strong>TEA 在事件覆盖广度上显著优于其他三种工具</strong>，尤其在解释 <strong>Flushed 状态</strong>（如异常和内存序违规）和 <strong>Drained 状态中的存储队列阻塞</strong>（DR-SQ）方面具有独特优势。</li>
<li>该表佐证了论文中关于 <strong>TEA 通过精心选择事件实现高可解释性与低开销平衡</strong> 的设计目标。</li>
</ul>
<h3 id="figure-4-tea-microarchitecture">Figure 4: TEA microarchitecture.<a class="headerlink" href="#figure-4-tea-microarchitecture" title="Permanent link">&para;</a></h3>
<p><img alt="1c5f5c65e53685954b038cf73486a548a8f2907143fab503d8acc91916488c0d.jpg" src="../images/1c5f5c65e53685954b038cf73486a548a8f2907143fab503d8acc91916488c0d.jpg" /></p>
<ul>
<li>图片展示了 <strong>TEA microarchitecture</strong> 的完整数据流与硬件模块布局，核心目标是为每个动态指令构建 <strong>Performance Signature Vector (PSV)</strong> 并在 commit 阶段进行时间比例采样。</li>
<li>整个架构围绕 <strong>Re-Order Buffer (ROB)</strong> 展开，所有指令的 PSV 最终存储于 ROB 条目中，并通过 <strong>Sample Selection</strong> 单元在 commit 时触发采样。</li>
<li><strong>Fetch &amp; PreDecode</strong> 阶段：从 I-Cache 和 I-TLB 获取指令包，同时检测 <strong>DR-L1</strong>（L1 指令缓存未命中）和 <strong>DR-TLB</strong>（L1 指令 TLB 未命中）事件。这些事件被编码进一个 <strong>2b PSV</strong>，并仅分配给 fetch packet 中的第一个指令，其余指令初始化为 0。</li>
<li><strong>Fetch Buffer</strong> 存储多个 fetch packet，每个指令携带其 PSV 向下传递至 Decode 阶段。</li>
<li><strong>Decode</strong> 阶段：将指令解码为 µops，PSV 被复制到每个 µop 的元数据中，继续向下游传递。</li>
<li><strong>Dispatch</strong> 阶段：µops 被插入 ROB 和功能单元队列。在此阶段，检测 <strong>DR-SQ</strong>（Store Queue 满导致 ROB drain）事件，并将其记录到 µop 的 PSV 中。同时，PSV 被写入 ROB 条目。</li>
<li><strong>LSU (Load/Store Unit)</strong> 阶段：在 load 执行前可检测 <strong>ST-TLB</strong>（数据 TLB 未命中），因此在 LSU 条目中预留一位用于记录该事件。<strong>ST-L1</strong> 和 <strong>ST-LLC</strong> 事件在 cache 响应后通过 Writeback 阶段更新到 PSV。</li>
<li><strong>ALU / FPU</strong> 阶段：不直接产生新事件，但执行结果可能影响后续状态。</li>
<li><strong>Writeback</strong> 阶段：将最终的 PSV 更新回 ROB 条目，确保在 commit 时 PSV 包含所有相关事件。</li>
<li><strong>Re-Order Buffer (ROB)</strong> 是 PSV 的最终存储位置，每个条目包含一个 <strong>9b PSV</strong>，对应 TEA 支持的九个性能事件：
  | 事件类型 | 事件名称 | 说明 |
  |----------|----------|------|
  | Drained (DR) | DR-L1 | L1 指令缓存未命中 |
  | Drained (DR) | DR-TLB | L1 指令 TLB 未命中 |
  | Drained (DR) | DR-SQ | Store Queue 满导致 ROB drain |
  | Flushed (FL) | FL-MB | 分支预测错误 |
  | Flushed (FL) | FL-EX | 异常发生 |
  | Flushed (FL) | FL-MO | 内存顺序违规 |
  | Stalled (ST) | ST-L1 | L1 数据缓存未命中 |
  | Stalled (ST) | ST-TLB | L1 数据 TLB 未命中 |
  | Stalled (ST) | ST-LLC | LLC 数据缓存未命中 |</li>
<li><strong>Sample Selection</strong> 单元连接 ROB 头部，根据当前 commit 状态（Compute, Stalled, Drained, Flushed）选择要采样的指令及其 PSV。它继承自 TIP [22] 的时间比例采样逻辑。</li>
<li><strong>PMU (Performance Monitoring Unit)</strong> 通过周期计数器触发采样事件，通知 Sample Selection 单元。</li>
<li><strong>Control Status Registers (CSRs)</strong> 存储采样结果，包括时间戳、标志位、指令地址和 PSV，随后触发中断供软件读取。</li>
<li><strong>关键设计原则</strong>：</li>
<li><strong>时间比例性</strong>：采样点位于 commit 阶段，确保样本反映的是实际暴露延迟的指令。</li>
<li><strong>事件完整性</strong>：PSV 跟踪所有在指令生命周期内发生的性能事件，而非仅前端事件。</li>
<li><strong>低开销</strong>：通过精心选择事件集（仅 9 个）和复用现有结构（如 ROB 条目），将存储开销控制在 249 字节/核。</li>
<li><strong>非关键路径</strong>：所有 TEA 逻辑均不在处理器的关键路径上，不影响时钟频率。</li>
<li><strong>采样流程</strong>：</li>
<li>PMU 计数器达到阈值，触发采样事件。</li>
<li>Sample Selection 根据 ROB 状态选择指令。</li>
<li>读取该指令的 PSV 和地址。</li>
<li>将样本写入 CSRs。</li>
<li>触发中断，软件读取并存储样本。</li>
<li><strong>与传统方法对比</strong>：不同于 IBS/SPE/RIS 在 fetch/dispatch 阶段标记指令，TEA 在 commit 阶段采样，避免了因前端阻塞导致的样本偏差，从而实现更高的准确性（平均误差 2.1%）。</li>
</ul>
<h3 id="table-2-baseline-architecture-configuration">Table 2: Baseline architecture configuration.<a class="headerlink" href="#table-2-baseline-architecture-configuration" title="Permanent link">&para;</a></h3>
<p><img alt="76d7052a3fe24470118c7419e0884689b88544d5d9360f69e5dc810d236b1921.jpg" src="../images/76d7052a3fe24470118c7419e0884689b88544d5d9360f69e5dc810d236b1921.jpg" /></p>
<ul>
<li>该表格详细列出了用于评估 TEA 的基准架构配置，核心为 <strong>OoO BOOM [58]</strong>，运行在 <strong>RV64IMAFDCSUX</strong> 指令集架构上，主频为 <strong>3.2 GHz</strong>。</li>
<li>前端（Front-end）配置包括：</li>
<li><strong>8-wide fetch</strong>，配备 <strong>48-entry fetch buffer</strong> 和 <strong>4-wide decode</strong>。</li>
<li>使用 <strong>28 KB TAGE branch predictor</strong>，支持最多 <strong>30 outstanding branches</strong>。</li>
<li>配备 <strong>60-entry fetch target queue</strong>。</li>
<li>执行单元（Execute）部分包含：</li>
<li><strong>192-entry ROB</strong>（Reorder Buffer），以及 <strong>192 integer/floating-point physical registers</strong>。</li>
<li><strong>48-entry dual-issue memory queue</strong>、<strong>80-entry 4-issue integer queue</strong> 和 <strong>48-entry dual-issue floating-point queue</strong>。</li>
<li>加载/存储单元（LSU）配置如下：</li>
<li><strong>64-entry load/store queue</strong>。</li>
<li>L1 缓存：<strong>32 KB 8-way I-cache</strong> 和 <strong>32 KB 8-way D-cache</strong>，配备 <strong>16 MSHRs</strong>、<strong>64 SDQ/RPQ entries</strong> 及 <strong>next-line prefetcher</strong>。</li>
<li>LLC（Last Level Cache）：<strong>2 MiB 16-way dual-bank</strong>，配备 <strong>12 MSHRs</strong>。</li>
<li>TLB：采用 <strong>Page Table Walker</strong>，包含 <strong>32-entry fully-assoc L1 D-TLB</strong> 和 <strong>32-entry fully-assoc L1 I-TLB</strong>，以及 <strong>1024-entry direct-mapped L2 TLB</strong>。</li>
<li>内存子系统（Memory）配置为：</li>
<li><strong>16 GB DDR3 FR-FCFS quad-rank</strong>，最大带宽 <strong>16 GB/s</strong>。</li>
<li>内存延迟为 <strong>14-14-14 (CAS-RCD-RP)</strong> @ 1 GHz，支持 <strong>8 queue depth</strong> 和 <strong>32 max reads/writes</strong>。</li>
<li>操作系统（OS）为 <strong>Buildroot, Linux 5.7.0</strong>。</li>
</ul>
<table>
<thead>
<tr>
<th>Part</th>
<th>Configuration</th>
</tr>
</thead>
<tbody>
<tr>
<td>Core</td>
<td>OoO BOOM [58]: RV64IMAFDCSUX @ 3.2 GHz</td>
</tr>
<tr>
<td>Front-end</td>
<td>8-wide fetch, 48-entry fetch buffer, 4-wide decode, 28 KB TAGE branch predictor, 60-entry fetch target queue, max. 30 outstanding branches</td>
</tr>
<tr>
<td>Execute</td>
<td>192-entry ROB, 192 integer/floating-point physical registers, 48-entry dual-issue memory queue, 80-entry 4-issue integer queue, 48-entry dual-issue floating-point queue</td>
</tr>
<tr>
<td>LSU</td>
<td>64-entry load/store queue</td>
</tr>
<tr>
<td>L1</td>
<td>32 KB 8-way I-cache, 32 KB 8-way D-cache w/ 16 MSHRs, 64 SDQ/RPQ entries, next-line prefetcher</td>
</tr>
<tr>
<td>LLC</td>
<td>2 MiB 16-way dual-bank w/ 12 MSHRs</td>
</tr>
<tr>
<td>TLB</td>
<td>Page Table Walker, 32-entry fully-assoc L1 D-TLB, 32-entry fully-assoc L1 I-TLB, 1024-entry direct-mapped L2 TLB</td>
</tr>
<tr>
<td>Memory</td>
<td>16 GB DDR3 FR-FCFS quad-rank, 16 GB/s maximum bandwidth, 14-14-14 (CAS-RCD-RP) latencies @ 1 GHz, 8 queue depth, 32 max reads/writes</td>
</tr>
<tr>
<td>OS</td>
<td>Buildroot, Linux 5.7.0</td>
</tr>
</tbody>
</table>
<h3 id="figure-5-quantifying-the-error-for-the-pics-obtained-through-ibs-spe-ris-nci-tea-and-tea-tea-achieves-the-highest-accuracy-within-21-and-at-most-77-compared-to-the-golden-reference">Figure 5: Quantifying the error for the PICS obtained through IBS, SPE, RIS, NCI-TEA, and TEA. TEA achieves the highest accuracy within 2.1% (and at most 7.7%) compared to the golden reference.<a class="headerlink" href="#figure-5-quantifying-the-error-for-the-pics-obtained-through-ibs-spe-ris-nci-tea-and-tea-tea-achieves-the-highest-accuracy-within-21-and-at-most-77-compared-to-the-golden-reference" title="Permanent link">&para;</a></h3>
<p><img alt="06a45f0c65adb0893d2611eb63833d4c75d2658daa31b83ada7657858799aeb6.jpg" src="../images/06a45f0c65adb0893d2611eb63833d4c75d2658daa31b83ada7657858799aeb6.jpg" /></p>
<ul>
<li>图表标题为 Figure 5，旨在量化通过 IBS、SPE、RIS、NCI-TEA 和 TEA 五种方法生成的 Per-Instruction Cycle Stacks（PICS）相对于“黄金参考”（golden reference）的误差。</li>
<li><strong>TEA 在所有基准测试中均表现出最低误差</strong>，平均误差仅为 <strong>2.1%</strong>，最大误差不超过 <strong>7.7%</strong>，显著优于其他方法。</li>
<li>其他方法误差普遍较高：IBS、SPE、RIS 平均误差在 <strong>55.5%–56.0%</strong> 之间；NCI-TEA 平均误差为 <strong>11.3%</strong>，最高达 <strong>22.0%</strong>。</li>
<li>图表横轴列出 24 个 SPEC CPU2017 基准测试程序及一个“Average”汇总项，纵轴表示误差百分比（0%–80%）。</li>
<li>每个基准测试对应五个柱状图，分别代表 IBS（深蓝）、SPE（中蓝）、RIS（浅紫）、NCI-TEA（灰紫）、TEA（黑），颜色与图例一致。</li>
<li>多数基准测试中，TEA 的误差柱高度远低于其他方法，尤其在 lbm、omnetpp、nab 等程序中优势明显。</li>
<li>NCI-TEA 虽优于 IBS/SPE/RIS，但仍显著劣于 TEA，说明仅采样“下一提交指令”不足以实现高精度。</li>
<li>IBS、SPE、RIS 三者误差相近，证实其“前端标记”机制导致非时间比例性，系统性高估部分指令性能影响。</li>
<li>下表总结各方法在不同基准测试中的典型误差表现：</li>
</ul>
<table>
<thead>
<tr>
<th>Benchmark</th>
<th>IBS Error</th>
<th>SPE Error</th>
<th>RIS Error</th>
<th>NCI-TEA Error</th>
<th>TEA Error</th>
</tr>
</thead>
<tbody>
<tr>
<td>perlbanch</td>
<td>~58%</td>
<td>~58%</td>
<td>~60%</td>
<td>~15%</td>
<td>~5%</td>
</tr>
<tr>
<td>gcc</td>
<td>~55%</td>
<td>~55%</td>
<td>~57%</td>
<td>~10%</td>
<td>~3%</td>
</tr>
<tr>
<td>bwaves</td>
<td>~75%</td>
<td>~75%</td>
<td>~78%</td>
<td>~18%</td>
<td>~4%</td>
</tr>
<tr>
<td>lbm</td>
<td>~78%</td>
<td>~78%</td>
<td>~79%</td>
<td>~10%</td>
<td><strong>&lt;1%</strong></td>
</tr>
<tr>
<td>omnetpp</td>
<td>~70%</td>
<td>~70%</td>
<td>~72%</td>
<td>~12%</td>
<td>~3%</td>
</tr>
<tr>
<td>nab</td>
<td>~70%</td>
<td>~70%</td>
<td>~72%</td>
<td>~15%</td>
<td>~2%</td>
</tr>
<tr>
<td>Average</td>
<td>55.6%</td>
<td>55.5%</td>
<td>56.0%</td>
<td>11.3%</td>
<td><strong>2.1%</strong></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>结论</strong>：TEA 通过时间比例采样和完整事件追踪，实现了前所未有的 PICS 精度，是当前最可靠的指令级性能分析工具。</li>
</ul>
<h3 id="figure-6-pics-for-the-top-3-instructions-as-provided-by-ibs-tea-and-the-golden-reference-gr-the-pics-provided-by-tea-are-accurate-compared-to-the-golden-reference-in-contrast-to-ibs">Figure 6: PICS for the top-3 instructions as provided by IBS, TEA, and the golden reference (GR). The PICS provided by TEA are accurate compared to the golden reference, in contrast to IBS.<a class="headerlink" href="#figure-6-pics-for-the-top-3-instructions-as-provided-by-ibs-tea-and-the-golden-reference-gr-the-pics-provided-by-tea-are-accurate-compared-to-the-golden-reference-in-contrast-to-ibs" title="Permanent link">&para;</a></h3>
<p><img alt="f038b33e872a951087c91f37efdf225c0f0ca0ea8fb4c1342f438b0afdb8dbd3.jpg" src="../images/f038b33e872a951087c91f37efdf225c0f0ca0ea8fb4c1342f438b0afdb8dbd3.jpg" /></p>
<ul>
<li>图片展示了四个基准测试（bwaves、omnetpp、fotonik3d、exchange2）中，<strong>前三大耗时指令</strong>的 Per-Instruction Cycle Stacks（PICS），分别由 IBS、TEA 和黄金参考（GR）生成，用于对比精度。</li>
<li><strong>TEA 的 PICS 与 GR 高度一致</strong>，而 IBS 的结果存在显著偏差，验证了 TEA 在时间比例性上的优势。</li>
<li>每个子图包含三个堆叠柱状图，分别对应 IBS、TEA、GR，横轴为指令地址，纵轴为周期数（Cycles），不同颜色代表不同性能事件组合。</li>
<li>事件分类包括：<strong>base</strong>（无事件）、<strong>others</strong>（其他未归类事件）、<strong>ST-L1</strong>（L1数据缓存缺失）、<strong>ST-TLB</strong>（L1数据TLB缺失）、<strong>ST-LLC</strong>（LLC缺失）、<strong>FL-MB</strong>（分支误预测）、<strong>FL-MO</strong>（内存顺序违规）、<strong>DR-SQ</strong>（存储队列满）、<strong>DR-L1</strong>（L1指令缓存缺失）、<strong>DR-TLB</strong>（L1指令TLB缺失）等。</li>
</ul>
<p>以下是各子图的关键观察：</p>
<table>
<thead>
<tr>
<th>子图</th>
<th>基准测试</th>
<th>主要发现</th>
</tr>
</thead>
<tbody>
<tr>
<td>(a) bwaves</td>
<td>指令 <code>fld fa2,(a4)</code>、<code>fld fa1,(a1)</code>、<code>fld fa5,(a2)</code></td>
<td>TEA 与 GR 几乎重合；IBS 高估了 base 和 ST-L1 组件，低估了 ST-TLB 和 ST-LLC；<strong>组合事件如 ST-L1,ST-TLB 被准确捕捉</strong>。</td>
</tr>
<tr>
<td>(b) omnetpp</td>
<td>指令 <code>sw t1,120(a1)</code>、<code>ld a6,104(a1)</code>、<code>ld a7,104(t4)</code></td>
<td>TEA 与 GR 高度匹配；IBS 错误地将大量周期归因于 base，而忽略了 FL-MB 和 ST-LLC 等关键事件；<strong>FL-MO 事件在 GR 和 TEA 中均被识别</strong>。</td>
</tr>
<tr>
<td>(c) fotonik3d</td>
<td>指令 <code>fld ft2,24(a5)</code>、<code>fld ft2,24(a3)</code>、<code>ld a5,48(sp)</code></td>
<td>TEA 与 GR 几乎完全一致；IBS 完全未能捕捉到任何性能事件，所有周期均归为 base；<strong>表明 IBS 在此场景下完全失效</strong>。</td>
</tr>
<tr>
<td>(d) exchange2</td>
<td>指令 <code>bgtz a2,b2ce</code>、<code>bgtz a4,a4f5a</code>、<code>lw a2,(s4)</code></td>
<td>TEA 与 GR 接近；IBS 对 lw 指令的 DR-SQ 和 DR-L1 事件有部分捕捉，但整体仍不准确；<strong>这是 IBS 表现最好的案例，但仍远逊于 TEA</strong>。</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>综合结论</strong>：TEA 能精确归因每个指令的执行周期至具体性能事件，尤其擅长处理<strong>组合事件</strong>和<strong>非计算状态（Stalled/Flushed/Drained）</strong>，而 IBS 因在前端标记指令，导致样本偏向非关键指令，造成严重误判。</li>
<li>此图有力支持论文核心主张：<strong>只有时间比例性的分析方法（如 TEA）才能提供可信的性能归因</strong>，从而指导有效优化。</li>
</ul>
<h3 id="figure-7-quantifying-the-correlation-between-event-count-and-its-impact-on-performance-some-event-counts-correlate-strongly-with-their-impact-on-performance-while-others-do-not">Figure 7: Quantifying the correlation between event count and its impact on performance. Some event counts correlate strongly with their impact on performance while others do not.<a class="headerlink" href="#figure-7-quantifying-the-correlation-between-event-count-and-its-impact-on-performance-some-event-counts-correlate-strongly-with-their-impact-on-performance-while-others-do-not" title="Permanent link">&para;</a></h3>
<p><img alt="50c548710d2cb6dfd0c158e39611a7a53a8ef3dd34c3922c9003e5c31c34f6fb.jpg" src="../images/50c548710d2cb6dfd0c158e39611a7a53a8ef3dd34c3922c9003e5c31c34f6fb.jpg" /></p>
<ul>
<li>图片为箱线图，标题为“Figure 7: Quantifying the correlation between event count and its impact on performance”，旨在量化性能事件计数与其对性能实际影响之间的相关性。</li>
<li>横轴列出九种性能事件，按其所属的 commit state 分组：DR-SQ、DR-TLB、ST-TLB、ST-L1、ST-LLC、DR-L1 属于 Drained 或 Stalled 状态；FL-MB、FL-EX、FL-MO 属于 Flushed 状态。</li>
<li>纵轴为 Pearson 相关系数（Correlation），范围从 0 到 1，值越接近 1 表示事件计数与性能影响高度正相关。</li>
<li><strong>Flushed 类事件（FL-MB, FL-EX, FL-MO）表现出最强的相关性</strong>，中位数均高于 0.8，表明这些事件（如分支误预测、异常、内存序违规）一旦发生，几乎必然导致显著性能损失，且难以被隐藏。</li>
<li><strong>Stalled 类事件中，ST-LLC 相关性较高</strong>（中位数约 0.75），而 ST-L1 和 ST-TLB 相关性中等（中位数约 0.6–0.65），说明 LLC miss 更难被隐藏，L1 miss 和 TLB miss 则部分可被流水线隐藏。</li>
<li><strong>Drained 类事件中，DR-L1 相关性较高</strong>（中位数约 0.7），而 DR-TLB 和 DR-SQ 相关性较低（中位数约 0.5–0.6），尤其 DR-SQ（Store Queue stall）分布最广、离群值多，表明其对性能的影响高度依赖上下文，有时完全被隐藏，有时严重阻塞。</li>
<li>下表总结各事件的中位数相关系数：</li>
</ul>
<table>
<thead>
<tr>
<th>Event</th>
<th>Commit State</th>
<th>Median Correlation</th>
</tr>
</thead>
<tbody>
<tr>
<td>DR-SQ</td>
<td>Drained</td>
<td>~0.5</td>
</tr>
<tr>
<td>DR-TLB</td>
<td>Drained</td>
<td>~0.55</td>
</tr>
<tr>
<td>ST-TLB</td>
<td>Stalled</td>
<td>~0.6</td>
</tr>
<tr>
<td>ST-L1</td>
<td>Stalled</td>
<td>~0.6</td>
</tr>
<tr>
<td>ST-LLC</td>
<td>Stalled</td>
<td>~0.75</td>
</tr>
<tr>
<td>DR-L1</td>
<td>Drained</td>
<td>~0.7</td>
</tr>
<tr>
<td>FL-MB</td>
<td>Flushed</td>
<td>~0.85</td>
</tr>
<tr>
<td>FL-EX</td>
<td>Flushed</td>
<td>~0.9</td>
</tr>
<tr>
<td>FL-MO</td>
<td>Flushed</td>
<td>~0.85</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>该图揭示了传统基于 PMC 计数的性能分析的局限性</strong>：并非所有事件计数都能准确反映其对性能的实际贡献，尤其对于可被隐藏的事件（如 L1 cache miss、store queue stall），仅靠计数无法判断其是否真正造成性能瓶颈。</li>
<li>TEA 的价值在于它能直接测量每个指令在 commit 阶段暴露的延迟，并将其归因于具体的性能事件组合，从而避免了事件计数与性能影响之间弱相关性带来的误导。</li>
</ul>
<h3 id="figure-8-error-versus-sampling-frequency">Figure 8: Error versus sampling frequency.<a class="headerlink" href="#figure-8-error-versus-sampling-frequency" title="Permanent link">&para;</a></h3>
<p><img alt="074e3ead1c8a545d618fe0378066c902ba6a56e63f967b04c15bb9ee3e7974ca.jpg" src="../images/074e3ead1c8a545d618fe0378066c902ba6a56e63f967b04c15bb9ee3e7974ca.jpg" /></p>
<ul>
<li>图片展示了不同性能分析技术在不同采样频率下的误差表现，横轴为技术名称（IBS、SPE、RIS、NCI-TEA、TEA），纵轴为误差百分比，图例区分了四种采样频率：<strong>100 Hz</strong>、<strong>1 kHz</strong>、<strong>4 kHz</strong> 和 <strong>8 kHz</strong>。</li>
<li>从图中可见，<strong>IBS、SPE 和 RIS</strong> 的误差始终维持在较高水平（约 50%-80%），且随采样频率变化不明显，表明其误差主要源于非时间比例采样机制，而非采样稀疏性。</li>
<li><strong>NCI-TEA</strong> 在所有采样频率下均显著优于 IBS/SPE/RIS，误差范围约为 10%-20%，但其误差仍随采样频率增加而略有下降，说明采样频率对其精度有一定影响。</li>
<li><strong>TEA</strong> 表现出最佳的精度和稳定性，误差始终低于 5%，且在 4 kHz 及以上频率时误差稳定在约 2%-3%，进一步提升至 8 kHz 并未带来显著改善，表明 <strong>4 kHz 是兼顾精度与开销的最优采样频率</strong>。</li>
<li>下表总结各技术在不同采样频率下的典型误差范围：</li>
</ul>
<table>
<thead>
<tr>
<th>技术</th>
<th>100 Hz</th>
<th>1 kHz</th>
<th>4 kHz</th>
<th>8 kHz</th>
</tr>
</thead>
<tbody>
<tr>
<td>IBS</td>
<td>~70%-80%</td>
<td>~65%-75%</td>
<td>~60%-70%</td>
<td>~60%-70%</td>
</tr>
<tr>
<td>SPE</td>
<td>~70%-80%</td>
<td>~65%-75%</td>
<td>~60%-70%</td>
<td>~60%-70%</td>
</tr>
<tr>
<td>RIS</td>
<td>~70%-80%</td>
<td>~65%-75%</td>
<td>~60%-70%</td>
<td>~60%-70%</td>
</tr>
<tr>
<td>NCI-TEA</td>
<td>~20%-30%</td>
<td>~15%-25%</td>
<td>~10%-20%</td>
<td>~10%-15%</td>
</tr>
<tr>
<td>TEA</td>
<td>~5%-10%</td>
<td>~3%-7%</td>
<td><strong>~2%-3%</strong></td>
<td><strong>~2%-3%</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>结论：<strong>TEA 的高精度源于其时间比例采样机制，而非依赖高频采样；4 kHz 采样频率已足以实现接近理论极限的精度，继续提高频率收益甚微。</strong></li>
</ul>
<h3 id="figure-9-errors-at-instruction-and-function-granularity">Figure 9: Errors at instruction and function granularity.<a class="headerlink" href="#figure-9-errors-at-instruction-and-function-granularity" title="Permanent link">&para;</a></h3>
<p><img alt="396a415236da0707e322779ddba36a831b596008797f7b15b1b006a8abe35478.jpg" src="../images/396a415236da0707e322779ddba36a831b596008797f7b15b1b006a8abe35478.jpg" /></p>
<ul>
<li>图片展示了在不同分析粒度下，多种性能分析技术的误差分布情况，具体分为 <strong>(a) Instruction</strong>（指令级）和 <strong>(b) Function</strong>（函数级）两个子图。</li>
<li>误差以箱线图形式呈现，纵轴为 <strong>Error</strong>（误差百分比），横轴为不同技术：<strong>IBS</strong>、<strong>SPE</strong>、<strong>RIS</strong>、<strong>NCI-TEA</strong> 和 <strong>TEA</strong>。</li>
<li>在 <strong>Instruction 粒度</strong>（图 a）中：</li>
<li>IBS、SPE、RIS 的误差中位数均在 <strong>60% 左右</strong>，且分布范围广，最大误差接近 <strong>80%</strong>。</li>
<li>NCI-TEA 显著优于前三者，中位数误差降至约 <strong>20%</strong>。</li>
<li><strong>TEA 表现最优</strong>，中位数误差低于 <strong>5%</strong>，且分布极窄，最大误差不超过 <strong>10%</strong>。</li>
<li>在 <strong>Function 粒度</strong>（图 b）中：</li>
<li>所有技术的误差均有所下降，但相对排名不变。</li>
<li>IBS、SPE、RIS 中位数误差仍高于 <strong>40%</strong>。</li>
<li>NCI-TEA 中位数误差约为 <strong>15%</strong>。</li>
<li><strong>TEA 依旧最精准</strong>，中位数误差接近 <strong>0%</strong>，最大误差小于 <strong>5%</strong>。</li>
<li>误差数据对比表：</li>
</ul>
<table>
<thead>
<tr>
<th>技术</th>
<th>指令级中位数误差</th>
<th>函数级中位数误差</th>
</tr>
</thead>
<tbody>
<tr>
<td>IBS</td>
<td>~60%</td>
<td>~45%</td>
</tr>
<tr>
<td>SPE</td>
<td>~60%</td>
<td>~45%</td>
</tr>
<tr>
<td>RIS</td>
<td>~60%</td>
<td>~45%</td>
</tr>
<tr>
<td>NCI-TEA</td>
<td>~20%</td>
<td>~15%</td>
</tr>
<tr>
<td><strong>TEA</strong></td>
<td><strong>&lt;5%</strong></td>
<td><strong>~0%</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>结论：无论在指令级还是函数级，<strong>TEA 均显著优于其他方法</strong>，尤其在细粒度分析中优势更为突出，证明其时间比例采样机制能更准确归因性能开销。</li>
</ul>
<h3 id="figure-10-lbm-performance-analysis-tea-identifies-the-performance-critical-load-whereas-ibs-does-not">Figure 10: Lbm performance analysis. TEA identifies the performance-critical load whereas IBS does not.<a class="headerlink" href="#figure-10-lbm-performance-analysis-tea-identifies-the-performance-critical-load-whereas-ibs-does-not" title="Permanent link">&para;</a></h3>
<p><img alt="50b36abcc0e15b0bcf0e31550dedf365adaa5381173871518036b3c51c8f3213.jpg" src="../images/50b36abcc0e15b0bcf0e31550dedf365adaa5381173871518036b3c51c8f3213.jpg" /></p>
<ul>
<li>图片展示了 <strong>Figure 10</strong>，用于对比 <strong>TEA</strong> 与 <strong>IBS</strong> 在分析 SPEC CPU2017 基准程序 <strong>lbm</strong> 时的性能剖析结果，核心目标是揭示哪种工具能准确识别性能瓶颈指令。</li>
<li>图 (a) 为 <strong>TEA 生成的 PICS</strong>，图 (b) 为 <strong>IBS 生成的 PICS</strong>。两者均以条形图形式展示各指令在执行周期中的分布，横轴为周期数（Cycles），纵轴为指令及其操作码。</li>
<li><strong>TEA 的 PICS 显示</strong>：</li>
<li>最显著的性能瓶颈是 <code>lw t4,152(a0)</code> 指令，其贡献了约 <strong>692B 周期</strong>。</li>
<li>该指令的性能损失主要归因于 <strong>ST-LLC</strong>（L3 缓存未命中）和 <strong>ST-TLB</strong>（数据 TLB 未命中）事件组合，表明其负载延迟无法被隐藏。</li>
<li>其他指令如 <code>fld ft6,(a0)</code>、<code>andi t5,t4,1</code> 等贡献较小，且无显著性能事件标记。</li>
<li><strong>IBS 的 PICS 显示</strong>：</li>
<li>性能热点被错误地归因于多个浮点运算指令，如 <code>fmul.d fs9,fs5,fs8</code>、<code>fdiv.d fs1,fs5,fs5</code> 等。</li>
<li>这些指令在 IBS 下显示高周期消耗，但实际并非性能瓶颈，而是因为它们在前端被调度时，真正的瓶颈指令 <code>lw</code> 正处于 ROB 头部阻塞状态。</li>
<li>IBS 未能正确关联性能事件与真正导致停滞的指令，导致误导性结论。</li>
<li>两图对比凸显 <strong>TEA 的时间比例特性</strong>：它只在指令暴露延迟时采样（即 commit 阶段），从而准确归因性能损失；而 <strong>IBS 在 dispatch 阶段采样</strong>，捕获的是前端行为，而非实际影响执行时间的指令。</li>
<li>关键术语保留英文：<strong>PICS</strong>（Per-Instruction Cycle Stacks）、<strong>TEA</strong>（Time-Proportional Event Analysis）、<strong>IBS</strong>（Instruction-Based Sampling）、<strong>ST-LLC</strong>、<strong>ST-TLB</strong>。</li>
<li>数据对比表：</li>
</ul>
<table>
<thead>
<tr>
<th>工具</th>
<th>主要性能瓶颈指令</th>
<th>主要性能事件</th>
<th>周期贡献</th>
<th>准确性</th>
</tr>
</thead>
<tbody>
<tr>
<td>TEA</td>
<td><code>lw t4,152(a0)</code></td>
<td>ST-LLC, ST-TLB</td>
<td>~692B</td>
<td>高</td>
</tr>
<tr>
<td>IBS</td>
<td><code>fmul.d fs9,fs5,fs8</code> 等</td>
<td>无明确事件</td>
<td>&gt;100B</td>
<td>低</td>
</tr>
</tbody>
</table>
<ul>
<li>结论：<strong>TEA 能精准定位 lbm 中的性能关键负载指令及其根本原因（LLC 和 TLB 未命中）</strong>，而 <strong>IBS 因非时间比例采样机制产生误导性结果</strong>，无法有效指导优化。</li>
</ul>
<h3 id="figure-11-pics-and-speedup-for-the-most-performancecritical-load-instruction-and-store-instruction-of-lbm-across-a-range-of-prefetch-distances">Figure 11: PICS and speedup for the most performancecritical load instruction and store instruction of lbm across a range of prefetch distances.<a class="headerlink" href="#figure-11-pics-and-speedup-for-the-most-performancecritical-load-instruction-and-store-instruction-of-lbm-across-a-range-of-prefetch-distances" title="Permanent link">&para;</a></h3>
<p><img alt="c4ca84660f92475b1db286e5ae08452e74da6b059e6de62847c4f12241ac6ac4.jpg" src="../images/c4ca84660f92475b1db286e5ae08452e74da6b059e6de62847c4f12241ac6ac4.jpg" /></p>
<ul>
<li>图片展示了在不同预取距离（Prefetch Distance, Pf 1 至 Pf 8）下，lbm 基准程序中最关键的 load 和 store 指令的 <strong>Per-Instruction Cycle Stacks (PICS)</strong> 及其对应的 <strong>Speedup</strong>。</li>
<li>左侧 Y 轴为 <strong>Cycles</strong>，右侧 Y 轴为 <strong>Speedup</strong>，X 轴为预取距离配置，从原始版本（Orig.）到 Pf 8。</li>
<li>图中柱状图表示各事件类别对执行周期的贡献，颜色对应不同性能事件：</li>
<li><strong>base</strong>: 无性能事件的基础执行周期。</li>
<li><strong>others</strong>: 其他未分类事件。</li>
<li><strong>ST-TLB</strong>: 数据 TLB 缺失导致的停滞。</li>
<li><strong>ST-TLB,DR-SQ</strong>: TLB 缺失与存储队列满的组合事件。</li>
<li><strong>DR-SQ</strong>: 存储队列满导致的前端排空。</li>
<li><strong>ST-L1</strong>: L1 数据缓存缺失。</li>
<li><strong>ST-LLC</strong>: LLC 缓存缺失。</li>
<li>红色折线表示相对于原始版本的 <strong>Speedup</strong>，随预取距离增加先上升后下降，在 Pf 4 达到峰值约 <strong>1.28×</strong>。</li>
<li>在原始版本中，load 指令（ld）主导周期消耗，主要归因于 <strong>ST-LLC</strong>（562B cycles），表明其工作集超出 LLC 容量。</li>
<li>随着预取距离增加，<strong>ST-LLC</strong> 周期显著减少，<strong>ST-L1</strong> 周期上升，说明预取成功将部分 LLC 缺失转化为 L1 命中。</li>
<li>当预取距离超过 4（如 Pf 5–8），<strong>DR-SQ</strong> 和 <strong>ST-TLB,DR-SQ</strong> 周期开始增长，表明预取引入了存储带宽瓶颈。</li>
<li>下表总结关键数据点：</li>
</ul>
<table>
<thead>
<tr>
<th>配置</th>
<th>Load 指令总周期</th>
<th>Store 指令总周期</th>
<th>Speedup</th>
</tr>
</thead>
<tbody>
<tr>
<td>Orig.</td>
<td>692B</td>
<td>—</td>
<td>1.00</td>
</tr>
<tr>
<td>Pf 4</td>
<td>~50B (ST-L1为主)</td>
<td>显著增加</td>
<td><strong>1.28×</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>TEA 的 PICS 清晰揭示了性能瓶颈从 <strong>load latency</strong> 向 <strong>store bandwidth</strong> 的转移，指导开发者选择最优预取距离（Pf 3 或 Pf 4）以平衡两者。</li>
</ul>
<h3 id="figure-12-nab-performance-analysis-tea-identifies-that-the-fsqrtd-instruction-issues-too-late-to-hide-its-execution-latency">Figure 12: Nab performance analysis. TEA identifies that the fsqrt.d instruction issues too late to hide its execution latency.<a class="headerlink" href="#figure-12-nab-performance-analysis-tea-identifies-that-the-fsqrtd-instruction-issues-too-late-to-hide-its-execution-latency" title="Permanent link">&para;</a></h3>
<p><img alt="042927ffd0d0b8be2bb53eb699b6a93e40cb57d7250c799516a7e60e73eb931e.jpg" src="../images/042927ffd0d0b8be2bb53eb699b6a93e40cb57d7250c799516a7e60e73eb931e.jpg" /></p>
<ul>
<li>图片展示了在分析 SPEC CPU2017 基准测试程序 <strong>nab</strong> 时，<strong>TEA</strong> 与 <strong>IBS</strong> 生成的 Per-Instruction Cycle Stacks（PICS）对比，旨在说明 TEA 如何准确识别性能瓶颈。</li>
<li>左侧子图 (a) 为 <strong>TEA 生成的 PICS</strong>，右侧子图 (b) 为 <strong>IBS 生成的 PICS</strong>。两者均聚焦于包含关键指令 <code>fsqrt.d</code> 的代码区域。</li>
<li>两图中横轴均为 <strong>Cycles</strong>（周期数），纵轴列出各静态指令，包括 <code>fmv.d.x</code>, <code>frflags</code>, <code>flt.d</code>, <code>beqz</code>, <code>j</code>, <code>fsqrt.d</code>, <code>slli</code> 等。</li>
<li>图例显示两种分类：<strong>Flushing instruction</strong>（紫色）和 <strong>base</strong>（黑色）。前者指导致流水线冲刷的指令，后者指无性能事件影响的正常执行。</li>
<li>在 TEA 的 PICS 中，<strong><code>fsqrt.d</code> 指令</strong>占据最长条形，其大部分周期归因于 <strong>base</strong> 类别，表明该指令本身未遭遇缓存缺失或 TLB 缺失等事件，但因其执行延迟未被隐藏而成为性能瓶颈。</li>
<li>TEA 同时指出，<strong><code>frflags</code> 和 <code>flt.d</code></strong> 等前序指令属于 <strong>Flushing instruction</strong>，它们触发了流水线冲刷，导致 <code>fsqrt.d</code> 被延迟发射，从而无法隐藏其长执行延迟。</li>
<li>相比之下，IBS 生成的 PICS 显示 <strong><code>fsqrt.d</code> 的周期贡献被严重低估</strong>，且其主要周期被错误归因于 <strong>Flushing instruction</strong> 类别，这与其实际行为不符。</li>
<li>IBS 的误差源于其在 <strong>dispatch 阶段标记指令</strong>，而非在 commit 阶段采样。因此，它捕获的是在 <code>fsqrt.d</code> 被阻塞期间调度的指令，而非真正造成性能损失的指令。</li>
<li>下表总结了关键指令在 TEA 与 IBS 中的周期归类差异：</li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>TEA 归类</th>
<th>IBS 归类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fsqrt.d</code></td>
<td>主要为 <strong>base</strong></td>
<td>主要为 <strong>Flushing</strong></td>
<td>TEA 正确反映其无事件但延迟未被隐藏</td>
</tr>
<tr>
<td><code>frflags</code></td>
<td><strong>Flushing</strong></td>
<td><strong>Flushing</strong></td>
<td>两者均正确识别其冲刷行为</td>
</tr>
<tr>
<td><code>flt.d</code></td>
<td><strong>Flushing</strong></td>
<td><strong>Flushing</strong></td>
<td>两者均正确识别其冲刷行为</td>
</tr>
<tr>
<td><code>beqz</code></td>
<td><strong>Flushing</strong></td>
<td><strong>Flushing</strong></td>
<td>两者均正确识别其冲刷行为</td>
</tr>
</tbody>
</table>
<ul>
<li>该图直观证明了 <strong>TEA 的时间比例性</strong>使其能准确归因性能损失，而 IBS 因非时间比例性导致对关键指令 <code>fsqrt.d</code> 的性能影响评估出现重大偏差。</li>
<li>最终结论：<strong>TEA 能揭示 <code>fsqrt.d</code> 性能问题的根本原因——前序指令引发的流水线冲刷导致其发射过晚</strong>，而 IBS 无法提供此洞察，凸显了 TEA 在性能分析中的优越性。</li>
</ul>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.sections", "navigation.top", "navigation.indexes", "search.suggest", "search.highlight", "content.code.copy"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../../../javascripts/switcher.js"></script>
      
    
  </body>
</html>