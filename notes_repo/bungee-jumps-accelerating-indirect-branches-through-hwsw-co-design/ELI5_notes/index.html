
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://example.com/notes_repo/bungee-jumps-accelerating-indirect-branches-through-hwsw-co-design/ELI5_notes/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Bungee Jumps: Accelerating Indirect Branches Through HW/SW Co-Design 通俗讲解 - BlaBlaCut</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#bungee-jumps-accelerating-indirect-branches-through-hwsw-co-design" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="BlaBlaCut" class="md-header__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            BlaBlaCut
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Bungee Jumps: Accelerating Indirect Branches Through HW/SW Co-Design 通俗讲解
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到深色模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换到深色模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到浅色模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换到浅色模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="BlaBlaCut" class="md-nav__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    BlaBlaCut
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/Recent/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Recent
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/awesome-data-prefetchers/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Awesome Data Prefetchers
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/micro-2025/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    MICRO 2025
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/dyn-lang-acc/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Dynamic Language Acceleration
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#0" class="md-nav__link">
    <span class="md-ellipsis">
      
        0. 整体创新点通俗解读
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1-bungee-jump-transformation" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. Bungee Jump Transformation
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-decomposed-branch-buffer-dbb" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. Decomposed Branch Buffer (DBB)
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-landing-pad-with-marker-instructions" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. Landing Pad with Marker Instructions
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-speculative-execution-with-fault-suppression" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. Speculative Execution with Fault Suppression
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-profile-guided-transformation-selection" class="md-nav__link">
    <span class="md-ellipsis">
      
        5. Profile-Guided Transformation Selection
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="bungee-jumps-accelerating-indirect-branches-through-hwsw-co-design">Bungee Jumps: Accelerating Indirect Branches Through HW/SW Co-Design 通俗讲解<a class="headerlink" href="#bungee-jumps-accelerating-indirect-branches-through-hwsw-co-design" title="Permanent link">&para;</a></h1>
<h3 id="0">0. 整体创新点通俗解读<a class="headerlink" href="#0" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击 (The "Why")</strong></p>
<ul>
<li>传统的 <strong>in-order (IO) 处理器</strong>在处理 <strong>indirect branch</strong>（间接跳转）时非常痛苦。虽然现代的 <strong>branch predictor</strong>（分支预测器）已经能非常准确地预测出跳转目标（如 Figure 1 和 Figure 2 所示，<strong>predictability</strong> 远高于 <strong>bias</strong>），但 IO 处理器依然会卡住。</li>
<li>为什么？因为在现有 ISA 下，<strong>预测点</strong>和<strong>执行/解析点</strong>是同一个 <code>jmp</code> 指令。IO 处理器必须等整个“计算跳转地址的依赖链”（比如 <code>load -&gt; load -&gt; add -&gt; jmp</code>）完全执行完，才能知道去哪取下一条指令。这个过程会产生大量 <strong>stall cycles</strong>（停顿周期）。</li>
<li>相比之下，<strong>out-of-order (OOO) 处理器</strong>没这个问题，因为它可以一边算跳转地址，一边根据预测结果提前把目标代码取进来并执行（如 Figure 3(a) 所示）。IO 处理器眼巴巴看着 OOO “吃肉”，自己却只能“喝汤”。</li>
</ul>
<p><strong>通俗比方 (The Analogy)</strong></p>
<ul>
<li>想象你要寄一个包裹（执行跳转后的代码），但包裹的地址写在一个保险箱里（需要一系列计算才能得到）。</li>
<li><strong>传统 IO 做法</strong>：你必须先打开保险箱（完成所有计算），拿到地址，然后才能去邮局寄包裹。这段时间你啥也干不了，干等着。</li>
<li><strong>OOO 做法</strong>：你有个超准的预言家（branch predictor），他猜出地址很可能是“A市”。于是你一边让助手去开保险箱，一边自己先跑去邮局，按“A市”的地址把包裹寄了。如果预言家猜对了，你就省了大把时间；猜错了，大不了把寄错的追回来重寄。</li>
<li><strong>这篇论文的核心思想</strong>：既然我们已经有了一个很准的预言家，那能不能给 IO 处理器也设计一套“先寄后验”的流程？答案就是，把“预言”和“验证”拆成两个独立的动作。</li>
</ul>
<p><strong>关键一招 (The "How")</strong></p>
<ul>
<li>作者没有去改进预测器本身，而是对 <strong>ISA</strong>（指令集架构）做了个精巧的手术，引入了两条新指令：<ul>
<li><strong><code>predict-indir-jmp</code></strong>: 这是一个纯粹的“预言”指令。它只在 <strong>frontend</strong>（取指前端）起作用，告诉处理器：“嘿，我猜我们要跳到 XXX 地址，你先去那儿取指令吧！” 这条指令本身不进入执行流水线。</li>
<li><strong><code>resolve</code></strong>: 这是一个“验证”指令，被放置在每个可能的跳转目标代码块的开头。它的作用是检查：实际计算出来的跳转地址，是否和之前 <code>predict-indir-jmp</code> 预测的一致。如果一致，万事大吉；如果不一致，就跳转到 <strong>recovery code</strong>（恢复代码）去修正错误。</li>
</ul>
</li>
<li>通过这个拆分，编译器（code generator）就可以大胆地将原本阻塞在跳转指令之后的、计算跳转地址的那部分代码（the indirect branch computation chain），<strong>co-mingle</strong>（混合调度）到各个预测的目标代码块中去执行（如 Figure 3(b) 和 Figure 7 所示）。</li>
<li>这样一来，IO 处理器就能模仿 OOO 的行为：在等待最终地址确认的同时，已经开始执行预测路径上的有用工作，从而<strong>完全隐藏了间接跳转的计算延迟</strong>。为了保证这种推测执行的安全性，论文还配套使用了 <strong>fault-suppressed instructions</strong>（抑制异常的指令）和 <strong>temporary registers</strong>（临时寄存器）来处理可能的异常和状态回滚。整个方案的硬件开销也很小，主要增加了一个叫 <strong>Decomposed Branch Buffer (DBB)</strong> 的小结构来关联 <code>predict</code> 和 <code>resolve</code> 指令。</li>
</ul>
<h3 id="1-bungee-jump-transformation">1. Bungee Jump Transformation<a class="headerlink" href="#1-bungee-jump-transformation" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击 (The "Why")</strong></p>
<ul>
<li>传统 <strong>in-order (IO) 处理器</strong> 面对间接分支（indirect branch）时，有一个致命的“卡脖子”问题：计算跳转目标地址的指令链（比如 <code>load -&gt; add -&gt; jmp reg</code>）必须在跳转发生前<strong>完全执行完</strong>。</li>
<li>这导致了一个长长的<strong>关键路径</strong>，后面的指令只能干等着，造成大量 <strong>issue stalls</strong>。</li>
<li>而 <strong>out-of-order (OOO) 处理器</strong> 则没这个问题。它靠强大的动态调度器，一旦预测了跳转目标，就立刻开始执行目标地址的代码，同时在后台慢慢算那个跳转地址。两者并行不悖，效率极高。</li>
<li>对 IO 处理器来说，即使现代分支预测器已经能<strong>非常准确地预测</strong>间接分支（如论文图2所示，预测准确率远高于分支偏置度），这种<strong>编译时的控制依赖</strong>依然锁死了指令调度，让它无法享受到预测准确带来的红利。之前的解决方案，如 <strong>RCPO</strong> 或 <strong>predication</strong>，要么只适用于目标很少的分支，要么会爆炸式地增加指令数和关键路径长度，得不偿失。</li>
</ul>
<p><strong>通俗比方 (The Analogy)</strong></p>
<ul>
<li>想象你要从A点开车去一个未知的目的地B、C或D。你有一个非常准的导航（<strong>branch predictor</strong>），它在你刚出发时就告诉你：“95%概率是去B”。</li>
<li><strong>传统IO处理器的做法</strong>：你必须先把车开到一个叫“地址计算中心”的地方，查清楚确切地址（比如通过查户口本 <code>load</code> 再拼门牌号 <code>add</code>），拿到纸质地址条后，才能根据地址条开车去B/C/D。即使导航早就告诉你是B，你也得先绕路去拿那张纸，浪费时间。</li>
<li><strong>OOO处理器的做法</strong>：它信任导航，一出A点就直接往B开，同时派个无人机（<strong>动态调度器</strong>）去“地址计算中心”拿地址条。等你快到B时，无人机也把地址条送到了，一对比，果然是B，完美。</li>
<li><strong>Bungee Jump Transformation 的做法</strong>：它给你的车加了个新功能。你在A点出发时，先按一下“<strong>predict-indir-jmp</strong>”按钮，告诉车载系统“我相信导航，现在就按它说的去B”。然后，你<strong>一边开车去B，一边在路上完成查户口本和拼门牌号的动作</strong>。当你到达B点门口时，再按一下“<strong>resolve</strong>”按钮，核对一下你刚在路上算出来的地址和B点的门牌是否一致。如果一致，万事大吉；如果不一致（预测错了），你就立刻掉头去正确的地方，并且路上算的那些东西作废。</li>
</ul>
<p><img alt="" src="../images/9fc418e5f94a16a353d933e01c95988a5207a65612cad36987695cf2e1edcd9e.jpg" />
<img alt="" src="../images/bd6ef8edd19d01a0a9b8a6677504e0b00ca4103dc77f6a3e9dd4c44f1eedc903.jpg" /> <em>Figure 3: The indirect branch computation chain (highlighted) is a source of stall cycles for the In-Order; the Out-of-Order overlaps the chain with instructions from the target B. Our transformation enables the In-Order to mimic the schedule found by the OOO.</em></p>
<p><strong>关键一招 (The "How")</strong></p>
<ul>
<li>作者并没有试图去改进预测器本身，而是巧妙地<strong>重构了间接分支的语义</strong>，把它从一个原子操作拆成了两个独立的指令。</li>
<li><strong>第一步：分离预测与解析</strong>。引入一个新的 <strong><code>predict-indir-jmp</code></strong> 指令，它<strong>只负责通知前端取指单元</strong>（fetch unit）“请根据预测器的结果，开始从预测的目标地址取指”。这个指令本身不参与后续的流水线执行。</li>
<li><strong>第二步：交织计算与执行</strong>。原本在跳转前必须完成的“地址计算链”，现在被<strong>推送到各个可能的分支目标块内部</strong>。这样，在预测路径上，处理器可以<strong>并行地</strong>执行两件事：1) 完成剩余的地址计算；2) 执行预测目标的有用工作。</li>
<li><strong>第三步：延迟验证</strong>。在每个分支目标块的开头，放置一个 <strong><code>resolve</code></strong> 指令。它会检查刚刚计算出的实际跳转地址是否和当前所在的目标块匹配。如果不匹配，就跳转到<strong>恢复代码</strong>（recovery code），回滚状态并重新定向到正确的路径。</li>
<li><strong>第四步：硬件协同</strong>。为了支持这套机制，硬件需要一个小巧的 <strong>Decomposed Branch Buffer </strong>(DBB)，用来将前端的 <code>predict</code> 指令和后端的 <code>resolve</code> 指令关联起来，确保预测器能得到正确的训练反馈。此外，还需要支持<strong>投机执行中的故障抑制</strong>（fault suppression），因为 <code>predict</code> 和 <code>resolve</code> 之间的代码都是推测执行的。</li>
</ul>
<p><img alt="" src="../images/2278920402bf9f0b9a6850fa7def1cbd073166ee6870b880246a2da3890f1afc.jpg" /> <em>(a) Indirect Branch to be overlapped highlighted: branch bias shown on arcs</em>
<img alt="" src="../images/cf3a20d7ef553f2a29fd121ebf2fb530f18e3210fa2848f338faeb325888eee8.jpg" />
<img alt="" src="../images/91baa461e56916cdb3800d4a55ebb30bd80a7caf68bfe8bff56604fdeadb6d3b.jpg" /> <em>Figure 7: Transformation</em></p>
<h3 id="2-decomposed-branch-buffer-dbb">2. Decomposed Branch Buffer (DBB)<a class="headerlink" href="#2-decomposed-branch-buffer-dbb" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击 (The "Why")</strong></p>
<ul>
<li>传统处理器里，一个 <strong>indirect branch</strong>（间接跳转）指令身兼二职：它既是前端 <strong>预测</strong> 的起点（“我们要跳去哪？”），又是后端 <strong>解析/执行</strong> 的终点（“我们到底算出来要跳去哪？”）。这两个动作在同一个指令上完成，天经地义。</li>
<li>但对于 <strong>In-Order (IO) 处理器</strong> 来说，这就成了枷锁。因为 IO 处理器无法像 Out-of-Order (OOO) 那样动态地把跳转目标的代码和计算跳转地址的代码重叠执行。IO 必须老老实实地等跳转地址算完，才能去取下一条指令，这中间就产生了 <strong>stall cycles</strong>（停顿周期）。</li>
<li>论文提出的解决方案很聪明：把一个跳转指令拆成两个——一个 <strong>predict-indir-jmp</strong>（只负责告诉前端“我猜我们要去这里”）和一个 <strong>resolve</strong>（在目标代码里，负责检查“我们猜得对不对”）。这样，IO 就能提前开始取目标代码，把计算地址的延迟给“藏”起来。</li>
<li><strong>但是，拆开之后就乱套了！</strong> 分支预测器怎么知道是哪个 <code>predict</code> 指令猜错了？它需要把 <code>resolve</code> 指令反馈的“正确答案”关联到当初发出预测的那个 <code>predict</code> 指令上，才能正确地更新自己的预测表。如果关联错了，预测器就会越学越笨。</li>
</ul>
<p><strong>通俗比方 (The Analogy)</strong></p>
<ul>
<li>想象一个餐厅的点餐系统。以前是一个服务员（传统branch指令）既负责记下客人的点单（预测），又负责把做好的菜端给客人（解析）。</li>
<li>现在为了提高效率，老板把工作拆了：一个 <strong>接单员</strong>（<code>predict</code>）专门在门口快速记录客人的需求并传给厨房；另一个 <strong>上菜员</strong>（<code>resolve</code>）在厨房做好菜后，负责核对订单再上菜。</li>
<li><strong>问题来了</strong>：如果上菜时发现做错了（misprediction），厨房主管（分支预测器）怎么知道是哪个接单员记错了单子？他们之间没有直接联系！</li>
<li><strong>DBB 就是那个“订单号”系统</strong>。每当接单员记下一个新订单，他都会生成一个唯一的 <strong>订单号</strong>（DBB entry）并把它贴在订单上，同时自己也留一份底单（写入DBB FIFO）。当上菜员拿着菜来核对时，他必须报出这个订单号。主管根据订单号，就能精准地找到是哪个接单员、在哪一桌犯了错，并针对性地进行培训（更新预测器）。</li>
</ul>
<p><strong>关键一招 (The "How")</strong></p>
<ul>
<li>作者并没有设计一套复杂的全局追踪机制，而是巧妙地利用了 <strong>IO 处理器指令按序发射</strong> 这一特性，引入了一个极简的硬件结构：<strong>Decomposed Branch Buffer (DBB)</strong>。</li>
<li>DBB 本质上就是一个小型的 <strong>FIFO circular buffer</strong>（先进先出环形缓冲区）。</li>
<li>具体流程如下：<ul>
<li>当前端 <strong>fetch</strong> 到一个 <code>predict-indir-jmp</code> 指令时：<ul>
<li>它会像往常一样查询 <strong>branch predictor</strong> 得到一个预测目标。</li>
<li>然后，它会将这次预测所需的所有 <strong>metadata</strong>（比如预测器表项的索引、预测的目标地址等）打包，作为一个新条目 <strong>push</strong> 进 DBB 的尾部。</li>
<li>这个 <code>predict</code> 指令本身在完成其“指引前端取指”的使命后，就被丢弃，不再进入后端流水线。</li>
</ul>
</li>
<li>当后续的 <code>resolve</code> 指令被 <strong>fetch</strong> 时：<ul>
<li>由于指令是按序处理的，这个 <code>resolve</code> 必然对应于 DBB <strong>尾部</strong>（或者说头部，取决于实现视角）的那个最新 <code>predict</code> 条目。</li>
<li>硬件会从 DBB 中 <strong>pop</strong> 出这个条目，并将其 <strong>index/metadata</strong> 打包进 <code>resolve</code> 指令的内部，让它带着这个“订单号”一起流经后端。</li>
</ul>
</li>
<li>当 <code>resolve</code> 指令在后端 <strong>执行</strong> 时：<ul>
<li>如果发现预测错误，它会带着这个“订单号”发起 <strong>resteer</strong>（重定向）。</li>
<li>前端收到重定向信号后，利用这个“订单号”从 DBB 中找回当初的预测信息，从而能够 <strong>精准地更新</strong> 分支预测器的状态。
    <img alt="" src="../images/22088a1874d703377a20a1910cb4de03af04c04cdc8001b474bf5ad6ab8b217c.jpg" /> <em>(b) Insert tail pointer index into corresponding resolution instruction.</em>
    <img alt="" src="../images/4f4a4d3c1e22a0fb82b039524c9c73ccd6bb50f992dc39893b4a4c9839052a65.jpg" /> <em>Figure 8: The Decomposed Branch Buffer and its operations.The area shaded in grey denotes existing HW structures and data/control paths.</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-landing-pad-with-marker-instructions">3. Landing Pad with Marker Instructions<a class="headerlink" href="#3-landing-pad-with-marker-instructions" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击</strong></p>
<ul>
<li>传统的间接分支处理，预测和跳转是同一个指令。在作者提出的“Bungee Jumps”新方法里，他们把这两件事拆开了：一个 <strong>predict-indir-jmp</strong> 指令只负责告诉前端“去哪取指”，而真正的跳转验证则被推迟到目标代码块里的一个 <strong>resolve</strong> 指令。</li>
<li>这个拆分带来了一个致命问题：如果 <strong>predict-indir-jmp</strong> 指令被一个糟糕的预测器误导，或者因为 BTB（Branch Target Buffer）冲突，它可能会指向一个<strong>完全无效的地址</strong>。这个地址上根本没有 <strong>resolve</strong> 指令！</li>
<li>结果就是，处理器会一头扎进错误的代码里执行，既无法验证预测是否正确，也无法触发恢复机制回到正确的路径。整个系统就崩溃了。这就像你让一个信使去一个地址送信，但他走错了地方，那个地方根本没人能签收，信也就永远送不到了。</li>
</ul>
<p><strong>通俗比方</strong></p>
<ul>
<li>这个 <strong>Landing Pad with Marker Instructions</strong> 的设计，就像是给每一个合法的“降落点”（即间接分支的有效目标）都安装了一个独一无二的 <strong>电子门禁卡</strong>。</li>
<li>那个 <strong>predict-indir-jmp</strong> 指令在出发前，会从自己的口袋里掏出一张写着特定ID（即8位立即数）的 <strong>通行证</strong>。</li>
<li>当处理器前端根据预测跳转到目标地址后，它做的第一件事不是执行业务逻辑，而是检查门口（目标地址的第一条指令，即 <strong>marker instruction</strong>）的门禁卡ID。</li>
<li>只有当门口的ID和信使手里的通行证ID <strong>完全匹配</strong> 时，才说明降落在了正确的、受保护的区域，可以安全地继续执行。</li>
<li>如果ID对不上，或者门口根本没有门禁卡（即没有marker指令），那就说明降落在了“野外”，必须立刻启动应急预案——回退到一个已知的安全位置（即 <strong>predict</strong> 指令后面的顺序地址），那里有一套完整的、能算出正确地址的“导航系统”（即原始的间接分支计算链）。</li>
</ul>
<p><img alt="" src="../images/fbe49e849b1578c5ed7f43fc60d97d231fda30a0641dba2e4720a51bc7ec742b.jpg" /> <em>Figure 11: A naive implementation of predict and resolve. Figure 12: (1) Invalid target address predicted and no resolve present; unable to resteer to the correct path (2) marker “landing pad” introduced to ensure a valid indirect branch target is fetched (3)placement indirect branch computation chain in the shadow of the predict allows us to resteer to correct path as shown in (4).</em></p>
<p><strong>关键一招</strong></p>
<ul>
<li>作者并没有依赖复杂的硬件来验证目标地址的有效性，而是巧妙地在软件层面引入了一种轻量级的 <strong>握手协议</strong>。</li>
<li>具体来说，他们在编译/动态翻译阶段做了两件事：<ul>
<li>在 <strong>predict-indir-jmp</strong> 指令中嵌入一个唯一的 <strong>8-bit marker ID</strong>。</li>
<li>在每一个该间接分支的合法目标块的开头，插入一条特殊的 <strong>marker instruction</strong>，这条指令也包含同样的 <strong>8-bit marker ID</strong>。</li>
</ul>
</li>
<li>硬件前端在取指阶段增加了一个简单的检查逻辑：一旦执行了 <strong>predict-indir-jmp</strong>，下一次取指的目标地址处的第一条指令<strong>必须</strong>是一条 <strong>marker instruction</strong>，并且其ID必须与 <strong>predict</strong> 指令中的ID一致。</li>
<li>如果检查失败（ID不匹配或不是marker指令），硬件就会忽略这次预测，转而从 <strong>predict</strong> 指令的下一条顺序地址开始取指。这个顺序地址处，保留了完整的、未经优化的间接分支计算代码（<code>ld r9; jmp r9</code>），它能保证最终一定能找到并跳转到正确的路径。</li>
<li>这一招的核心在于，它用极小的硬件开销（一个8位比较器）和微小的代码膨胀（每个目标块加一条指令），就完美地解决了因预测目标无效而导致的系统可靠性问题，为整个“预测-解析分离”的大胆构想提供了坚实的安全网。</li>
</ul>
<h3 id="4-speculative-execution-with-fault-suppression">4. Speculative Execution with Fault Suppression<a class="headerlink" href="#4-speculative-execution-with-fault-suppression" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击 (The "Why")</strong></p>
<ul>
<li>传统的 <strong>speculative execution</strong>（推测执行）在遇到可能出错的指令（比如访存越界、除零等）时会很“难受”。因为一旦在错误的路径上触发了异常（fault），处理器就必须立刻处理它，这会破坏整个推测执行的逻辑。</li>
<li>对于 <strong>in-order processor</strong>（顺序处理器）来说，这个问题更严重。因为它不像 <strong>out-of-order</strong>（乱序）处理器那样有复杂的 <strong>reorder buffer</strong> 来轻松回滚状态。如果在推测路径上贸然执行了可能出错的指令，一旦预测错误，恢复正确的 <strong>architected state</strong>（架构状态）会非常麻烦，甚至可能导致 <strong>memory corruption</strong>（内存损坏）。</li>
<li>因此，之前的方案要么不敢在推测路径上放太多代码，限制了性能提升；要么需要极其复杂的硬件来支持完整的事务性回滚，成本太高。</li>
</ul>
<p><strong>通俗比方 (The Analogy)</strong></p>
<ul>
<li>想象你是一个谨慎的图书管理员（处理器），需要根据一张模糊的借书单（predict 指令）去书架上找书。你相信这张单子大概率是对的，所以你提前把可能要用到的几本书（推测路径上的指令）都拿了出来，并开始做些准备工作，比如撕掉旧的借阅标签（计算）。</li>
<li>但是，在你完全确认借书单正确之前（resolve 指令），你绝不会真的把新标签贴上去（提交写操作），也绝不会把任何可能损坏书籍的操作（比如用剪刀裁剪——对应 faulting instruction）付诸实践。</li>
<li>相反，你会先用铅笔轻轻做个记号（<strong>non-faulting instructions</strong>），并记下“如果这张单子是对的，我就在这里剪”。只有当你最终核对完借书单，确认无误后（resolve 成功），你才会拿出剪刀和胶水，正式完成所有操作。如果发现单子错了，你只需要擦掉铅笔印（丢弃推测结果），一切完好如初。</li>
</ul>
<p><strong>关键一招 (The "How")</strong>
作者并没有引入一套全新的、昂贵的硬件事务内存系统，而是巧妙地在软件和硬件之间做了一个轻量级的协同设计：</p>
<ul>
<li><strong>将推测区域内的危险操作“钝化”</strong>：在 <code>predict-indir-jmp</code> 和 <code>resolve</code> 之间的所有可能触发异常的指令（如 load/store），都被编译器替换成了它们的 <strong>non-faulting</strong> 版本（文中用 <code>+</code> 后缀表示，如 <code>load+</code>）。这些指令在执行时，如果遇到异常情况（如 page fault），不会立即抛出，而是将异常信息 <strong>suppress</strong>（抑制）并 <strong>accumulate</strong>（累积）在一个内部标志位里。</li>
<li><strong>集中检查与处理</strong>：在每个推测路径的末尾（紧邻 <code>resolve</code> 指令），插入一个 <code>check-fault</code> 指令。这个指令的作用就是检查刚才累积的异常标志。<ul>
<li>如果 <code>resolve</code> 指令确认路径正确 <strong>并且</strong> <code>check-fault</code> 发现没有异常，那么万事大吉，推测执行成功。</li>
<li>如果 <code>resolve</code> 指令发现预测错误 <strong>或者</strong> <code>check-fault</code> 发现了异常，控制流就会跳转到 <strong>recovery code</strong>（恢复代码）。</li>
</ul>
</li>
<li><strong>安全的恢复机制</strong>：恢复代码会禁用 fault suppression，然后重新执行正确的路径。在这个正确的路径上，所有的指令都是普通的、会正常触发异常的版本，从而保证了程序语义的正确性。同时，所有 <strong>store</strong> 操作都被严格安排在 <code>resolve</code> 和 <code>check-fault</code> <strong>之后</strong>，从根本上杜绝了在错误路径上污染内存的可能性。</li>
</ul>
<p><img alt="" src="../images/2278920402bf9f0b9a6850fa7def1cbd073166ee6870b880246a2da3890f1afc.jpg" /> <em>(a) Indirect Branch to be overlapped highlighted: branch bias shown on arcs</em>
<img alt="" src="../images/cf3a20d7ef553f2a29fd121ebf2fb530f18e3210fa2848f338faeb325888eee8.jpg" />
<img alt="" src="../images/91baa461e56916cdb3800d4a55ebb30bd80a7caf68bfe8bff56604fdeadb6d3b.jpg" /> <em>Figure 7: Transformation</em></p>
<p>这种设计的核心在于，它用一种非常经济的方式（只需要硬件支持 non-faulting 指令和一个 fault 标志位）就解决了推测执行中最棘手的异常处理问题，使得 in-order 处理器也能安全、高效地执行大块的推测代码，从而逼近 out-of-order 处理器的调度效果。</p>
<h3 id="5-profile-guided-transformation-selection">5. Profile-Guided Transformation Selection<a class="headerlink" href="#5-profile-guided-transformation-selection" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击</strong></p>
<ul>
<li>传统上，编译器面对间接分支（indirect branch）时很“难受”，因为它不知道该往哪跳。为了处理它，要么用 <strong>RCPO</strong>（Receiver Class Predication Optimization）把它展开成一长串 if-else，要么用 <strong>predication</strong> 把所有路径都算一遍再选结果。</li>
<li>这两种方法在<strong>静态偏置</strong>（static bias）高的时候很有效，比如 90% 的情况都跳到同一个地方。但问题在于，很多现代程序（尤其是 Python、PHP 这类动态语言）里的间接分支是 <strong>unbiased</strong>（各目标概率差不多），但却是 <strong>highly predictable</strong>（硬件预测器能猜得很准）。</li>
<li>如果强行对这些分支做 RCPO 或 predication，会带来灾难性的后果：<ul>
<li><strong>代码膨胀</strong>：一个有 8 个目标的 switch 语句会展开成 8 条路径，指令数暴增。</li>
<li><strong>关键路径变长</strong>：计算所有谓词（predicates）本身就成了瓶颈。</li>
<li><strong>得不偿失</strong>：你花了巨大代价去消除一个其实硬件已经能很好预测的分支。</li>
</ul>
</li>
</ul>
<p><strong>通俗比方</strong></p>
<ul>
<li>想象你是个快递分拣员（in-order processor），面前有一条传送带（instruction stream）。每当遇到一个“神秘包裹”（indirect branch），你必须停下来看清楚地址才能继续分拣，因为后面所有包裹的流向都取决于它。</li>
<li>而你的同事（out-of-order processor）有个超能力：他能<strong>凭直觉</strong>（branch predictor）提前把神秘包裹后面的货也一起分拣了，哪怕猜错了大不了重来。</li>
<li>现在，公司给你配了个新工具：一个“预判标签”（predict-indir-jmp）和一个“核验站”（resolve）。但问题是，不是所有神秘包裹都值得贴这个标签——有些包裹地址本来就很随机，贴了也白贴，反而浪费标签纸（代码空间）和核验时间。</li>
<li>所以，聪明的做法是：先观察一周（<strong>profile-guided</strong>），只给那些“看起来随机但其实有规律”（<strong>predictability &gt; bias</strong>）的包裹贴标签。比如，一个包裹表面上周一到周日发往 7 个不同城市（bias 低），但只要你注意到天气、节日等线索（硬件预测器看到的历史模式），就能 95% 猜中明天发哪（predictability 高）——这种才值得投资。</li>
</ul>
<p><strong>关键一招</strong></p>
<ul>
<li>作者并没有对所有间接分支都应用他们的 <strong>Bungee Jump</strong> 转换（即插入 predict/resolve 指令），而是设置了一个非常务实的筛选条件：<strong>仅当该分支的动态可预测性</strong>（predictability）。</li>
<li>这个 <strong>3% 的阈值</strong> 是通过实验得出的经验法则，它巧妙地划定了“值得转换”和“不值得转换”的边界：<ul>
<li>对于 <strong>high-bias</strong> 分支：传统 RCPO/predication 已经足够好，没必要用新机制。</li>
<li>对于 <strong>low-predictability</strong> 分支：即使转换了，也会频繁进入 recovery code，性能反而更差。</li>
<li>只有 <strong>high-predictability but low-bias</strong> 的分支，才是 Bungee Jump 的“天选之子”——它们能完美利用硬件预测器的能力，又避免了传统软件优化的膨胀开销。</li>
</ul>
</li>
<li>这个策略直接体现在论文的评估数据中（见 Table 2）：<ul>
<li><strong>PDC</strong>（Percentage of Dynamic indirect branches Converted）指标显示，像 <strong>perl2k</strong> 这样的 benchmark 有 <strong>98%</strong> 的动态间接分支被转换，而 <strong>eon</strong> 只有 <strong>58%</strong>，正是因为前者有更多满足 <code>predictability &gt; bias + 3%</code> 的分支。</li>
<li>这也解释了为什么 <strong>mbrot</strong> 虽然 <strong>PDS</strong>（间接分支占比）很高，但提速不明显——它的 <strong>MPKI</strong>（misprediction rate）太高，说明很多分支并不满足高 predictability 的前提。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/511d4138b2d0b78b22751b5e2497d0772da4fd5cd50b2d4d5e60045a4bba2554.jpg" /></p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.sections", "navigation.top", "navigation.indexes", "search.suggest", "search.highlight", "content.code.copy"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../../../javascripts/switcher.js"></script>
      
        <script src="../../../javascripts/smart_back.js"></script>
      
    
  </body>
</html>