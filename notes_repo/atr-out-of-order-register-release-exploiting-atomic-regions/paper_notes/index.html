
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://example.com/notes_repo/atr-out-of-order-register-release-exploiting-atomic-regions/paper_notes/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>ATR: Out-of-Order Register Release Exploiting Atomic Regions 论文解析 - BlaBlaCut</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#atr-out-of-order-register-release-exploiting-atomic-regions" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="BlaBlaCut" class="md-header__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            BlaBlaCut
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              ATR: Out-of-Order Register Release Exploiting Atomic Regions 论文解析
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到深色模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换到深色模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到浅色模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换到浅色模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="BlaBlaCut" class="md-nav__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    BlaBlaCut
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/Recent/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Recent
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/awesome-data-prefetchers/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Awesome Data Prefetchers
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/micro-2025/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    MICRO 2025
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#0" class="md-nav__link">
    <span class="md-ellipsis">
      
        0. 论文基本信息
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. 摘要
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. 背景知识与核心贡献
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. 核心技术和实现细节
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3. 核心技术和实现细节">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#0_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        0. 技术架构概览
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-atomic-commit-regions" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. Atomic Commit Regions
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-consumer-count-tracking" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. Consumer Count Tracking
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-bulk-no-early-release-marking" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. Bulk No-Early-Release Marking
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-double-free-avoidance-mechanism" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. Double-Free Avoidance Mechanism
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. 实验方法与实验结果
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="atr-out-of-order-register-release-exploiting-atomic-regions">ATR: Out-of-Order Register Release Exploiting Atomic Regions 论文解析<a class="headerlink" href="#atr-out-of-order-register-release-exploiting-atomic-regions" title="Permanent link">&para;</a></h1>
<h2 id="0">0. 论文基本信息<a class="headerlink" href="#0" title="Permanent link">&para;</a></h2>
<p><strong>作者 (Authors)</strong></p>
<ul>
<li>Yinyuan Zhao</li>
<li>Surim Oh</li>
<li>Mingsheng Xu</li>
<li>Heiner Litz</li>
</ul>
<p><strong>发表期刊/会议 (Journal/Conference)</strong></p>
<ul>
<li>58th IEEE/ACM International Symposium on Microarchitecture (MICRO '25)</li>
</ul>
<p><strong>发表年份 (Publication Year)</strong></p>
<ul>
<li>2025</li>
</ul>
<hr />
<h2 id="1">1. 摘要<a class="headerlink" href="#1" title="Permanent link">&para;</a></h2>
<p><strong>目的</strong></p>
<ul>
<li>解决现代<strong>superscalar processors</strong>中因保守的寄存器释放策略导致的<strong>physical register file</strong>压力过大问题。传统方法需等待重定义该架构寄存器的指令<strong>commit</strong>后才释放旧物理寄存器，造成资源浪费。</li>
<li>克服现有<strong>early register release</strong>技术的缺陷：<strong>speculative early release</strong>不安全（需复杂的<strong>shadow register file</strong>进行checkpoint），而<strong>non-speculative early release</strong>过于保守（需等待指令<strong>precommit</strong>，即所有更早的分支和异常指令都已解决）。</li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li>提出 <strong>ATR (Atomic register Release)</strong> 技术，其核心是识别并利用<strong>atomic commit regions</strong>（原子提交区域）。</li>
<li><strong>Atomic commit regions</strong>被定义为不包含任何<strong>conditional branches</strong>、<strong>indirect jumps</strong>或<strong>exception-causing instructions</strong>（如load/store, 除零）的指令序列。该区域内的所有指令保证会<strong>原子性地一起commit或flush</strong>。</li>
<li>基于上述洞察，ATR允许在区域内分配的物理寄存器，在其值被<strong>完全消费</strong>（consumer count归零）且被<strong>重定义</strong>后，即可<strong>out-of-order</strong>地安全释放，无需等待重定义指令<strong>precommit</strong>或<strong>commit</strong>。</li>
<li>实现上，通过在<strong>physical register table (PRT)</strong>中为每个物理寄存器增加一个<strong>3-bit consumer counter</strong>来追踪消费者数量，并在<strong>rename stage</strong>引入一个简单的逻辑，当遇到分支或异常指令时，将当前所有活跃的物理寄存器标记为<strong>no-early-release</strong>。</li>
<li>为防止<strong>double-free</strong>，在rename阶段若检测到一个寄存器在原子区域内被重定义，则将其<strong>previous ptag</strong>字段置为<strong>invalid</strong>，确保该寄存器仅由ATR机制释放。</li>
<li><img alt="" src="../images/98a92276cc4d899233510e66772713b33a5080961fbe12e590567ce986c83c47.jpg" /></li>
</ul>
<p><em>Figure 7: The proposed ATR design.</em></p>
<p><strong>结果</strong></p>
<ul>
<li><strong>机会分析</strong>：在SPEC2017基准测试中，平均有<strong>17.04%</strong>的整数寄存器和<strong>13.14%</strong>的浮点寄存器位于<strong>atomic commit regions</strong>内，存在巨大的早期释放潜力。</li>
</ul>
<p><img alt="" src="../images/c92c330f57022012a1e210dbf8e1f0c6a9830212a597408a12fa1bd77a887774.jpg" /></p>
<p><em>Figure 6: Atomic register ratio.</em></p>
<ul>
<li><strong>性能提升</strong>：在<strong>64-entry</strong>寄存器文件配置下，ATR为SPEC2017int带来平均<strong>5.13%</strong>的IPC提升；在<strong>224-entry</strong>配置下，提升为<strong>1.48%</strong>。</li>
</ul>
<p><img alt="" src="../images/2439dfdf2c69d8207501392a63946fe828c651e6de3c8879a2cb309d98f52ffb.jpg" /></p>
<p><em>Figure 10: IPC speedup over the baseline with 64 and 224 physical registers.</em></p>
<ul>
<li><strong>资源节省</strong>：ATR能将寄存器文件大小需求减少<strong>27.1%</strong>，同时性能损失控制在**3%**以内。</li>
</ul>
<p><img alt="" src="../images/b942e1e1ca4b6808dee674c0b8be47075d8a7bbd525206ad1e2a918c16219c9d.jpg" /></p>
<p><em>Figure 15: Overhead reduction of different schemes.</em></p>
<ul>
<li><strong>开销低廉</strong>：硬件开销仅为每个物理寄存器增加<strong>3 bits</strong>（对64位整数寄存器文件开销约<strong>4.6%</strong>），且逻辑可轻松流水线化以满足高频设计需求。</li>
</ul>
<p><strong>结论</strong></p>
<ul>
<li>ATR通过利用<strong>atomic commit regions</strong>的特性，提供了一种<strong>安全、非推测性</strong>的<strong>out-of-order register release</strong>机制，有效缓解了寄存器文件压力。</li>
<li>该技术在保持<strong>precise exception handling</strong>的同时，显著提升了处理器性能或减少了硬件资源需求。</li>
<li>ATR与现有的<strong>non-speculative early release</strong>等技术正交，可以协同工作以获得更优的整体效果。</li>
</ul>
<hr />
<h2 id="2">2. 背景知识与核心贡献<a class="headerlink" href="#2" title="Permanent link">&para;</a></h2>
<p><strong>研究背景</strong></p>
<ul>
<li>现代 <strong>superscalar processors</strong> 为提升 <strong>ILP (Instruction-Level Parallelism)</strong> 和 <strong>IPC (Instructions Per Cycle)</strong>，需要支持大量 <strong>in-flight instructions</strong>，这导致对 <strong>physical register file</strong> 的规模需求巨大。</li>
<li><strong>Register renaming</strong> 是消除 <strong>WAR (Write-After-Read)</strong> 和 <strong>WAW (Write-After-Write)</strong> 依赖的关键技术，但传统的寄存器释放策略非常保守：一个物理寄存器必须等到<strong>重定义同一架构寄存器的指令提交（commit）后</strong>才能被释放。</li>
<li>这种保守策略导致寄存器在不再被使用后仍长时间占用资源，造成 <strong>register file pressure</strong>，限制了性能。扩大寄存器文件虽能缓解此问题，但会带来显著的 <strong>area</strong>、<strong>power</strong> 和 <strong>clock frequency</strong> 挑战。</li>
<li>先前的 <strong>early register release</strong> 方案存在明显缺陷：<ul>
<li><strong>Speculative Early Release</strong>: 在寄存器被最后一位消费者读取后就释放，但这种方式是<strong>不安全</strong>的。一旦发生 <strong>branch misprediction</strong>，被释放的寄存器值可能被后续指令重新消费，导致错误。为解决此问题，需要复杂的 <strong>shadow register file</strong> 来备份数据，增加了硬件开销。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/8e39dd5f5458782b1edcec7288568b4d304fdef0ca7f1a7311d4ea16fd149240.jpg" /></p>
<p><em>Figure 2: An example of a register value that is speculatively released and laterreused.</em></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a>- **Non-Speculative Early Release**: 等待重定义指令变为 **non-speculative**（即所有更老的分支和异常指令都已解决）后再释放。这种方式虽然安全，但过于**保守**，因为指令通常在提交前很短的时间内才变为 non-speculative，释放时机改善有限。
</code></pre></div>
<p><strong>研究动机</strong></p>
<ul>
<li>寄存器生命周期分析揭示了巨大的优化空间。如</li>
</ul>
<p><img alt="" src="../images/4efde8d26c33342c7f5f4051b61c8379f982a69404e06ca47ffd1c7ae3796fd8.jpg" /></p>
<p><em>Figure 4: Cyclecount distribution across the register lifecycle.</em></p>
<p>所示，在 SPEC2017int 中，寄存器有 <strong>41.03%</strong> 的时间处于“已分配但未使用”（Unused）状态，而安全的 Non-Speculative Early Release 仅能比基线提前 <strong>5.05%</strong> 释放寄存器。</p>
<ul>
<li>作者观察到，程序中存在大量 <strong>atomic commit regions</strong> —— 即不包含任何<strong>条件分支</strong>或<strong>异常引发指令</strong>（如 load/store, division）的指令序列。这些区域内的所有指令要么全部提交，要么作为一个整体被冲刷（flush），其行为是原子的。</li>
<li>对 SPEC2017 基准测试的分析表明，<strong>17.04%</strong> 的整数寄存器和 <strong>13.14%</strong> 的浮点寄存器分配发生在这样的原子区域内。</li>
</ul>
<p><img alt="" src="../images/c92c330f57022012a1e210dbf8e1f0c6a9830212a597408a12fa1bd77a887774.jpg" /></p>
<p><em>Figure 6: Atomic register ratio.</em></p>
<ul>
<li>核心洞察在于：对于原子区域内的寄存器，一旦其被最后一位消费者使用且被重定义，就可以<strong>安全地提前释放</strong>，无需等待重定义指令提交或变为 non-speculative。因为即使发生冲刷，整个区域都会被丢弃，不会出现新的消费者来访问已被释放的旧值。</li>
</ul>
<p><strong>核心贡献</strong></p>
<ul>
<li>提出 <strong>ATR (Atomic register Release)</strong>，一种新颖的 <strong>out-of-order register release</strong> 机制，通过利用 <strong>atomic commit regions</strong> 来安全地提前释放寄存器。</li>
<li>ATR 的设计简单高效，仅需在 <strong>physical register table</strong> 中为每个寄存器增加一个 <strong>3-bit consumer counter</strong>，并在重命名阶段加入轻量级逻辑来检测原子区域边界（遇到分支或异常指令时标记寄存器为不可提前释放）。</li>
</ul>
<p><img alt="" src="../images/bd3a9c82d0389a3f7274ef3fcce71d4dbf0eaa4025aab7051ebece3f613070b5.jpg" /></p>
<p><em>Figure 9: Renaming stage modifcations for bulk setting of no-early-release</em></p>
<ul>
<li>ATR <strong>保证了精确异常处理（precise exceptions）</strong> 的正确性，并且<strong>完全避免了因错误预测（misprediction）而导致的恢复复杂性</strong>。</li>
<li>实验评估表明，ATR 能显著提升性能或减少寄存器文件开销：<ul>
<li>在 <strong>64-entry</strong> 寄存器文件配置下，SPEC2017int 平均获得 <strong>5.13%</strong> 的 IPC 提升。</li>
<li>在保持性能损失低于 <strong>3%</strong> 的前提下，ATR 可将所需寄存器文件大小平均减少 <strong>27.1%</strong>。</li>
</ul>
</li>
<li>ATR 与现有的 <strong>Non-Speculative Early Release</strong> 等技术正交，可以无缝结合以获得叠加的性能收益。</li>
</ul>
<p><img alt="" src="../images/2439dfdf2c69d8207501392a63946fe828c651e6de3c8879a2cb309d98f52ffb.jpg" /></p>
<p><em>Figure 10: IPC speedup over the baseline with 64 and 224 physical registers.</em></p>
<hr />
<h2 id="3">3. 核心技术和实现细节<a class="headerlink" href="#3" title="Permanent link">&para;</a></h2>
<h3 id="0_1">0. 技术架构概览<a class="headerlink" href="#0_1" title="Permanent link">&para;</a></h3>
<p><strong>整体技术架构</strong></p>
<p>本文提出的 <strong>ATR (Atomic register Release)</strong> 是一种新颖的寄存器重命名技术，其核心目标是在保证安全性和精确异常处理的前提下，通过识别和利用 <strong>atomic commit regions</strong>（原子提交区域）来实现 <strong>out-of-order register release</strong>（乱序寄存器释放），从而缓解物理寄存器文件的压力。</p>
<ul>
<li><strong>核心洞察</strong>: 在程序执行流中，存在大量不包含条件分支或异常引发指令（如 load/store、除零）的指令序列，即 <strong>atomic commit regions</strong>。这些区域内的所有指令要么全部提交，要么全部被冲刷（flush），具有原子性。</li>
<li><strong>关键机会</strong>: 对于在原子区域内分配的物理寄存器，一旦其值被后续指令重新定义（redefined）且所有消费者都已使用（consumed），就可以立即安全地释放，而无需等待重新定义该寄存器的指令提交（commit）。分析表明，在 <strong>SPEC2017int</strong> 和 <strong>SPEC2017fp</strong> 基准测试中，分别有 <strong>17.04%</strong> 和 <strong>13.14%</strong> 的分配寄存器位于此类原子区域内。</li>
</ul>
<p><img alt="" src="../images/c92c330f57022012a1e210dbf8e1f0c6a9830212a597408a12fa1bd77a887774.jpg" /></p>
<p><em>Figure 6: Atomic register ratio.</em></p>
<p><strong>硬件实现架构</strong></p>
<p>ATR 通过在传统重命名流水线阶段引入轻量级硬件逻辑来实现，主要包括以下组件：</p>
<ul>
<li><strong>扩展的物理寄存器表 (PRT)</strong>:<ul>
<li>为每个物理寄存器条目增加一个 <strong>3-bit consumer count</strong>（消费者计数器），用于追踪有多少条指令消费了该寄存器的值。</li>
<li>保留一个特殊的计数值（例如 <code>7</code>）作为 <strong>no-early-release</strong> 标记，当消费者数量超过阈值（6个）或寄存器不属于原子区域时使用。</li>
</ul>
</li>
<li><strong>原子区域检测逻辑</strong>:<ul>
<li>在重命名阶段，每当遇到分支指令或潜在的异常引发指令时，会将当前 <strong>Speculative Renaming Table (SRT)</strong> 中映射的所有物理寄存器的消费者计数器设置为 <strong>no-early-release</strong>。</li>
<li>这一过程通过一个 <strong>bulk no-early-release logic</strong> 实现，该逻辑可以并行处理多个寄存器，并可通过流水线设计来满足高频时序要求。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/bd3a9c82d0389a3f7274ef3fcce71d4dbf0eaa4025aab7051ebece3f613070b5.jpg" /></p>
<p><em>Figure 9: Renaming stage modifcations for bulk setting of no-early-release</em></p>
<ul>
<li><strong>早期原子释放机制</strong>:<ul>
<li>当一个物理寄存器满足两个条件时，即可触发早期释放：(1) 其对应的架构寄存器已被重新定义；(2) 其 <strong>consumer count</strong> 降为零。</li>
<li>消费者计数器在指令从发射队列（issue queue）发射到执行单元时递减。</li>
</ul>
</li>
<li><strong>双重释放避免机制</strong>:<ul>
<li>为了防止同一个物理寄存器被 ATR 和传统的提交释放逻辑重复释放，ATR 在重命名时会将可早期释放寄存器的“前一个 ptag”字段标记为 <strong>invalid</strong>。</li>
<li>在冲刷（flush）操作期间，通过维护每个架构寄存器的 <strong>redefined</strong> 和 <strong>consumed</strong> 位，来精确判断哪些寄存器已被 ATR 释放，从而避免在冲刷回滚时错误地再次释放它们。</li>
</ul>
</li>
</ul>
<p><strong>与其他技术的协同</strong></p>
<p>ATR 的设计是正交的，可以与现有的寄存器管理技术无缝集成：</p>
<ul>
<li><strong>与 Non-Speculative Early Release 结合</strong>: ATR 负责释放原子区域内的寄存器，而非原子区域的寄存器则由非推测性早期释放机制处理，二者互补。</li>
<li><strong>与其他优化技术兼容</strong>: 如 <strong>Move Elimination</strong>, <strong>Late Allocation</strong>, <strong>Register Packing</strong> 等，均可与 ATR 协同工作以进一步提升性能。</li>
</ul>
<p><strong>性能与开销</strong></p>
<ul>
<li><strong>性能收益</strong>: 在 <strong>64-entry</strong> 寄存器文件配置下，ATR 为 SPEC2017int 带来了 <strong>5.13%</strong> 的平均 IPC 提升；在 <strong>224-entry</strong> 配置下，提升为 <strong>1.48%</strong>。</li>
</ul>
<p><img alt="" src="../images/2439dfdf2c69d8207501392a63946fe828c651e6de3c8879a2cb309d98f52ffb.jpg" /></p>
<p><em>Figure 10: IPC speedup over the baseline with 64 and 224 physical registers.</em></p>
<ul>
<li><strong>硬件开销</strong>: 主要开销是每个物理寄存器增加的 <strong>3-bit</strong> 计数器。对于标量寄存器文件（64位），存储开销约为 <strong>4.6%</strong>；对于向量寄存器文件（256位），开销仅为 <strong>1.1%</strong>。如果与非推测性早期释放结合，该计数器可以共享，从而几乎无额外存储开销。</li>
<li><strong>面积与功耗</strong>: McPAT 分析显示，ATR 方案可实现 <strong>5.5%</strong> 的运行时功耗降低和 <strong>2.7%</strong> 的核心面积缩减。</li>
</ul>
<h3 id="1-atomic-commit-regions">1. Atomic Commit Regions<a class="headerlink" href="#1-atomic-commit-regions" title="Permanent link">&para;</a></h3>
<p><strong>Atomic Commit Regions 的定义与核心洞察</strong></p>
<ul>
<li><strong>Atomic Commit Regions</strong> 被定义为一段连续的指令序列，该序列中<strong>不包含任何条件分支 (conditional branches)、间接跳转 (indirect jumps) 或异常引发指令 (exception-causing instructions)</strong>。</li>
<li>其核心洞察在于：位于同一 Atomic Commit Region 内的所有指令，其命运是绑定的。它们要么作为一个整体<strong>原子性地提交 (atomically commit)</strong>，要么作为一个整体被<strong>刷新 (flush)</strong>。这种原子性保证了在区域内提前释放寄存器是安全的。</li>
<li>该机制的安全性根基在于<strong>精确异常 (precise exceptions)</strong> 处理。由于区域排除了所有可能引发异常的指令（如 Load/Store 可能导致 Page Fault，除法可能导致除零异常），因此无需担心在错误的时间点释放寄存器会破坏处理器的精确状态。</li>
</ul>
<p><strong>实现原理与硬件机制</strong></p>
<ul>
<li>ATR 的实现依赖于在 <strong>rename 阶段</strong>动态识别和标记这些原子区域，并通过一个简单的计数器来跟踪寄存器的使用情况。</li>
<li><strong>关键硬件修改</strong>：<ul>
<li>在物理寄存器表 (Physical Register Table, PRT) 中为每个物理寄存器 (ptag) 增加一个 <strong>3-bit consumer count</strong>。这个计数器用于追踪有多少条指令将此寄存器作为源操作数。</li>
<li>当一条指令的目的寄存器被 rename 时，为其分配一个新的 ptag，并将该 ptag 的 consumer count <strong>初始化为 0</strong>。</li>
<li>当后续指令以该 ptag 为源操作数进行 rename 时，consumer count <strong>递增</strong>。</li>
<li>当消费者指令在 <strong>issue 阶段</strong>读取其源操作数时，consumer count <strong>递减</strong>。</li>
</ul>
</li>
<li><strong>原子区域的动态标记</strong>：<ul>
<li>在 rename 阶段，每当遇到一条<strong>分支指令或异常引发指令</strong>时，ATR 会立即将当前 <strong>Speculative Renaming Table (SRT)</strong> 中映射的所有 ptag 的 consumer count <strong>设置为保留值 7 (no-early-release)</strong>。</li>
<li>这个操作有效地“污染”了所有在该分支/异常指令之前分配的寄存器，标记它们为<strong>非原子区域</strong>的一部分，从而禁止对它们进行提前释放。</li>
<li><img alt="" src="../images/bd3a9c82d0389a3f7274ef3fcce71d4dbf0eaa4025aab7051ebece3f613070b5.jpg" /></li>
</ul>
</li>
</ul>
<p><em>Figure 9: Renaming stage modifcations for bulk setting of no-early-release</em></p>
<ul>
<li><strong>提前释放的触发条件</strong>：<ul>
<li>一个 ptag 可以被提前释放，当且仅当同时满足两个条件：<ol>
<li>该 ptag 对应的架构寄存器已经被<strong>重新定义 (redefined)</strong>，即有一条更新的指令已经 rename 了同一个架构寄存器。</li>
<li>该 ptag 的 <strong>consumer count 等于 0</strong>，表示其值已被所有消费者读取完毕。</li>
</ol>
</li>
<li>一旦满足条件，该 ptag 会被立即释放回 free list，而<strong>无需等待</strong>重新定义它的那条指令提交 (commit) 或预提交 (precommit)。</li>
</ul>
</li>
</ul>
<p><strong>输入输出关系及在整体流水线中的作用</strong></p>
<ul>
<li><strong>输入</strong>：<ul>
<li>指令流，特别是指令的类型（是否为分支、Load/Store、除法等）。</li>
<li>架构寄存器到物理寄存器的映射信息（来自 SRT）。</li>
<li>指令间的生产者-消费者依赖关系。</li>
</ul>
</li>
<li><strong>输出</strong>：<ul>
<li>一个被动态维护的、带有 <strong>consumer count</strong> 和 <strong>no-early-release</strong> 标记的物理寄存器文件。</li>
<li>更早地向 <strong>free list</strong> 返回空闲的物理寄存器 (ptag)。</li>
</ul>
</li>
<li><strong>在整体中的作用</strong>：<ul>
<li><strong>缓解寄存器文件压力</strong>：通过更积极地回收不再需要的寄存器，显著减少了对物理寄存器文件大小的需求。论文数据显示，在 SPEC2017int 和 SPEC2017fp 中，分别有 <strong>17.04%</strong> 和 <strong>13.14%</strong> 的寄存器分配发生在原子区域内，这些寄存器都具备被提前释放的潜力。</li>
<li><img alt="" src="../images/c92c330f57022012a1e210dbf8e1f0c6a9830212a597408a12fa1bd77a887774.jpg" /></li>
</ul>
</li>
</ul>
<p><em>Figure 6: Atomic register ratio.</em></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a>- **提升 IPC**：通过减少因 free list 耗尽而导致的 rename stall，提高了指令吞吐率。例如，在 64-entry 寄存器文件配置下，SPEC2017int 平均 IPC 提升了 **5.13%**。
<a id="__codelineno-1-2" name="__codelineno-1-2" href="#__codelineno-1-2"></a>- **正交性与可组合性**：ATR 机制与现有的 **Late Allocation** 和 **Non-Speculative Early Release** 等技术是正交的，可以无缝结合，产生叠加的性能收益。
<a id="__codelineno-1-3" name="__codelineno-1-3" href="#__codelineno-1-3"></a>- **简化设计**：相比需要复杂检查点 (checkpointing) 或影子寄存器文件 (shadow register file) 的推测性提前释放方案，ATR 通过利用指令序列的固有原子性，实现了**安全、非推测性**的提前释放，避免了恢复逻辑的复杂性。
</code></pre></div>
<p><strong>参数设置与敏感性分析</strong></p>
<ul>
<li><strong>Consumer Counter 宽度</strong>：采用 <strong>3-bit</strong> 计数器，其中值 <strong>7</strong> 被保留为 <code>no-early-release</code> 标记，因此最多支持 <strong>6 个消费者</strong>。分析表明，绝大多数原子区域内的寄存器消费者数量很少（通常为 1-2 个），因此 3-bit 宽度已足够，性能损失可忽略。</li>
</ul>
<p><img alt="" src="../images/f33fec17dd3b8aa6b5b1bb75b2414f0dcec66e8d5dc2f40d1ffc4beef73b32a3.jpg" /></p>
<p><em>Figure 12: Consumer count distribution.</em></p>
<ul>
<li><strong>流水线延迟</strong>：用于标记 <code>no-early-release</code> 的逻辑可能成为关键路径，因此可以对其进行流水线化（例如延迟 1-2 个周期）。分析显示，由于寄存器的<strong>消费 (consumption)</strong> 通常远晚于其<strong>重定义 (redefinition)</strong>，这种延迟对性能几乎没有影响。</li>
</ul>
<p><img alt="" src="../images/dcc41abee643a846e303ecf0df213cb9b98a801747d602c22934e23b2067f59d.jpg" /></p>
<p><em>Figure 14: Average cyclecount between rename, redefine, and commit.</em></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a>- 
</code></pre></div>
<p><img alt="" src="../images/5422e968f8bd1f0a71194441a10a9a579bd7ef007b1700fd594d260fa7c62e11.jpg" /></p>
<p><em>Figure 13: Performance effect of pipelining the register redefinition logic.</em></p>
<hr />
<p><strong>性能与开销总结</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">方案</th>
<th style="text-align: center;">目标 (IPC within 3% of 280-RF baseline) 所需 RF 大小</th>
<th style="text-align: center;">RF 需求减少</th>
<th style="text-align: center;">核心面积减少</th>
<th style="text-align: center;">运行时功耗减少</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Baseline</td>
<td style="text-align: center;">280</td>
<td style="text-align: center;">0%</td>
<td style="text-align: center;">0%</td>
<td style="text-align: center;">0%</td>
</tr>
<tr>
<td style="text-align: left;"><strong>ATR</strong></td>
<td style="text-align: center;"><strong>204</strong></td>
<td style="text-align: center;"><strong>27.1%</strong></td>
<td style="text-align: center;"><strong>2.7%</strong></td>
<td style="text-align: center;"><strong>5.5%</strong></td>
</tr>
<tr>
<td style="text-align: left;">Non-spec-ER</td>
<td style="text-align: center;">212</td>
<td style="text-align: center;">24.3%</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;"><strong>ATR + Non-spec-ER</strong></td>
<td style="text-align: center;"><strong>196</strong></td>
<td style="text-align: center;"><strong>30.0%</strong></td>
<td style="text-align: center;"><strong>2.9%</strong></td>
<td style="text-align: center;"><strong>5.5%</strong></td>
</tr>
</tbody>
</table>
<p><img alt="" src="../images/b942e1e1ca4b6808dee674c0b8be47075d8a7bbd525206ad1e2a918c16219c9d.jpg" /></p>
<p><em>Figure 15: Overhead reduction of different schemes.</em></p>
<h3 id="2-consumer-count-tracking">2. Consumer Count Tracking<a class="headerlink" href="#2-consumer-count-tracking" title="Permanent link">&para;</a></h3>
<p><strong>Consumer Count Tracking 的实现原理与流程</strong></p>
<ul>
<li>ATR 机制的核心在于安全地识别并释放那些位于 <strong>atomic commit regions</strong>（原子提交区域）内的、已不再被使用的物理寄存器。为了实现这一点，系统需要精确知道一个物理寄存器何时被其所有消费者使用完毕。</li>
<li>为此，ATR 在 <strong>物理寄存器表 (Physical Register Table, PRT)</strong> 中为每个物理寄存器条目扩展了一个 <strong>3-bit consumer count</strong>（消费者计数器）。</li>
<li>该计数器的初始化和更新逻辑如下：<ul>
<li><strong>分配时初始化</strong>: 当一条指令在 rename 阶段为其目的寄存器分配一个新的物理寄存器 (ptag) 时，该 ptag 对应的 consumer count 被初始化为 <strong>0</strong>。</li>
<li><strong>消费时递增</strong>: 每当有一条后续指令（消费者）在 rename 阶段将其源操作数映射到这个 ptag 时，该 ptag 的 consumer count 就会 <strong>递增 1</strong>。</li>
<li><strong>执行时递减</strong>: 当一个消费者指令在 <strong>issue</strong> 阶段（或 execute 阶段，根据具体实现）读取其源操作数时，它所依赖的 ptag 的 consumer count 会被 <strong>递减 1</strong>。这标志着该消费者已经“消费”了该寄存器的值。</li>
</ul>
</li>
<li><strong>特殊状态标记</strong>: 计数器的一个特定值（文中指定为 <strong>7</strong>）被保留作为 <strong>no-early-release</strong> 标志。这意味着：<ul>
<li>如果一个 ptag 的消费者数量超过 <strong>6</strong>（因为 7 被保留），则该寄存器将被标记为不可提前释放，回归到传统的提交时释放机制。</li>
<li>更重要的是，当 rename 阶段遇到一条 <strong>分支指令</strong> 或 <strong>可能引发异常的指令</strong>（如 load/store）时，ATR 会立即将 <strong>当前所有架构寄存器所映射的 ptag</strong> 的 consumer count 设置为 <strong>7</strong>（即 no-early-release）。这是确保安全性的关键一步，因为它将这些寄存器排除在原子区域之外。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/bd3a9c82d0389a3f7274ef3fcce71d4dbf0eaa4025aab7051ebece3f613070b5.jpg" /></p>
<p><em>Figure 9: Renaming stage modifcations for bulk setting of no-early-release</em></p>
<p><strong>触发提前释放的条件与输入输出关系</strong></p>
<ul>
<li>一个物理寄存器 (ptag) 能够被 ATR 提前释放，必须同时满足两个条件：<ul>
<li><strong>条件一：寄存器已被重定义 (Redefined)</strong>。这意味着一个新的指令已经为同一个架构寄存器分配了新的 ptag，旧的 ptag 不再是该架构寄存器的最新值。</li>
<li><strong>条件二：消费者计数归零 (Consumer Count is Zero)</strong>。这意味着所有依赖于该 ptag 值的指令都已经被 issue/execute，其值已被完全消费。</li>
</ul>
</li>
<li><strong>输入</strong>:<ul>
<li>Rename 阶段产生的指令流，包含源/目的 ptag 信息。</li>
<li>分支和异常指令的检测信号。</li>
<li>Issue/Execute 阶段的消费者完成信号。</li>
</ul>
</li>
<li><strong>输出</strong>:<ul>
<li>一个 <strong>释放信号</strong>，指示某个 ptag 可以被安全地返回到 <strong>free list</strong>。</li>
<li><strong>作用</strong>: 通过及时回收不再需要的物理寄存器，显著降低了 <strong>register file pressure</strong>（寄存器文件压力），从而减少了因 free list 耗尽而导致的 rename stall，最终提升了 IPC。</li>
</ul>
</li>
</ul>
<p><strong>参数设置与敏感性分析</strong></p>
<ul>
<li><strong>计数器宽度</strong>: 采用 <strong>3-bit</strong> 宽度是一个经过权衡的设计选择。它允许最多追踪 <strong>6</strong> 个消费者（第7个值用于 no-early-release 标记）。</li>
<li>这一设计基于对 SPEC2017 工作负载的分析，如图所示，绝大多数原子区域内的寄存器只有 <strong>1-2 个消费者</strong>，极少有超过 5 个的情况。因此，3-bit 计数器足以覆盖绝大多数可优化场景，而不会引入过多的硬件开销。</li>
</ul>
<p><img alt="" src="../images/f33fec17dd3b8aa6b5b1bb75b2414f0dcec66e8d5dc2f40d1ffc4beef73b32a3.jpg" /></p>
<p><em>Figure 12: Consumer count distribution.</em></p>
<ul>
<li><strong>硬件开销</strong>: 为每个物理寄存器增加 3-bit 计数器，对于 64-bit 的标量寄存器文件，存储开销仅为 <strong>4.6%</strong>；对于 256-bit 的向量寄存器文件，开销更是低至 <strong>1.1%</strong>。如果与 non-speculative early release 机制结合，该计数器可以复用，从而几乎不增加额外存储成本。</li>
</ul>
<p><strong>在整体机制中的作用与优势</strong></p>
<ul>
<li>Consumer count tracking 是 ATR 实现 <strong>safe and non-speculative</strong> 提前释放的基石。它与 <strong>atomic region detection</strong> 逻辑紧密配合：<ul>
<li>Atomic region detection 通过标记 no-early-release 来划定安全边界。</li>
<li>Consumer count tracking 则在安全边界内精确追踪寄存器的生命周期。</li>
</ul>
</li>
<li>相比于 <strong>speculative early release</strong>，ATR 的 consumer count 无需复杂的 checkpointing 和恢复机制，因为在原子区域内，所有指令要么全部提交要么全部 flush，不存在部分消费者消失后又因 misprediction 而重新出现的情况，因此 <strong>flush 时无需恢复 consumer count</strong>。</li>
<li>相比于 <strong>non-speculative early release</strong>，ATR 能在更早的时机（无需等待 redefining instruction precommit）释放寄存器，从而更有效地利用了寄存器资源，尤其是在寄存器文件较小的配置下性能提升显著。</li>
</ul>
<h3 id="3-bulk-no-early-release-marking">3. Bulk No-Early-Release Marking<a class="headerlink" href="#3-bulk-no-early-release-marking" title="Permanent link">&para;</a></h3>
<p><strong>Bulk No-Early-Release Marking 的实现原理与流程</strong></p>
<ul>
<li><strong>触发条件</strong>: 该机制在重命名（rename）阶段被激活，每当一个新指令被重命名时，硬件会检查该指令是否为 <strong>分支指令</strong>（如 conditional branch, indirect jump）或 <strong>异常引发指令</strong>（exception-causing instruction），例如 load/store（可能引发 page fault）或除法指令（可能除零）。</li>
<li><strong>核心目的</strong>: 一旦检测到上述指令，就必须确保在此指令之前所有已分配的、且仍被架构寄存器映射的物理寄存器（ptag）<strong>不能被 ATR 机制提前释放</strong>。这是因为这些指令的存在破坏了“原子提交区域”（atomic commit region）的连续性，使得后续的寄存器释放变得不安全。</li>
<li><strong>并行标记操作</strong>: 为了高效完成这一任务，ATR 设计了一个 <strong>bulk marking</strong> 逻辑单元。该单元在一个周期内，并行地处理所有需要被标记的 ptag。</li>
</ul>
<p><strong>算法流程与硬件交互</strong></p>
<ul>
<li><strong>输入数据</strong>:<ul>
<li><strong>当前 SRT 状态</strong>: 从 **Speculative Renaming Table **(SRT) 中读取所有当前有效的（即旧的）ptag。SRT 保存了架构寄存器到物理寄存器的最新映射。</li>
<li><strong>当前重命名指令信息</strong>: 获取本周期内正在被重命名的 N 条指令（N 为处理器宽度）的新 ptag 及其指令类型。</li>
</ul>
</li>
<li><strong>关键硬件修改</strong>:<ul>
<li>为了读取 SRT 中的所有 ptag，ATR 在重命名阶段为 SRT <strong>增加了一个额外的读端口</strong>。这个端口专门用于 bulk marking 操作，与常规的源操作数查找端口分离，以减少时序压力。</li>
<li>如图</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/bd3a9c82d0389a3f7274ef3fcce71d4dbf0eaa4025aab7051ebece3f613070b5.jpg" /></p>
<p><em>Figure 9: Renaming stage modifcations for bulk setting of no-early-release</em></p>
<p>所示，该逻辑单元接收来自 SRT 的所有旧 ptag 和当前指令的新 ptag。</p>
<ul>
<li><strong>标记逻辑</strong>:<ul>
<li>对于本周期重命名的每一条指令，如果它被识别为分支或异常引发指令，则 <strong>立即生成一个信号</strong>，指示需要进行 bulk marking。</li>
<li>该信号会驱动逻辑单元，将从 SRT 读出的所有 ptag 对应的 <strong>consumer count</strong> 字段设置为一个保留值 <strong><code>no-early-release</code></strong>（在实现中，3-bit 计数器的值 <code>7</code> 被保留为此用途）。</li>
<li>这个过程是 <strong>高度并行化</strong> 的，论文提到在一个 8-wide x86 设计中，最多需要同时处理 23 个 ptag（16 个来自 SRT + 7 个来自当前指令），并通过并行逻辑同时计算所有 <code>no-early-release</code> 信号。</li>
</ul>
</li>
<li><strong>时序优化</strong>:<ul>
<li>由于 bulk marking 逻辑可能路径较长，影响关键路径，设计允许对其进行 <strong>N 级流水线化</strong>。</li>
<li>为了保证正确性，当该逻辑被流水线化时，<strong>寄存器重定义</strong>（redefined）信号也必须被延迟相同的 N 个周期。这确保了一个 ptag 不会在其 <code>no-early-release</code> 状态被最终确定之前就被错误地标记为可释放。</li>
</ul>
</li>
</ul>
<p><strong>参数设置与作用</strong></p>
<ul>
<li><strong>Consumer Counter 宽度</strong>: 使用 <strong>3-bit</strong> 的 consumer counter。其中，值 <code>0-6</code> 用于正常计数消费者数量，值 <code>7</code> 被专用于表示 <strong><code>no-early-release</code></strong>。</li>
<li><strong>在整体 ATR 机制中的作用</strong>:<ul>
<li>这是 ATR 实现 <strong>安全性</strong> 的基石。通过精确地标记出哪些寄存器位于非原子区域的边界，ATR 能够严格区分出可以安全提前释放的寄存器和必须保守处理的寄存器。</li>
<li>它直接定义了 <strong>原子提交区域</strong>（atomic commit region）的动态边界。一个原子区域始于一个非分支/非异常指令，并持续到下一个分支或异常指令被重命名为止。</li>
<li>该机制确保了即使在发生 <strong>分支误预测</strong>（misprediction）的情况下，也不会出现因提前释放而丢失必要寄存器值的情况，从而完美支持 <strong>precise exceptions</strong>。</li>
</ul>
</li>
</ul>
<hr />
<p><strong>性能与开销分析</strong></p>
<p>根据论文第 4.4 节的硬件开销评估，该 bulk marking 逻辑的具体指标如下：</p>
<table>
<thead>
<tr>
<th style="text-align: left;">评估项目</th>
<th style="text-align: left;">数值/描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>逻辑门数</strong></td>
<td style="text-align: left;">2,960 gates</td>
</tr>
<tr>
<td style="text-align: left;"><strong>最坏情况逻辑级数</strong></td>
<td style="text-align: left;">42 levels</td>
</tr>
<tr>
<td style="text-align: left;">**估算延迟 **(5nm)</td>
<td style="text-align: left;">378 ps (约 2.6 GHz)</td>
</tr>
<tr>
<td style="text-align: left;"><strong>对性能的影响</strong></td>
<td style="text-align: left;">通过引入 1-2 级流水线，可支持 &gt;4GHz 频率，且对 IPC 性能影响<strong>可忽略不计</strong>（见 Figure 13）</td>
</tr>
</tbody>
</table>
<p>该设计在保证功能安全的同时，通过并行化和可选的流水线化，将硬件开销和性能影响控制在了极低的水平。</p>
<h3 id="4-double-free-avoidance-mechanism">4. Double-Free Avoidance Mechanism<a class="headerlink" href="#4-double-free-avoidance-mechanism" title="Permanent link">&para;</a></h3>
<p><strong>Double-Free Avoidance 机制的核心原理</strong></p>
<p>ATR (Atomic register Release) 机制通过允许在指令提交（commit）前释放物理寄存器（ptag），打破了传统按序释放的限制。这引入了一个关键挑战：如何确保一个 ptag <strong>不会被 ATR 和传统的提交释放逻辑同时释放两次</strong>（即 double-free）。该机制通过两个层面的设计来解决此问题：<strong>重命名时的预防性标记</strong>和<strong>刷新（flush）时的精确追踪</strong>。</p>
<ul>
<li><strong>重命名阶段的预防措施</strong><ul>
<li>当一条指令（称为 redefining instruction）在重命名阶段为其目标架构寄存器分配一个新的 ptag 时，它会获取该寄存器当前映射的旧 ptag（previous ptag）。</li>
<li>如果这条 redefining instruction 与分配 previous ptag 的指令位于同一个 <strong>atomic commit region</strong>（即两者之间没有分支或异常指令），那么这个 previous ptag 就符合 ATR 的早期释放条件。</li>
<li>此时，系统会将该指令元数据中的 <strong>previous ptag 字段标记为 invalid</strong>。</li>
<li>这个 <strong>invalid 标记是一个关键信号</strong>，它明确指示：“这个 ptag 应该由 ATR 负责释放，而不是在 redefining instruction 提交时由传统逻辑释放”。</li>
<li>因此，在正常的提交流程中，如果检测到 previous ptag 是 <strong>invalid</strong>，提交逻辑就会跳过对该 ptag 的释放操作，从而避免了与 ATR 的冲突。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/bd3a9c82d0389a3f7274ef3fcce71d4dbf0eaa4025aab7051ebece3f613070b5.jpg" /></p>
<p><em>Figure 9: Renaming stage modifcations for bulk setting of no-early-release</em></p>
<ul>
<li><strong>刷新（Flush）阶段的精确追踪</strong><ul>
<li>当发生分支预测错误等事件需要刷新流水线时，处理器必须回收所有被刷新指令所分配的 ptag。</li>
<li>此时情况更复杂，因为需要区分三种状态的 ptag：<ol>
<li><strong>Non-early-release ptags</strong>: 不符合 ATR 条件的 ptag，必须在此时回收。</li>
<li><strong>Early-release-eligible but not yet released ptags</strong>: 符合 ATR 条件但尚未被 ATR 释放的 ptag，也必须在此时回收。</li>
<li><strong>Already early-released ptags</strong>: 已经被 ATR 释放并返回到 free list 的 ptag，<strong>绝对不能再回收</strong>，否则会造成 double-free。</li>
</ol>
</li>
<li>为了解决这个问题，ATR 引入了两个 <strong>per-architectural-register 的标志位</strong>：<strong>redefined bit</strong> 和 <strong>consumed bit</strong>。</li>
<li>刷新过程采用从 ROB 最旧指令向刷新点遍历的方式，并执行以下算法：<ul>
<li>对于每条被刷新的指令，首先检查其目标寄存器的 <strong>redefined</strong> 和 <strong>consumed</strong> 标志位。如果两者都为真，则说明其 previous ptag <strong>已被 ATR 释放</strong>，因此跳过回收。</li>
<li>然后，检查该指令的所有源寄存器。如果某个源寄存器对应的 <strong>redefined</strong> 位为真，且该指令尚未被发射（issued），则清除其 <strong>consumed</strong> 位（因为存在一个未执行的消费者）。</li>
<li>最后，如果该指令的目标寄存器的 previous ptag 是 <strong>invalid</strong>（即 ATR-releasable），则设置该目标寄存器的 <strong>redefined</strong> 位为真，并设置 <strong>consumed</strong> 位为真（假设所有消费者都已处理，后续步骤会修正）。</li>
<li>在处理完当前指令后，清除其目标寄存器的 <strong>redefined</strong> 和 <strong>consumed</strong> 标志位，为下一轮处理做准备。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>输入输出关系及在整体中的作用</strong></p>
<ul>
<li><strong>输入</strong>:<ul>
<li><strong>重命名阶段</strong>: 指令流、当前 SRT (Speculative Renaming Table) 状态、指令类型（是否为分支/异常指令）。</li>
<li><strong>刷新阶段</strong>: 需要被刷新的指令序列、每个指令的元数据（包含 previous ptag 是否 valid）、每个架构寄存器的 <strong>redefined/consumed</strong> 标志位状态。</li>
</ul>
</li>
<li><strong>输出</strong>:<ul>
<li><strong>重命名阶段</strong>: 指令元数据中带有正确标记（valid/invalid）的 previous ptag 字段。</li>
<li><strong>刷新阶段</strong>: 一份精确的、需要被回收到 free list 的 ptag 列表，该列表<strong>排除了所有已被 ATR 释放的 ptag</strong>。</li>
</ul>
</li>
<li><strong>在整体中的作用</strong>:<ul>
<li><strong>保证正确性</strong>: 这是 ATR 机制安全运行的基石。没有这个机制，double-free 会导致 free list 被破坏，进而引发严重的功能错误。</li>
<li><strong>实现正交性</strong>: 通过清晰地划分 ATR 和传统提交逻辑的职责（谁负责释放哪个 ptag），使得 ATR 可以无缝集成到现有的处理器微架构中，而无需对提交或刷新的核心逻辑进行大规模重构。</li>
<li><strong>支持高效回收</strong>: 在刷新时能够快速、准确地识别出哪些资源需要回收，哪些不需要，保证了错误恢复路径的效率。</li>
</ul>
</li>
</ul>
<hr />
<h2 id="4">4. 实验方法与实验结果<a class="headerlink" href="#4" title="Permanent link">&para;</a></h2>
<p><strong>实验设置</strong></p>
<ul>
<li>仿真环境基于开源的 <strong>Scarab</strong> 周期级模拟器，配置为模仿 <strong>Intel Golden Cove</strong> 架构的核心。</li>
<li>处理器关键参数如下表所示：
    | 组件                                    | 配置                          |
    | :-------------------------------------- | :---------------------------- |
    | Fetch/Decode/Rename/Issue/Commit Width  | 6 / 6 / 6 / 8 / 8             |
    | Reorder Buffer (ROB)                    | 512 entries                   |
    | Load/Store Queue (LSQ)                  | 96 / 64 entries               |
    | Physical Register File (Integer/Vector) | 可变 (64 - 280) / 224 entries |
    | Branch Predictor                        | TAGE-SC                       |</li>
<li>工作负载采用 <strong>SPEC2017int</strong> 和 <strong>SPEC2017fp</strong> 基准测试套件。</li>
<li>对每个应用，使用 <strong>simpoint</strong> 方法选取并加权平均多个具有代表性的 <strong>10M</strong> 指令片段进行模拟，以确保结果的代表性。</li>
</ul>
<p><strong>结果数据分析</strong></p>
<ul>
<li><strong>性能提升 (IPC Speedup)</strong>:<ul>
<li>在 <strong>64-entry</strong> 寄存器文件的受限配置下，ATR 技术相比基线（Baseline）在 SPEC2017int 上实现了 <strong>5.70%</strong> 的平均 IPC 提升，在 SPEC2017fp 上实现了 <strong>4.69%</strong> 的提升。</li>
<li>在 <strong>224-entry</strong> 寄存器文件的较大配置下，ATR 依然有效，分别带来 <strong>1.48%</strong> (int) 和 <strong>1.11%</strong> (fp) 的平均 IPC 提升。</li>
<li>ATR 与非推测性提前释放（nonspec-ER）技术结合后，性能进一步提升，在 64-entry 配置下，相比仅使用 nonspec-ER 的方案，还能额外获得约 <strong>3.2%</strong> 的 IPC 增益。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/2439dfdf2c69d8207501392a63946fe828c651e6de3c8879a2cb309d98f52ffb.jpg" /></p>
<p><em>Figure 10: IPC speedup over the baseline with 64 and 224 physical registers.</em></p>
<ul>
<li><strong>寄存器文件压力缓解</strong>:<ul>
<li>ATR 能显著减少对物理寄存器数量的需求。为了达到与 <strong>280-entry</strong> 基线配置相差不到 <strong>3%</strong> 的性能，仅使用 ATR 的方案只需 <strong>204</strong> 个寄存器，实现了 <strong>27.1%</strong> 的寄存器文件规模缩减。</li>
<li>结合 nonspec-ER 后，所需寄存器数可进一步降至 <strong>196</strong>，缩减比例高达 <strong>30%</strong>。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/b942e1e1ca4b6808dee674c0b8be47075d8a7bbd525206ad1e2a918c16219c9d.jpg" /></p>
<p><em>Figure 15: Overhead reduction of different schemes.</em></p>
<ul>
<li><strong>功耗与面积优化</strong>:<ul>
<li>由于减少了寄存器文件的压力和访问，ATR 方案在 McPAT 评估下实现了 <strong>5.5%</strong> 的运行时功耗降低和 <strong>2.7%</strong> 的核心面积缩减。</li>
</ul>
</li>
</ul>
<p><strong>消融实验 (Ablation Studies)</strong></p>
<ul>
<li><strong>消费者计数器宽度敏感性</strong>:<ul>
<li>ATR 使用一个 <strong>3-bit</strong> 的消费者计数器（最多支持6个消费者，1个值保留给 no-early-release 状态）。</li>
<li>分析显示，绝大多数原子区域内的寄存器只有 <strong>1-2</strong> 个消费者，即使对于消费者较多的 <code>namd</code> 基准，也很少超过5个。</li>
<li>因此，3-bit 计数器的设计是充足的，使用无限宽计数器带来的性能收益可以忽略不计。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/f33fec17dd3b8aa6b5b1bb75b2414f0dcec66e8d5dc2f40d1ffc4beef73b32a3.jpg" /></p>
<p><em>Figure 12: Consumer count distribution.</em></p>
<ul>
<li><strong>流水线延迟敏感性</strong>:<ul>
<li>ATR 在重命名阶段引入的“批量设置 no-early-release”逻辑可能需要流水线化以满足时序要求。</li>
<li>实验评估了将寄存器重定义信号延迟 <strong>1</strong> 或 <strong>2</strong> 个周期的影响，结果显示性能损失微乎其微。</li>
<li>原因在于，在原子区域内，寄存器通常在被消费之前很久就已经被重定义了，因此短暂的延迟不会影响其提前释放的时机。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/5422e968f8bd1f0a71194441a10a9a579bd7ef007b1700fd594d260fa7c62e11.jpg" /></p>
<p><em>Figure 13: Performance effect of pipelining the register redefinition logic.</em></p>
<p><img alt="" src="../images/dcc41abee643a846e303ecf0df213cb9b98a801747d602c22934e23b2067f59d.jpg" /></p>
<p><em>Figure 14: Average cyclecount between rename, redefine, and commit.</em></p>
<ul>
<li><strong>原子区域机会分析</strong>:<ul>
<li>通过对 SPEC2017 基准的分析，发现 <strong>17.04%</strong> 的整数寄存器和 <strong>13.14%</strong> 的浮点寄存器分配发生在原子提交区域内。</li>
<li>这为 ATR 提供了坚实的机会基础，解释了其性能收益的来源。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/c92c330f57022012a1e210dbf8e1f0c6a9830212a597408a12fa1bd77a887774.jpg" /></p>
<p><em>Figure 6: Atomic register ratio.</em></p>
<ul>
<li><strong>寄存器生命周期分析</strong>:<ul>
<li>寄存器在其生命周期中，有相当大一部分时间（SPECint 中为 <strong>41.03%</strong>）处于“已分配但未使用”的状态。</li>
<li>非推测性提前释放只能安全地回收其中很小一部分（<strong>5.05%</strong>），而 ATR 正是利用了这中间的巨大鸿沟来实现安全的提前释放。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/4efde8d26c33342c7f5f4051b61c8379f982a69404e06ca47ffd1c7ae3796fd8.jpg" /></p>
<p><em>Figure 4: Cyclecount distribution across the register lifecycle.</em></p>
<hr />












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.sections", "navigation.top", "navigation.indexes", "search.suggest", "search.highlight", "content.code.copy"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../../../javascripts/switcher.js"></script>
      
    
  </body>
</html>