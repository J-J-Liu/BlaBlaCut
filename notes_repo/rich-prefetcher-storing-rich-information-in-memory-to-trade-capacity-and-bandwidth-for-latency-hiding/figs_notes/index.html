
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://example.com/notes_repo/rich-prefetcher-storing-rich-information-in-memory-to-trade-capacity-and-bandwidth-for-latency-hiding/figs_notes/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>RICH Prefetcher: Storing Rich Information in Memory to Trade Capacity and Bandwidth for Latency Hiding 图表详解 - BlaBlaCut</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#rich-prefetcher-storing-rich-information-in-memory-to-trade-capacity-and-bandwidth-for-latency-hiding" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="BlaBlaCut" class="md-header__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            BlaBlaCut
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              RICH Prefetcher: Storing Rich Information in Memory to Trade Capacity and Bandwidth for Latency Hiding 图表详解
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到深色模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换到深色模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到浅色模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换到浅色模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="BlaBlaCut" class="md-nav__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    BlaBlaCut
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/Recent/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Recent
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/awesome-data-prefetchers/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Awesome Data Prefetchers
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/micro-2025/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    MICRO 2025
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#table-1-ddr-specifications-across-generations-exhibit-the-high-bandwidth-high-capacity-and-high-latency-trends" class="md-nav__link">
    <span class="md-ellipsis">
      
        Table 1: DDR specifications across generations exhibit the high-bandwidth high-capacity and high-latency trends
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-1-different-workloads-favor-distinct-spatial-region-sizes-for-prefetching-approximately-half-achieve-peak-performance-under-conventional-4-kb-regionswhile-the-remainder-achieve-peak-performance-with-larger-spatial-region-sizes" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 1: Different workloads favor distinct spatial region sizes for prefetching; approximately half achieve peak performance under conventional 4 KB regions,while the remainder achieve peak performance with larger spatial region sizes
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-2-the-multi-offset-trigger-mechanism-can-distinguish-common-origin-later-divergent-access-streams" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 2: The multi-offset trigger mechanism can distinguish "common-origin, later-divergent" access streams
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-3-by-using-more-access-offsets-in-a-trigger-we-can-trade-off-between-the-accuracy-and-coverage-of-prefetching-specifically-a-band-c-correspond-to-16-kb-region-4-kbregion-and-2-kb-region" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 3: By using more access offsets in a trigger, we can trade off between the accuracy and coverage of prefetching. Specifically, a), b),and c) correspond to 16 KB-region, 4 KBregion, and 2 KB-region.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#24623341e46f13ed9c6004980d11054a104d928f1085abdd3d49c538fd7c2597jpg" class="md-nav__link">
    <span class="md-ellipsis">
      
        24623341e46f13ed9c6004980d11054a104d928f1085abdd3d49c538fd7c2597.jpg
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-4-achieving-high-accuracy-in-large-spatial-regions-and-high-coverage-in-small-spatial-regions-by-using-different-numbers-of-trigger-offsets-figure-5-placing-16-kb-pht-off-chip-keeps-most-prefetch-opportunities-even-with-additional-memory-access-latency" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 4: Achieving high accuracy in large spatial regions and high coverage in small spatial regions by using different numbers of trigger offsets Figure 5: Placing 16 KB PHT off-chip keeps most prefetch opportunities, even with additional memory access latency
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#table-2-categorization-of-richs-metadata" class="md-nav__link">
    <span class="md-ellipsis">
      
        Table 2: Categorization of RICH's metadata
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#table-3-cover-ratio-under-a-2oo-entry-storage-constraint-of-16-kb-region-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      
        Table 3: Cover ratio under a 2oo-entry storage constraint of 16 KB-region patterns
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-6-architecture-of-rich" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 6: Architecture of RICH
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-7-training-process-of-each-region" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 7: Training process of each region
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-8-the-region-arbitration-unit-selects-the-appropriate-region-to-prefetch-step-p3" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 8: The Region Arbitration unit selects the appropriate region to prefetch (Step P3)
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#table-4-breakdown-of-on-chip-storage-overheads" class="md-nav__link">
    <span class="md-ellipsis">
      
        Table 4: Breakdown of on-chip storage overheads
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#table-5-simulated-system" class="md-nav__link">
    <span class="md-ellipsis">
      
        Table 5: Simulated system
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#table-6-comparison-of-area-overheads" class="md-nav__link">
    <span class="md-ellipsis">
      
        Table 6: Comparison of area overheads
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#table-7-workloads-used-for-evaluation" class="md-nav__link">
    <span class="md-ellipsis">
      
        Table 7: Workloads used for evaluation
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-9-rich-outperforms-bingo-across-four-benchmark-suites-on-a-single-core-system" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 9: RICH outperforms Bingo across four benchmark suites on a single-core system
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-10-rich-improves-coverage-and-timeliness-while-maintaining-comparable-accuracy" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 10: RICH improves coverage and timeliness while maintaining comparable accuracy
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-11-detailed-speedup-achieved-by-bingo-pmp-and-rich-on-representative-traces" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 11: Detailed speedup achieved by Bingo, PMP and RICH on representative traces
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-12-each-region-makes-a-significant-contribution-to-prefetchingand-we-achieve-a-significant-reduction-in-amat" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 12: Each region makes a significant contribution to prefetching,and we achieve a significant reduction in AMAT
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-13-rich-demonstrates-greater-performance-gains-compared-to-bingo-and-pmp-as-memory-latency-increases-highlighting-its-potential-for-future-high-latency-systems" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 13: RICH demonstrates greater performance gains compared to Bingo and PMP as memory latency increases, highlighting its potential for future high-latency systems
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-14-performance-under-different-memory-bandwidth" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 14: Performance under different memory bandwidth
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-15-multi-offset-trigger-mechanism-significantly-benefits-rich-while-offloading-part-of-the-16-kb-region-patterns-has-limited-performance-impact" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 15: Multi-offset trigger mechanism significantly benefits RICH, while offloading part of the 16 KB-Region patterns has limited performance impact.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-16-iso-storage-comparison-shows-rich-is-more-storage-efficient-than-bingo-and-pmp" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 16: Iso-storage comparison shows RICH is more storage efficient than Bingo and PMP.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-17-sensitivity-to-different-prefetch-count-thresholds-for-16-kb-region-under-different-memory-latencies" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 17: Sensitivity to different prefetch count thresholds for 16 KB-region under different memory latencies
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-18-sensitivity-to-different-pht-sizes" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 18: Sensitivity to different PHT sizes
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-19-rich-outperforms-bingo-in-both-homogeneous-and-heterogeneous-workloads-on-a-4-core-system" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 19: RICH outperforms Bingo in both homogeneous and heterogeneous workloads on a 4-core system
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="rich-prefetcher-storing-rich-information-in-memory-to-trade-capacity-and-bandwidth-for-latency-hiding">RICH Prefetcher: Storing Rich Information in Memory to Trade Capacity and Bandwidth for Latency Hiding 图表详解<a class="headerlink" href="#rich-prefetcher-storing-rich-information-in-memory-to-trade-capacity-and-bandwidth-for-latency-hiding" title="Permanent link">&para;</a></h1>
<h3 id="table-1-ddr-specifications-across-generations-exhibit-the-high-bandwidth-high-capacity-and-high-latency-trends">Table 1: DDR specifications across generations exhibit the high-bandwidth high-capacity and high-latency trends<a class="headerlink" href="#table-1-ddr-specifications-across-generations-exhibit-the-high-bandwidth-high-capacity-and-high-latency-trends" title="Permanent link">&para;</a></h3>
<p><img alt="ebf30d70127b3ff60d54844994f1d62755d9e6521f56737c6143785345b7ca9b.jpg" src="../images/ebf30d70127b3ff60d54844994f1d62755d9e6521f56737c6143785345b7ca9b.jpg" /></p>
<ul>
<li>该图片为论文中的 <strong>Table 1</strong>，标题明确指出其展示的是 <strong>DDR 规格在不同代际间的演进趋势</strong>，核心聚焦于 <strong>高带宽、大容量与高延迟</strong> 的并存现象。</li>
<li>表格横向列出四列关键指标：<strong>DDR Gen.（代际）</strong>、<strong>Peak speed（峰值速度）</strong>、<strong>Max. size（最大容量）</strong>、<strong>latency on row hit（行命中延迟）</strong> 和 <strong>latency on row miss（行未命中延迟）</strong>。</li>
<li>纵向对比三代主流 DDR 标准：<strong>DDR3 [27]</strong>、<strong>DDR4 [28]</strong>、<strong>DDR5 [29]</strong>，清晰呈现技术迭代路径。</li>
</ul>
<table>
<thead>
<tr>
<th>DDR Gen.</th>
<th>Peak speed</th>
<th>Max. size</th>
<th>latency on row hit</th>
<th>latency on row miss</th>
</tr>
</thead>
<tbody>
<tr>
<td>3 [27]</td>
<td>2133 MT/s</td>
<td>8Gb</td>
<td>10-15ns</td>
<td>20-30ns</td>
</tr>
<tr>
<td>4 [28]</td>
<td>3200 MT/s</td>
<td>16Gb</td>
<td>12-15ns</td>
<td>25-30ns</td>
</tr>
<tr>
<td>5 [29]</td>
<td>7200 MT/s</td>
<td>64Gb</td>
<td>14-18ns</td>
<td>28-36ns</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>峰值速度</strong> 从 DDR3 的 2133 MT/s 跃升至 DDR5 的 7200 MT/s，增长超过 <strong>三倍</strong>，体现 <strong>高带宽</strong> 趋势。</li>
<li><strong>最大容量</strong> 从 8Gb 增至 64Gb，同样实现 <strong>八倍提升</strong>，印证 <strong>大容量</strong> 发展方向。</li>
<li><strong>访问延迟</strong> 指标同步上升：<strong>行命中延迟</strong> 从 10-15ns 增至 14-18ns，<strong>行未命中延迟</strong> 从 20-30ns 扩展至 28-36ns，表明 <strong>高延迟</strong> 成为伴随性能提升的代价。</li>
<li>该表格作为背景支撑，旨在说明现代内存系统设计中 <strong>带宽与容量提升以牺牲延迟为代价</strong> 的普遍规律，为论文提出的 RICH prefetcher 针对高延迟场景优化提供必要性依据。</li>
</ul>
<h3 id="figure-1-different-workloads-favor-distinct-spatial-region-sizes-for-prefetching-approximately-half-achieve-peak-performance-under-conventional-4-kb-regionswhile-the-remainder-achieve-peak-performance-with-larger-spatial-region-sizes">Figure 1: Different workloads favor distinct spatial region sizes for prefetching; approximately half achieve peak performance under conventional 4 KB regions,while the remainder achieve peak performance with larger spatial region sizes<a class="headerlink" href="#figure-1-different-workloads-favor-distinct-spatial-region-sizes-for-prefetching-approximately-half-achieve-peak-performance-under-conventional-4-kb-regionswhile-the-remainder-achieve-peak-performance-with-larger-spatial-region-sizes" title="Permanent link">&para;</a></h3>
<p><img alt="d5fba481da15479c195a9af0bf842d4d112452c08c84cbddf3bc89b458b9e501.jpg" src="../images/d5fba481da15479c195a9af0bf842d4d112452c08c84cbddf3bc89b458b9e501.jpg" /></p>
<ul>
<li>图片为一个环形图，标题为“Figure 1: Different workloads favor distinct spatial region sizes for prefetching; approximately half achieve peak performance under conventional 4 KB regions, while the remainder achieve peak performance with larger spatial region sizes”，旨在展示不同工作负载在预取时对空间区域大小的偏好。</li>
<li>图表中心标注“Percentage of optimal spatial prefetch region sizes:”，表明其统计的是各区域尺寸作为最优预取单元的占比。</li>
<li>图例清晰对应六种区域尺寸：<strong>1KB</strong>、<strong>2KB</strong>、<strong>4KB</strong>、<strong>8KB</strong>、<strong>16KB</strong>、<strong>32KB</strong>，分别以不同颜色区分。</li>
<li>各区域尺寸对应的百分比如下表所示：</li>
</ul>
<table>
<thead>
<tr>
<th>区域尺寸</th>
<th>占比</th>
</tr>
</thead>
<tbody>
<tr>
<td>1KB</td>
<td>7.1%</td>
</tr>
<tr>
<td>2KB</td>
<td>24.3%</td>
</tr>
<tr>
<td>4KB</td>
<td>22.1%</td>
</tr>
<tr>
<td>8KB</td>
<td>12.1%</td>
</tr>
<tr>
<td>16KB</td>
<td>25.7%</td>
</tr>
<tr>
<td>32KB</td>
<td>8.6%</td>
</tr>
</tbody>
</table>
<ul>
<li>数据显示，<strong>4KB</strong>区域虽是传统主流选择，但仅占<strong>22.1%</strong>，不足四分之一；而<strong>16KB</strong>区域占比最高，达<strong>25.7%</strong>，成为最常被选为最优预取尺寸的工作负载。</li>
<li><strong>2KB</strong>和<strong>16KB</strong>合计占比<strong>50%</strong>，印证了原文“approximately half achieve peak performance under conventional 4 KB regions, while the remainder achieve peak performance with larger spatial region sizes”的结论。</li>
<li>该图直观揭示了单一固定区域尺寸（如4KB）无法满足多样化的访问模式需求，支持论文中提出多尺度区域预取的设计动机。</li>
</ul>
<h3 id="figure-2-the-multi-offset-trigger-mechanism-can-distinguish-common-origin-later-divergent-access-streams">Figure 2: The multi-offset trigger mechanism can distinguish "common-origin, later-divergent" access streams<a class="headerlink" href="#figure-2-the-multi-offset-trigger-mechanism-can-distinguish-common-origin-later-divergent-access-streams" title="Permanent link">&para;</a></h3>
<p><img alt="422c82dae797ba1a7110178407e9347cf3d4bdb82956c403ca656ded0eb8e80a.jpg" src="../images/422c82dae797ba1a7110178407e9347cf3d4bdb82956c403ca656ded0eb8e80a.jpg" /></p>
<ul>
<li>图片展示了 <strong>multi-offset trigger mechanism</strong> 如何区分具有“共同起点、后期发散”特征的访问流，这是传统单偏移触发机制无法做到的。</li>
<li>左侧图示为 <strong>single-offset trigger mechanism</strong> 的局限性：在 4 KB 空间区域内，两个访问流 A 和 B 均从地址 0x1 开始访问，但后续路径不同（A 访问 0x4, 0xc；B 访问 0xc, 0x1），单偏移机制仅凭首个偏移量无法区分二者，导致误预测。</li>
<li>右侧图示为 <strong>multi-offset trigger mechanism</strong> 的优势：通过记录多个访问偏移（如 0x1 和 0x4 对应流 A，0x1 和 0xc 对应流 B），系统可识别出两个流虽起始相同，但后续行为不同，从而分别建模并准确预测。</li>
<li>该机制的核心在于利用 <strong>多偏移信息</strong> 验证访问模式的连续性和方向性，避免将“common-origin, later-divergent”流错误归类为同一模式。</li>
<li>图中明确标注了两个访问流的具体地址序列：<ul>
<li>流 A 地址：<strong>0x1, 0x4, 0xc</strong></li>
<li>流 B 地址：<strong>0x1, 0xc, 0x4</strong></li>
</ul>
</li>
<li>此设计直接支持 RICH prefetcher 中对 16 KB 区域采用 (PC, 5 offsets) 触发策略，以提升大区域预取的准确性，同时牺牲部分覆盖率换取高精度。</li>
</ul>
<table>
<thead>
<tr>
<th>机制类型</th>
<th>能否区分流 A/B</th>
<th>核心依据</th>
<th>缺陷/优势</th>
</tr>
</thead>
<tbody>
<tr>
<td>Single-offset</td>
<td>❌ 不能</td>
<td>仅依赖首个访问偏移（0x1）</td>
<td>无法捕捉后续发散行为，易产生误预测</td>
</tr>
<tr>
<td>Multi-offset</td>
<td>✅ 能</td>
<td>依赖多个访问偏移组合（如 0x1+0x4 vs 0x1+0xc）</td>
<td>提升准确性，尤其适用于大区域预取场景</td>
</tr>
</tbody>
</table>
<ul>
<li>该图是 RICH 设计中 <strong>Insight 2</strong> 的直观体现，即“观察更多访问偏移可提高准确性，代价是降低覆盖率”，为后续多尺度区域仲裁机制奠定基础。</li>
</ul>
<h3 id="figure-3-by-using-more-access-offsets-in-a-trigger-we-can-trade-off-between-the-accuracy-and-coverage-of-prefetching-specifically-a-band-c-correspond-to-16-kb-region-4-kbregion-and-2-kb-region">Figure 3: By using more access offsets in a trigger, we can trade off between the accuracy and coverage of prefetching. Specifically, a), b),and c) correspond to 16 KB-region, 4 KBregion, and 2 KB-region.<a class="headerlink" href="#figure-3-by-using-more-access-offsets-in-a-trigger-we-can-trade-off-between-the-accuracy-and-coverage-of-prefetching-specifically-a-band-c-correspond-to-16-kb-region-4-kbregion-and-2-kb-region" title="Permanent link">&para;</a></h3>
<p><img alt="1f10b5e59c03da97147d1e6f49132168e55c6d8bffc6ba398eef1107e5abb7ce.jpg" src="../images/1f10b5e59c03da97147d1e6f49132168e55c6d8bffc6ba398eef1107e5abb7ce.jpg" /></p>
<ul>
<li>
<p>图片展示了在不同空间区域大小（16 KB、4 KB、2 KB）下，使用不同数量的访问偏移量（offsets）作为触发条件时，预取器的 <strong>Accuracy</strong>（准确率）、<strong>Coverage</strong>（覆盖率）和 <strong>Timeliness</strong>（及时性）三者之间的权衡关系。</p>
</li>
<li>
<p>三个子图分别对应：</p>
<ul>
<li><strong>a) 16 KB-region</strong>：随着触发条件中包含的偏移量从 (PC,1 offset) 增加到 (PC,10 offsets)，<strong>Accuracy</strong> 从约50%显著上升至接近100%，而 <strong>Coverage</strong> 则从约50%持续下降至约20%，<strong>Timeliness</strong> 基本保持稳定在75%-80%区间。</li>
<li><strong>b) 4 KB-region</strong>：随着偏移量从 (PC,1 offset) 增加到 (PC,8 offsets)，<strong>Accuracy</strong> 从约65%上升至约95%，<strong>Coverage</strong> 从约60%下降至约25%，<strong>Timeliness</strong> 稍有下降但仍维持在75%左右。</li>
<li><strong>c) 2 KB-region</strong>：随着偏移量从 (PC,1 offset) 增加到 (PC,8 offsets)，<strong>Accuracy</strong> 从约65%上升至约95%，<strong>Coverage</strong> 从约60%下降至约25%，<strong>Timeliness</strong> 略有波动但基本稳定在70%以上。</li>
</ul>
</li>
<li>
<p>数据趋势总结如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>区域大小</th>
<th>Accuracy 趋势</th>
<th>Coverage 趋势</th>
<th>Timeliness 趋势</th>
</tr>
</thead>
<tbody>
<tr>
<td>16 KB</td>
<td><strong>显著上升</strong></td>
<td><strong>显著下降</strong></td>
<td>基本稳定</td>
</tr>
<tr>
<td>4 KB</td>
<td>上升</td>
<td>下降</td>
<td>略降</td>
</tr>
<tr>
<td>2 KB</td>
<td>上升</td>
<td>下降</td>
<td>基本稳定</td>
</tr>
</tbody>
</table>
<ul>
<li>核心结论：<ul>
<li>增加触发条件中的访问偏移量可有效提升 <strong>Accuracy</strong>，尤其在大区域（如16 KB）中效果显著，能将准确率从不足50%提升至90%以上。</li>
<li>代价是 <strong>Coverage</strong> 显著降低，因为更严格的触发条件导致更少的预取机会被激活。</li>
<li><strong>Timeliness</strong> 受影响较小，表明该机制主要影响预测是否发生，而非预测时机。</li>
<li>RICH设计据此采用差异化策略：对16 KB区域采用**(PC,5 offsets)<strong>以追求高精度，对4 KB区域采用</strong>(PC,3 offsets)<strong>平衡精度与覆盖，对2 KB区域保留</strong>(PC,1 offset)<strong>或</strong>(PC,address)**以最大化覆盖。</li>
</ul>
</li>
</ul>
<h3 id="24623341e46f13ed9c6004980d11054a104d928f1085abdd3d49c538fd7c2597jpg">24623341e46f13ed9c6004980d11054a104d928f1085abdd3d49c538fd7c2597.jpg<a class="headerlink" href="#24623341e46f13ed9c6004980d11054a104d928f1085abdd3d49c538fd7c2597jpg" title="Permanent link">&para;</a></h3>
<p><img alt="24623341e46f13ed9c6004980d11054a104d928f1085abdd3d49c538fd7c2597.jpg" src="../images/24623341e46f13ed9c6004980d11054a104d928f1085abdd3d49c538fd7c2597.jpg" /></p>
<ul>
<li>
<p>图片展示了 RICH 预取器在不同区域大小和触发机制下的 <strong>Accuracy</strong>（准确率）与 <strong>Coverage</strong>（覆盖率）对比，直观呈现了其多尺度设计的核心权衡策略。</p>
</li>
<li>
<p>数据以柱状图形式呈现，蓝色代表 Accuracy，橙色代表 Coverage，横轴为四种不同的预取配置：</p>
<ul>
<li>16 KB-region (PC, 5 offsets)</li>
<li>4 KB-region (PC, 3 offsets)</li>
<li>2 KB-region (PC, offset)</li>
<li>2 KB-region (PC, address)</li>
</ul>
</li>
<li>
<p>各配置性能数据如下表所示：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: left;">配置</th>
<th style="text-align: left;">Accuracy</th>
<th style="text-align: left;">Coverage</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">16 KB-region (PC, 5 offsets)</td>
<td style="text-align: left;"><strong>约 90%</strong></td>
<td style="text-align: left;"><strong>约 30%</strong></td>
</tr>
<tr>
<td style="text-align: left;">4 KB-region (PC, 3 offsets)</td>
<td style="text-align: left;"><strong>约 85%</strong></td>
<td style="text-align: left;"><strong>约 40%</strong></td>
</tr>
<tr>
<td style="text-align: left;">2 KB-region (PC, offset)</td>
<td style="text-align: left;"><strong>约 65%</strong></td>
<td style="text-align: left;"><strong>约 60%</strong></td>
</tr>
<tr>
<td style="text-align: left;">2 KB-region (PC, address)</td>
<td style="text-align: left;"><strong>约 90%</strong></td>
<td style="text-align: left;"><strong>约 10%</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>分析表明，RICH 的设计实现了明确的性能取舍：</p>
<ul>
<li><strong>大区域（16KB）</strong>：采用 (PC, 5 offsets) 触发，追求 <strong>高准确率</strong>（~90%），但牺牲了部分覆盖率（~30%），适用于对误预取代价敏感的场景。</li>
<li><strong>中区域（4KB）</strong>：采用 (PC, 3 offsets) 触发，在准确率（~85%）和覆盖率（~40%）之间取得平衡。</li>
<li><strong>小区域（2KB）</strong>：采用 (PC, offset) 触发，优先保证 <strong>高覆盖率</strong>（~60%），准确率相对较低（~65%），用于捕捉更广泛的访问模式。</li>
<li><strong>特殊小区域（2KB）</strong>：采用 (PC, address) 触发，其准确率与 16KB 区域相当（~90%），但覆盖率极低（~10%），因其触发条件苛刻（需精确地址匹配），主要用于特定高精度需求。</li>
</ul>
</li>
<li>
<p>此图表是 RICH 设计哲学的直接体现：通过 <strong>多级触发机制</strong> 和 <strong>区域仲裁策略</strong>，动态选择最优预取粒度，从而在整体上实现 <strong>高准确率、高覆盖率和高及时性</strong> 的协同优化。</p>
</li>
</ul>
<h3 id="figure-4-achieving-high-accuracy-in-large-spatial-regions-and-high-coverage-in-small-spatial-regions-by-using-different-numbers-of-trigger-offsets-figure-5-placing-16-kb-pht-off-chip-keeps-most-prefetch-opportunities-even-with-additional-memory-access-latency">Figure 4: Achieving high accuracy in large spatial regions and high coverage in small spatial regions by using different numbers of trigger offsets Figure 5: Placing 16 KB PHT off-chip keeps most prefetch opportunities, even with additional memory access latency<a class="headerlink" href="#figure-4-achieving-high-accuracy-in-large-spatial-regions-and-high-coverage-in-small-spatial-regions-by-using-different-numbers-of-trigger-offsets-figure-5-placing-16-kb-pht-off-chip-keeps-most-prefetch-opportunities-even-with-additional-memory-access-latency" title="Permanent link">&para;</a></h3>
<p><img alt="8a2bbe0f30407dfa37e775c401d9144a90a7e78df58cfb7eabcdb2ec24266775.jpg" src="../images/8a2bbe0f30407dfa37e775c401d9144a90a7e78df58cfb7eabcdb2ec24266775.jpg" /></p>
<ul>
<li>图表标题为 <strong>Figure 5</strong>，其核心结论是：将 <strong>16 KB PHT</strong> 放置在片外（off-chip）仍能保留大部分预取机会，即使存在额外的内存访问延迟。</li>
<li>横轴表示 <strong>Additional Memory Access Latency</strong>，从 0 ns 到 50 ns，以 10 ns 为步长递增，模拟未来高延迟内存系统场景。</li>
<li>纵轴表示 <strong>Late Prefetches</strong>，即“迟到预取”的比例，范围从 5% 到 20%，衡量因元数据加载延迟导致预取请求未能及时完成的比例。</li>
<li>数据趋势显示，随着额外延迟增加，<strong>Late Prefetches</strong> 比例呈缓慢上升趋势：<ul>
<li>在 0 ns 延迟时，约为 <strong>11%</strong>。</li>
<li>在 50 ns 延迟时，上升至约 <strong>15%</strong>。</li>
</ul>
</li>
<li>这表明即使引入高达 50 ns 的额外延迟，<strong>RICH prefetcher</strong> 仍能维持超过 <strong>85%</strong> 的预取机会未被浪费，验证了其对延迟的容忍能力。</li>
<li>此设计策略有效平衡了 <strong>on-chip area overhead</strong> 与 <strong>off-chip latency penalty</strong>，通过将大区域模式（16 KB-region patterns）卸载到主存，显著节省芯片面积，同时性能损失可控。</li>
<li>该结果支撑论文中提出的 <strong>hierarchical storage design</strong>，即高频模式保留在片上缓存，低频模式存储于片外，实现成本与性能的最优折衷。</li>
</ul>
<table>
<thead>
<tr>
<th>Additional Memory Access Latency</th>
<th>Late Prefetches (%)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 ns</td>
<td>~11%</td>
</tr>
<tr>
<td>10 ns</td>
<td>~12%</td>
</tr>
<tr>
<td>20 ns</td>
<td>~12.5%</td>
</tr>
<tr>
<td>30 ns</td>
<td>~13.5%</td>
</tr>
<tr>
<td>40 ns</td>
<td>~14%</td>
</tr>
<tr>
<td>50 ns</td>
<td>~15%</td>
</tr>
</tbody>
</table>
<h3 id="table-2-categorization-of-richs-metadata">Table 2: Categorization of RICH's metadata<a class="headerlink" href="#table-2-categorization-of-richs-metadata" title="Permanent link">&para;</a></h3>
<p><img alt="caca357af3f3213087919d97821353c5fd143706cce1834eabdabd91fa574906.jpg" src="../images/caca357af3f3213087919d97821353c5fd143706cce1834eabdabd91fa574906.jpg" /></p>
<ul>
<li>
<p><strong>Table 2</strong> 对 RICH prefetcher 的元数据进行了系统性分类，依据三个核心维度：<strong>Area overheads</strong>、<strong>Access frequency</strong> 和 <strong>Latency tolerance</strong>，并据此决定其存储位置（on-chip/off-chip）。</p>
</li>
<li>
<p>元数据被划分为四类：</p>
<ul>
<li><strong>Large region’s patterns</strong> (16 KB-region)</li>
<li><strong>Small region’s patterns</strong> (4 KB &amp; 2 KB-region)</li>
<li><strong>Training metadata</strong></li>
<li><strong>Control metadata</strong></li>
</ul>
</li>
<li>
<p>各类元数据的特性与 RICH 的决策如下表所示：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>元数据类别</th>
<th>Area overheads</th>
<th>Access frequency</th>
<th>Latency tolerance</th>
<th>RICH’s structures</th>
<th>RICH’s decision</th>
</tr>
</thead>
<tbody>
<tr>
<td>Large region’s patterns</td>
<td><strong>high (&gt; 100 KB)</strong></td>
<td>mixed</td>
<td><strong>high</strong></td>
<td>16 KB-region PHT Cache, 16 KB-region PHT</td>
<td>Frequently accessed: <strong>on-chip</strong><br>Infrequently accessed: <strong>off-chip</strong></td>
</tr>
<tr>
<td>Small region’s patterns</td>
<td>medium (~30 KB)</td>
<td>mixed</td>
<td>low</td>
<td>4 KB-region PHT, 2 KB-region PHT</td>
<td><strong>on-chip</strong></td>
</tr>
<tr>
<td>Training metadata</td>
<td>low (&lt; 10 KB)</td>
<td><strong>high</strong></td>
<td>low</td>
<td>FTs, ATs</td>
<td><strong>on-chip</strong></td>
</tr>
<tr>
<td>Control metadata</td>
<td>low (&lt; 10 KB)</td>
<td><strong>high</strong></td>
<td>low</td>
<td>Inflight Prefetch Table, 16 KB-region Valid Map</td>
<td><strong>on-chip</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>关键设计洞察：<ul>
<li><strong>大区域模式</strong>因面积开销巨大且对延迟容忍度高，采用<strong>分层存储</strong>：高频访问部分缓存在片上（PHT Cache），低频部分卸载至片外主存，以平衡性能与成本。</li>
<li><strong>小区域模式</strong>、<strong>训练元数据</strong>和<strong>控制元数据</strong>均因访问频率高或对延迟敏感，被强制部署在<strong>片上</strong>，确保快速响应。</li>
<li>此分类策略是 RICH 实现“用容量和带宽换延迟隐藏”核心思想的关键支撑，有效规避了传统预取器受限于片上资源的瓶颈。</li>
</ul>
</li>
</ul>
<h3 id="table-3-cover-ratio-under-a-2oo-entry-storage-constraint-of-16-kb-region-patterns">Table 3: Cover ratio under a 2oo-entry storage constraint of 16 KB-region patterns<a class="headerlink" href="#table-3-cover-ratio-under-a-2oo-entry-storage-constraint-of-16-kb-region-patterns" title="Permanent link">&para;</a></h3>
<p><img alt="d417f552a078a504ce1cacd72bd72cd0368bfab1846fdf206b707c34f0b9c683.jpg" src="../images/d417f552a078a504ce1cacd72bd72cd0368bfab1846fdf206b707c34f0b9c683.jpg" /></p>
<ul>
<li>该图片为论文中的 <strong>Table 3</strong>，标题为 “Cover ratio under a 200-entry storage constraint of 16 KB-region patterns”，用于评估在仅保留 <strong>200个条目</strong> 的存储限制下，RICH prefetcher 对 <strong>16 KB-region patterns</strong> 的覆盖能力。</li>
<li>表格展示了8个代表性工作负载（traces）的覆盖比例（% Covered），这些工作负载在使用16 KB区域预取时能获得显著性能收益。</li>
<li>数据表明，在有限的200个条目缓存容量下，RICH仍能对多数工作负载实现高覆盖率，验证了其 <strong>分层存储策略</strong> 的有效性。</li>
</ul>
<table>
<thead>
<tr>
<th>Trace</th>
<th>% Covered</th>
</tr>
</thead>
<tbody>
<tr>
<td>bwaves-891</td>
<td><strong>100.0%</strong></td>
</tr>
<tr>
<td>gcc-1850</td>
<td><strong>93.7%</strong></td>
</tr>
<tr>
<td>mcf-782</td>
<td><strong>90.4%</strong></td>
</tr>
<tr>
<td>mcf-1152</td>
<td><strong>86.7%</strong></td>
</tr>
<tr>
<td>bwaves-2609</td>
<td><strong>80.5%</strong></td>
</tr>
<tr>
<td>fotonik3d-7084</td>
<td><strong>66.9%</strong></td>
</tr>
<tr>
<td>roms-1070</td>
<td><strong>38.7%</strong></td>
</tr>
<tr>
<td>roms-294</td>
<td><strong>32.8%</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>覆盖率最高的工作负载是 <strong>bwaves-891</strong>，达到 <strong>100%</strong>，说明其16 KB区域访问模式高度集中，少量高频模式即可完全覆盖。</li>
<li>覆盖率最低的是 <strong>roms-294</strong> 和 <strong>roms-1070</strong>，分别为 <strong>32.8%</strong> 和 <strong>38.7%</strong>，表明这些工作负载的访问模式更分散，需要更多条目才能有效覆盖。</li>
<li>此结果支持论文中提出的观点：16 KB区域模式具有 <strong>混合频率分布</strong>，因此采用 <strong>分层存储</strong>（高频模式放片上缓存，低频模式放片外内存）是合理且高效的。</li>
</ul>
<h3 id="figure-6-architecture-of-rich">Figure 6: Architecture of RICH<a class="headerlink" href="#figure-6-architecture-of-rich" title="Permanent link">&para;</a></h3>
<p><img alt="6e338dab1c2f2dec78cf49ff7a45c67ddb5f075d83e56eb99f94a5a78cca2ac0.jpg" src="../images/6e338dab1c2f2dec78cf49ff7a45c67ddb5f075d83e56eb99f94a5a78cca2ac0.jpg" /></p>
<ul>
<li>图片展示了 <strong>RICH Prefetcher</strong> 的完整架构，分为 <strong>On-chip</strong> 和 <strong>Off-chip</strong> 两大模块，通过清晰的数据流和控制流连接。</li>
<li><strong>On-chip 部分</strong> 包含三个核心组件：<strong>Training Unit</strong>、<strong>Pattern Storage</strong>（即 PHTs）和 <strong>Prediction Unit</strong>，并辅以 <strong>Region Arbitration</strong> 和 <strong>Control Units</strong>。</li>
<li><strong>Training Unit</strong> 负责从 L2 cache miss/hit 事件中捕获访问模式，为 16 KB、4 KB 和 2 KB 三个区域分别维护 <strong>Filter Table (FT)</strong> 和 <strong>Accumulation Table (AT)</strong>，用于过滤噪声并累积位向量模式。</li>
<li><strong>Pattern Storage</strong> 中，2 KB 和 4 KB 区域的 <strong>PHT</strong> 完全驻留在芯片上；而 16 KB 区域采用 <strong>分层设计</strong>，仅保留一个小型 <strong>PHT Cache</strong> 在片上，作为主存中完整 <strong>16 KB-region PHT</strong> 的缓存。</li>
<li><strong>Prediction Unit</strong> 是触发预测的核心，包含三个 <strong>Lookup Units</strong>，分别对应不同区域大小。它们根据 (PC, address) 或 (PC, offsets) 等触发条件查询对应的 PHT。</li>
<li><strong>Region Arbitration</strong> 单元负责解决多区域同时触发时的优先级问题，并与 <strong>Inflight Prefetch Table</strong> 协作，避免对同一内存空间的重复或重叠预取。</li>
<li><strong>Control Units</strong> 专门管理 16 KB 区域的元数据读写，包括与 <strong>Valid Map</strong> 单元协同判断离线模式是否存在，以及异步发起对主存的元数据加载请求。</li>
<li><strong>Off-chip 部分</strong> 主要由 <strong>Main Memory</strong> 构成，其中存储了完整的 <strong>16 KB-region PHT</strong> 数组。当片上缓存未命中且 Valid Map 标记有效时，会触发对主存的访问。</li>
<li>数据流向明确：L2 cache 的访问事件驱动 Training Unit 和 Lookup Units；Prediction Unit 的输出经 Region Arbitration 后进入 <strong>Prefetch Buffer</strong>，再通过 <strong>TLB</strong> 发送至 <strong>LLC</strong> 和 <strong>Main Memory</strong>。</li>
<li>整体架构体现了 <strong>“用容量和带宽换延迟”</strong> 的设计理念，将大量不常访问的 16 KB 模式卸载到主存，同时利用片上高速缓存保证关键路径的低延迟。</li>
<li>关键术语如 <strong>PHT</strong>, <strong>FT</strong>, <strong>AT</strong>, <strong>TLB</strong>, <strong>LLC</strong>, <strong>Valid Map</strong>, <strong>Inflight Prefetch Table</strong> 均在图中清晰标注，符合论文描述。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: left;">组件名称</th>
<th style="text-align: left;">所属模块</th>
<th style="text-align: left;">功能简述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Training Unit</td>
<td style="text-align: left;">On-chip</td>
<td style="text-align: left;">从 L2 访问事件中学习并构建各区域的位向量模式。</td>
</tr>
<tr>
<td style="text-align: left;">16 KB-region PHT Cache</td>
<td style="text-align: left;">On-chip</td>
<td style="text-align: left;">片上缓存，存储高频访问的 16 KB 区域模式。</td>
</tr>
<tr>
<td style="text-align: left;">4 KB-region PHT / 2 KB-region PHT</td>
<td style="text-align: left;">On-chip</td>
<td style="text-align: left;">存储对应区域的访问模式，完全驻留片上。</td>
</tr>
<tr>
<td style="text-align: left;">Lookup Units</td>
<td style="text-align: left;">On-chip</td>
<td style="text-align: left;">根据触发条件查询 PHT，生成预取请求。</td>
</tr>
<tr>
<td style="text-align: left;">Region Arbitration</td>
<td style="text-align: left;">On-chip</td>
<td style="text-align: left;">解决多区域冲突，选择最优预取方案。</td>
</tr>
<tr>
<td style="text-align: left;">Inflight Prefetch Table</td>
<td style="text-align: left;">On-chip</td>
<td style="text-align: left;">记录正在进行的预取，防止重叠。</td>
</tr>
<tr>
<td style="text-align: left;">16 KB-region Control</td>
<td style="text-align: left;">On-chip</td>
<td style="text-align: left;">管理 16 KB 区域元数据的离线读写。</td>
</tr>
<tr>
<td style="text-align: left;">Valid Map</td>
<td style="text-align: left;">On-chip</td>
<td style="text-align: left;">标记主存中哪些 16 KB 模式是有效的。</td>
</tr>
<tr>
<td style="text-align: left;">16 KB-region PHT (Main Memory)</td>
<td style="text-align: left;">Off-chip</td>
<td style="text-align: left;">存储所有 16 KB 区域模式的主数组。</td>
</tr>
<tr>
<td style="text-align: left;">Prefetch Buffer</td>
<td style="text-align: left;">On-chip</td>
<td style="text-align: left;">缓冲待发出的预取流。</td>
</tr>
<tr>
<td style="text-align: left;">TLB</td>
<td style="text-align: left;">On-chip</td>
<td style="text-align: left;">处理虚拟地址到物理地址的转换。</td>
</tr>
<tr>
<td style="text-align: left;">LLC / Main Memory</td>
<td style="text-align: left;">Off-chip</td>
<td style="text-align: left;">最终执行预取操作的目标存储层级。</td>
</tr>
</tbody>
</table>
<h3 id="figure-7-training-process-of-each-region">Figure 7: Training process of each region<a class="headerlink" href="#figure-7-training-process-of-each-region" title="Permanent link">&para;</a></h3>
<p><img alt="c49cb9eed60e1589e32c457860160eb03726c6dd85d44f26a30a787f94f2b35d.jpg" src="../images/c49cb9eed60e1589e32c457860160eb03726c6dd85d44f26a30a787f94f2b35d.jpg" /></p>
<ul>
<li>
<p>图片展示了 RICH 预取器中每个区域（2KB、4KB、16KB）的<strong>训练过程</strong>，核心机制基于 <strong>Filter Table (FT)</strong> 和 <strong>Accumulation Table (AT)</strong> 两个表协同工作。</p>
</li>
<li>
<p>训练流程以一个 (PC, 2 offsets) 触发器为例，图中用编号 (1) 到 (5) 标示了关键步骤：</p>
<ul>
<li><strong>(1) 初始访问 P+3</strong>：当程序首次访问某个区域内的偏移量 3 时，该信息被记录在 FT 中，但此时不启动模式学习。</li>
<li><strong>(2) 第二次访问 P+1</strong>：后续访问偏移量 1，FT 再次记录。此时系统仍处于“过滤”阶段，等待更多不同偏移量来确认访问模式的有效性。</li>
<li><strong>(3) 第三次访问 P+2</strong>：当观察到第三个不同的偏移量（此处为 2）时，FT 条目被“提升”至 AT。AT 初始化一个位向量（Pattern），并开始记录所有已访问的偏移量。</li>
<li><strong>(4) 后续访问 P+4</strong>：随着更多访问发生（如偏移量 4），AT 持续更新其位向量，将新访问的偏移位置位（例如，从 <code>001110</code> 更新为 <code>011110</code>）。</li>
<li><strong>(5) 区域驱逐</strong>：当该区域被 L2 缓存驱逐或 AT 达到容量上限时，最终形成的完整模式会被传输至 <strong>Pattern History Table (PHT)</strong> 用于后续预测。</li>
</ul>
</li>
<li>
<p>下表总结了 FT 和 AT 在各步骤中的状态变化：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>步骤</th>
<th>Filter Table (FT) 状态</th>
<th>Accumulation Table (AT) 状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>(1)</td>
<td>记录 PC 和偏移量 3</td>
<td>无条目</td>
</tr>
<tr>
<td>(2)</td>
<td>记录 PC 和偏移量 3、1</td>
<td>无条目</td>
</tr>
<tr>
<td>(3)</td>
<td>将 PC/3,1 条目提升至 AT</td>
<td>创建新条目，Tag=P，Trigger=PC/3,1，Pattern=001110</td>
</tr>
<tr>
<td>(4)</td>
<td>保持不变</td>
<td>更新 Pattern 为 011110</td>
</tr>
<tr>
<td>(5)</td>
<td>保持不变</td>
<td>将最终 Pattern 传输至 PHT</td>
</tr>
</tbody>
</table>
<ul>
<li>关键设计点：<ul>
<li><strong>多偏移触发机制</strong>：通过要求至少观察到多个不同偏移量（如 2 或 5 个），有效过滤掉噪声访问，确保只有稳定的空间局部性模式才被学习。</li>
<li><strong>分阶段学习</strong>：FT 负责初步筛选，AT 负责精确建模，这种分离设计降低了硬件复杂度和误学习风险。</li>
<li><strong>LRU 替换策略</strong>：三个区域的 PHT 均采用 LRU 策略管理条目，保证常用模式优先保留。</li>
<li><strong>触发器定义</strong>：触发器由程序计数器 (PC) 和一组偏移量组成，是识别特定访问模式的关键标识符。</li>
</ul>
</li>
</ul>
<h3 id="figure-8-the-region-arbitration-unit-selects-the-appropriate-region-to-prefetch-step-p3">Figure 8: The Region Arbitration unit selects the appropriate region to prefetch (Step P3)<a class="headerlink" href="#figure-8-the-region-arbitration-unit-selects-the-appropriate-region-to-prefetch-step-p3" title="Permanent link">&para;</a></h3>
<p><img alt="e7db11d6666a6329d6f2f885db1cc278ea284b557d2571e2444b5f024a5d2ead.jpg" src="../images/e7db11d6666a6329d6f2f885db1cc278ea284b557d2571e2444b5f024a5d2ead.jpg" /></p>
<ul>
<li>
<p><strong>Region Arbitration</strong> 单元负责在多个可能触发的预取区域中选择最优的一个，以避免重复或冲突的预取操作。</p>
</li>
<li>
<p>该单元接收来自 <strong>2KB、4KB 和 16KB PHTs</strong> 的查找命中信号作为输入，启动优先级仲裁流程。</p>
</li>
<li>
<p><strong>Priority Selection</strong> 模块根据预定义的优先级顺序决定哪个区域应被选中：</p>
<ul>
<li>最高优先级：<strong>2KB by (PC, address)</strong></li>
<li>其次：<strong>16KB</strong></li>
<li>再次：<strong>4KB</strong></li>
<li>最低：<strong>2KB by (PC, offset)</strong></li>
</ul>
</li>
<li>
<p>选定区域后，系统会检查其是否与任何<strong>更高优先级的 Inflight Prefetch Region</strong> 存在重叠：</p>
<ul>
<li>若存在重叠（Y），则当前请求被 <strong>Ignored</strong>，防止冗余预取。</li>
<li>若无重叠（N），则允许生成预取请求并送入 <strong>Prefetch Buffer</strong>。</li>
</ul>
</li>
<li>
<p><strong>Inflight Prefetch Table</strong> 用于跟踪当前正在执行的预取任务，包含以下字段：</p>
<table>
<thead>
<tr>
<th>Region number</th>
<th>Number of prefetches left</th>
<th>Region type</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x70</td>
<td>15</td>
<td>2KB by (PC, address)</td>
</tr>
<tr>
<td>0x60</td>
<td>64</td>
<td>16KB</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>表格中的条目会随着预取进度动态更新，当 “Number of prefetches left” 归零时，对应条目被移除。</p>
</li>
<li>
<p>此机制确保了预取行为既高效又不浪费带宽，尤其在多尺度区域同时活跃时，能有效协调资源分配。</p>
</li>
</ul>
<h3 id="table-4-breakdown-of-on-chip-storage-overheads">Table 4: Breakdown of on-chip storage overheads<a class="headerlink" href="#table-4-breakdown-of-on-chip-storage-overheads" title="Permanent link">&para;</a></h3>
<p><img alt="aaf6a2c49ab61c4dae46cc589d72aba6cc85e21d45cac2fc2ee3ba31749afe78.jpg" src="../images/aaf6a2c49ab61c4dae46cc589d72aba6cc85e21d45cac2fc2ee3ba31749afe78.jpg" /></p>
<ul>
<li><strong>Table 4</strong> 详细列出了 RICH prefetcher 的片上存储开销分解，涵盖多个核心组件的位宽、条目数和总存储容量。</li>
<li>各结构的存储开销如下表所示：</li>
</ul>
<table>
<thead>
<tr>
<th>Structure</th>
<th>Width (bits)</th>
<th>Size (entries)</th>
<th>Storage (KB)</th>
</tr>
</thead>
<tbody>
<tr>
<td>FTs (2, 4, 16 KB)</td>
<td>64, 64, 90</td>
<td>64, 64, 64</td>
<td>1.7</td>
</tr>
<tr>
<td>ATs (2, 4, 16 KB)</td>
<td>91, 106, 312</td>
<td>128, 128, 32</td>
<td>4.3</td>
</tr>
<tr>
<td>PHTs (2, 4 KB)</td>
<td>43, 71</td>
<td>4096, 1024</td>
<td>30.4</td>
</tr>
<tr>
<td>16 KB-region PHT Cache</td>
<td>271</td>
<td>256</td>
<td>8.5</td>
</tr>
<tr>
<td>Inflight Prefetch Table</td>
<td>48</td>
<td>6</td>
<td>0.05</td>
</tr>
<tr>
<td>16 KB-region Valid Map</td>
<td>1</td>
<td>4096</td>
<td>0.5</td>
</tr>
<tr>
<td>Prefetch Buffer</td>
<td>48</td>
<td>320</td>
<td>1.9</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td>—</td>
<td>—</td>
<td><strong>47.3</strong></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>FTs (Filter Tables)</strong>：用于过滤噪声模式，针对 2 KB、4 KB 和 16 KB 区域分别配置，总占用 <strong>1.7 KB</strong>。</li>
<li><strong>ATs (Accumulation Tables)</strong>：用于累积访问足迹以构建预取模式，其位宽随区域增大而增加，总占用 <strong>4.3 KB</strong>。</li>
<li><strong>PHTs (Pattern History Tables)</strong>：存储学习到的访问模式，2 KB 和 4 KB 区域的 PHT 占用 <strong>30.4 KB</strong>，是主要开销来源。</li>
<li><strong>16 KB-region PHT Cache</strong>：作为片上缓存，仅保留高频模式，256 条目占用 <strong>8.5 KB</strong>。</li>
<li><strong>Inflight Prefetch Table</strong>：追踪正在进行的预取请求，6 条目仅占 <strong>0.05 KB</strong>。</li>
<li><strong>16 KB-region Valid Map</strong>：标记哪些 16 KB 模式存在于片外，4096 位（即 512 字节）占用 <strong>0.5 KB</strong>。</li>
<li><strong>Prefetch Buffer</strong>：缓冲预取请求，320 条目占用 <strong>1.9 KB</strong>。</li>
<li>总体来看，RICH 的片上存储开销为 <strong>47.3 KB</strong>，显著低于 Bingo 的 127 KB，体现了其在面积效率上的优势。</li>
</ul>
<h3 id="table-5-simulated-system">Table 5: Simulated system<a class="headerlink" href="#table-5-simulated-system" title="Permanent link">&para;</a></h3>
<p><img alt="73c48b90f5023bb454bfcb01a1da86144aceb0984be2c4bb5a7d33e2bf5e8ab6.jpg" src="../images/73c48b90f5023bb454bfcb01a1da86144aceb0984be2c4bb5a7d33e2bf5e8ab6.jpg" /></p>
<ul>
<li>
<p>该表格详细列出了论文中用于评估 RICH prefetcher 的模拟系统配置，涵盖了从核心微架构到主存的各个层级。</p>
</li>
<li>
<p>核心（Core）部分描述了处理器的前端和执行单元：</p>
<ul>
<li><strong>8-wide fetch</strong> 和 <strong>6-wide decode/dispatch</strong> 表明其具备宽发射能力。</li>
<li>拥有 <strong>512-entry ROB</strong>（Reorder Buffer）和 <strong>192/114-entry LQ/SQ</strong>（Load/Store Queue），支持大量乱序指令。</li>
<li>采用 <strong>Perceptron branch predictor</strong>，并设定 <strong>17-cycle misprediction penalty</strong>，反映其分支预测机制及惩罚开销。</li>
</ul>
</li>
<li>
<p>一级缓存（L1 Cache）分为指令缓存（L1-I）和数据缓存（L1-D）：</p>
<ul>
<li><strong>L1-I Cache</strong>：私有，容量为 <strong>32KB</strong>，组织方式为 <strong>8-way set associative</strong>，行大小 <strong>64B</strong>，往返延迟 <strong>4 cycles</strong>，拥有 <strong>8 MSHRs</strong>（Miss Status Holding Registers）。</li>
<li><strong>L1-D Cache</strong>：私有，容量为 <strong>48KB</strong>，组织方式为 <strong>12-way set associative</strong>，行大小 <strong>64B</strong>，往返延迟 <strong>5 cycles</strong>，拥有 <strong>16 MSHRs</strong>。</li>
</ul>
</li>
<li>
<p>二级缓存（L2 Cache）配置如下：</p>
<ul>
<li>私有，容量为 <strong>1.25MB</strong>，组织方式为 <strong>20-way set associative</strong>，行大小 <strong>64B</strong>，往返延迟 <strong>15 cycles</strong>，拥有 <strong>48 MSHRs</strong>。</li>
</ul>
</li>
<li>
<p>最后一级缓存（LLC, Last Level Cache）：</p>
<ul>
<li>容量为 <strong>3MB/core</strong>，组织方式为 <strong>12-way set associative</strong>，行大小 <strong>64B</strong>，往返延迟 <strong>55 cycles</strong>，拥有 <strong>64 MSHRs</strong>。</li>
</ul>
</li>
<li>
<p>主存（Main Memory）配置根据通道数不同而异：</p>
<ul>
<li><strong>1C (Single Channel)</strong>：单通道，每通道 <strong>1 rank</strong>。</li>
<li><strong>4C (Dual Channel)</strong>：双通道，每通道 <strong>2 ranks</strong>。</li>
<li>使用 <strong>DDR5-4800 MTPS</strong> 内存标准，每通道数据总线宽度为 <strong>64-bit</strong>。</li>
<li>关键时序参数：<strong>tRCD = tRP = tCAS = 16.6ns</strong>，这些参数直接影响内存访问延迟。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>组件</th>
<th>配置详情</th>
</tr>
</thead>
<tbody>
<tr>
<td>Core</td>
<td>8-wide fetch, 6-wide decode/dispatch, 512-entry ROB, 192/114-entry LQ/SQ, Perceptron branch predictor with 17-cycle misprediction penalty</td>
</tr>
<tr>
<td>L1-I Cache</td>
<td>Private, 32KB (8-way, 64B line), 4-cycle round-trip latency, 8 MSHRs</td>
</tr>
<tr>
<td>L1-D Cache</td>
<td>Private, 48KB (12-way, 64B line), 5-cycle round-trip latency, 16 MSHRs</td>
</tr>
<tr>
<td>L2 Cache</td>
<td>Private, 1.25MB (20-way, 64B line), 15-cycle round-trip latency, 48 MSHRs</td>
</tr>
<tr>
<td>LLC</td>
<td>3MB/core (12-way, 64B line), 55-cycle round-trip latency, 64 MSHRs</td>
</tr>
<tr>
<td>Main Memory</td>
<td>1C: Single channel, 1 rank/channel; 4C: Dual channel, 2 ranks/channel. DDR5-4800 MTPS, 64-bit data bus per channel, tRCD=tRP=tCAS=16.6ns</td>
</tr>
</tbody>
</table>
<ul>
<li>整体来看，该模拟系统基于现代高性能处理器设计，特别是参考了 Intel Alder Lake 的性能核心（P-Core）架构，旨在真实反映当前主流硬件环境下的 prefetcher 性能表现。</li>
</ul>
<h3 id="table-6-comparison-of-area-overheads">Table 6: Comparison of area overheads<a class="headerlink" href="#table-6-comparison-of-area-overheads" title="Permanent link">&para;</a></h3>
<p><img alt="7fcf1667bbe6763eba48297e6be4a6523d2772cc0bdf46a4d54a203e974be30c.jpg" src="../images/7fcf1667bbe6763eba48297e6be4a6523d2772cc0bdf46a4d54a203e974be30c.jpg" /></p>
<ul>
<li>该图片为论文中的 <strong>Table 6: Comparison of area overheads</strong>，用于对比不同硬件预取器（prefetcher）的存储开销。</li>
<li>表格横向列出五种预取器：<strong>Bingo</strong>、<strong>PMP</strong>、<strong>SPP-PPF</strong>、<strong>SMS</strong> 和 <strong>RICH</strong>。</li>
<li>各预取器对应的面积开销如下：</li>
</ul>
<table>
<thead>
<tr>
<th>Prefetcher</th>
<th>Area Overhead</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bingo</td>
<td><strong>127.8 KB</strong></td>
</tr>
<tr>
<td>PMP</td>
<td><strong>4.3 KB</strong></td>
</tr>
<tr>
<td>SPP-PPF</td>
<td><strong>48.4 KB</strong></td>
</tr>
<tr>
<td>SMS</td>
<td><strong>116.6 KB</strong></td>
</tr>
<tr>
<td>RICH</td>
<td><strong>47.3 KB on-chip, 128 KB off-chip</strong></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>RICH</strong> 的设计采用分层存储策略：将高频访问模式保留在片上（on-chip），低频模式卸载至片外主存（off-chip），从而在控制总开销的同时提升性能。</li>
<li>相较于 <strong>Bingo</strong> 和 <strong>SMS</strong> 等传统预取器，<strong>RICH</strong> 的片上开销显著降低（从 127.8 KB / 116.6 KB 降至 47.3 KB），但通过引入 128 KB 片外存储换取更丰富的元数据支持。</li>
<li><strong>PMP</strong> 虽然片上开销最小（仅 4.3 KB），但其覆盖度和及时性受限，性能不及 RICH。</li>
<li><strong>SPP-PPF</strong> 开销居中（48.4 KB），但其基于 delta 序列的机制在高带宽场景下扩展性不足。</li>
<li>此表凸显 <strong>RICH</strong> 在“性能-开销”权衡上的创新：以可控的片外存储代价，换取更优的预取准确率与覆盖范围。</li>
</ul>
<h3 id="table-7-workloads-used-for-evaluation">Table 7: Workloads used for evaluation<a class="headerlink" href="#table-7-workloads-used-for-evaluation" title="Permanent link">&para;</a></h3>
<p><img alt="44f3ca35b8e8f55a514b51b92d9b785c63387bd17862f52b9348461a1c2b809e.jpg" src="../images/44f3ca35b8e8f55a514b51b92d9b785c63387bd17862f52b9348461a1c2b809e.jpg" /></p>
<ul>
<li>该图片为论文中的 <strong>Table 7</strong>，标题为 “Workloads used for evaluation”，用于说明实验所使用的基准测试集构成。</li>
<li>表格包含三列：<strong>Suite</strong>（测试套件）、<strong>Count</strong>（工作负载数量）、<strong>Example workloads</strong>（示例工作负载）。</li>
<li>具体数据如下：</li>
</ul>
<table>
<thead>
<tr>
<th>Suite</th>
<th>Count</th>
<th>Example workloads</th>
</tr>
</thead>
<tbody>
<tr>
<td>SPEC06</td>
<td>46</td>
<td>gcc, bwaves, mcf, leslie3d, GemsFDTD</td>
</tr>
<tr>
<td>SPEC17</td>
<td>42</td>
<td>gcc, bwaves, mcf, cactuBSSN, lbm</td>
</tr>
<tr>
<td>Ligra</td>
<td>40</td>
<td>Bellman-ford, Triangle, Radii, PageRank</td>
</tr>
<tr>
<td>Parsec</td>
<td>12</td>
<td>canneal, fluidanimate, streamcluster</td>
</tr>
</tbody>
</table>
<ul>
<li>所有工作负载均来自主流基准测试集，包括 <strong>SPEC CPU 2006</strong>、<strong>SPEC CPU 2017</strong>、<strong>Ligra</strong> 和 <strong>Parsec</strong>。</li>
<li>实验中排除了 L2 缓存每千条指令缺失率（MPKI）低于 2 的工作负载，因其受内存延迟影响较小。</li>
<li>总计使用 <strong>140+</strong> 个 trace 进行单核性能评估，涵盖计算密集型、图处理和多线程应用等多种场景。</li>
</ul>
<h3 id="figure-9-rich-outperforms-bingo-across-four-benchmark-suites-on-a-single-core-system">Figure 9: RICH outperforms Bingo across four benchmark suites on a single-core system<a class="headerlink" href="#figure-9-rich-outperforms-bingo-across-four-benchmark-suites-on-a-single-core-system" title="Permanent link">&para;</a></h3>
<p><img alt="2b43f5f74c77eb76c70d8867a4b404e979bc2570e215062844e1bdbfc8cee89a.jpg" src="../images/2b43f5f74c77eb76c70d8867a4b404e979bc2570e215062844e1bdbfc8cee89a.jpg" /></p>
<ul>
<li>图片展示了在单核系统下，RICH 预取器与其他四种预取器（SPP-PPF、SMS、Bingo、PMP）在四个基准测试套件（SPEC17、SPEC06、Ligra、Parsec）上的性能对比，以“无预取”为基准（1.0），衡量各预取器带来的加速比。</li>
<li><strong>RICH 在所有四个基准套件中均取得最高加速比</strong>，验证了其设计在多类工作负载下的普适性优势。</li>
<li>各基准套件具体表现如下：</li>
</ul>
<table>
<thead>
<tr>
<th>基准套件</th>
<th>SPP-PPF</th>
<th>SMS</th>
<th>Bingo</th>
<th>PMP</th>
<th>RICH</th>
</tr>
</thead>
<tbody>
<tr>
<td>SPEC17</td>
<td>~1.15</td>
<td>~1.20</td>
<td>~1.20</td>
<td>~1.22</td>
<td><strong>~1.28</strong></td>
</tr>
<tr>
<td>SPEC06</td>
<td>~1.40</td>
<td>~1.48</td>
<td>~1.45</td>
<td>~1.48</td>
<td><strong>~1.55</strong></td>
</tr>
<tr>
<td>Ligra</td>
<td>~1.35</td>
<td>~1.38</td>
<td>~1.38</td>
<td>~1.39</td>
<td><strong>~1.43</strong></td>
</tr>
<tr>
<td>Parsec</td>
<td>~1.05</td>
<td>~1.08</td>
<td>~1.07</td>
<td>~1.08</td>
<td><strong>~1.10</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>在 <strong>GEOMEAN（几何平均）</strong> 汇总指标上，RICH 达到约 <strong>1.40</strong>，显著领先于 Bingo（~1.35）和 PMP（~1.36），表明其综合性能最优。</li>
<li>从图中可见，<strong>Bingo 和 PMP 性能接近</strong>，但 RICH 始终超越二者；SPP-PPF 在 SPEC06 上表现突出，但在其他套件中相对落后。</li>
<li>此图直接支持论文核心结论：RICH 在单核环境下平均优于 Bingo <strong>3.4%</strong>，体现了其多区域、多触发机制在实际负载中的有效性。</li>
</ul>
<h3 id="figure-10-rich-improves-coverage-and-timeliness-while-maintaining-comparable-accuracy">Figure 10: RICH improves coverage and timeliness while maintaining comparable accuracy<a class="headerlink" href="#figure-10-rich-improves-coverage-and-timeliness-while-maintaining-comparable-accuracy" title="Permanent link">&para;</a></h3>
<p><img alt="ea6cb47571db4912102c6d7d95ce78ada61a7820c3f3c835589744805aeb2767.jpg" src="../images/ea6cb47571db4912102c6d7d95ce78ada61a7820c3f3c835589744805aeb2767.jpg" /></p>
<ul>
<li>图表标题为“Figure 10: RICH improves coverage and timeliness while maintaining comparable accuracy”，旨在对比 RICH 与其他主流 prefetcher 在 Accuracy、Coverage 和 Timeliness 三个核心指标上的表现。</li>
<li>图表横轴为三项性能指标：Accuracy、Coverage、Timeliness；纵轴为百分比，范围从 0% 到 100%。</li>
<li>图例包含五种 prefetcher：SPP-PPF（橙色斜线）、SMS（橙色点状）、Bingo（蓝色网格）、PMP（浅蓝斜线）、RICH（黄色实心）。</li>
<li><strong>RICH 在 Coverage 和 Timeliness 上显著领先</strong>，在 Accuracy 上与 Bingo 相当，优于 PMP。</li>
<li>具体数据如下：</li>
</ul>
<table>
<thead>
<tr>
<th>Prefetcher</th>
<th>Accuracy (%)</th>
<th>Coverage (%)</th>
<th>Timeliness (%)</th>
</tr>
</thead>
<tbody>
<tr>
<td>SPP-PPF</td>
<td>~70</td>
<td>~55</td>
<td>~65</td>
</tr>
<tr>
<td>SMS</td>
<td>~70</td>
<td>~60</td>
<td>~70</td>
</tr>
<tr>
<td>Bingo</td>
<td><strong>76.6</strong></td>
<td>64</td>
<td>78</td>
</tr>
<tr>
<td>PMP</td>
<td>~70</td>
<td>69</td>
<td>80</td>
</tr>
<tr>
<td>RICH</td>
<td><strong>76.3</strong></td>
<td><strong>75</strong></td>
<td><strong>91</strong></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Coverage 方面</strong>：RICH 达到 75%，比 Bingo 高出 11%，比 PMP 高出 6.2%，体现其多区域+多偏移触发机制对复杂访问模式的捕捉能力。</li>
<li><strong>Timeliness 方面</strong>：RICH 达到 91%，比 Bingo 高出 13%，比 PMP 高出 11%，反映其大区域预取策略有效提前填充缓存。</li>
<li><strong>Accuracy 方面</strong>：RICH 为 76.3%，与 Bingo 的 76.6% 几乎持平，略低于 Bingo，但远高于其他方案，说明其多偏移验证机制有效控制误预取。</li>
<li>综合来看，RICH 通过牺牲少量 Accuracy 换取大幅 Coverage 和 Timeliness 提升，实现整体性能最优，符合其“用容量和带宽换延迟隐藏”的设计哲学。</li>
</ul>
<h3 id="figure-11-detailed-speedup-achieved-by-bingo-pmp-and-rich-on-representative-traces">Figure 11: Detailed speedup achieved by Bingo, PMP and RICH on representative traces<a class="headerlink" href="#figure-11-detailed-speedup-achieved-by-bingo-pmp-and-rich-on-representative-traces" title="Permanent link">&para;</a></h3>
<p><img alt="41d53331b15c166e8afd0d7a249adad623ea7bb26966d791b61ceb8c666a01b5.jpg" src="../images/41d53331b15c166e8afd0d7a249adad623ea7bb26966d791b61ceb8c666a01b5.jpg" /></p>
<ul>
<li>图片展示了 <strong>Figure 11</strong>，标题为“Detailed speedup achieved by Bingo, PMP and RICH on representative traces”，用于比较三种预取器在多个代表性工作负载上的性能加速比。</li>
<li>横轴列出了 40 个 SPEC CPU、Ligra 和 Parsec 工作负载的缩写名称，如 <code>602.gcc-754</code>、<code>603.bwaves-891</code>、<code>459.GemsFDTD-765B</code> 等，覆盖了科学计算、编译器、图形处理等场景。</li>
<li>纵轴表示“Speedup over no prefetching”，即相对于无预取基线的性能加速倍数，范围从 0 到 3.8。</li>
<li>图中使用三种颜色柱状图分别代表：<ul>
<li>蓝色：<strong>PMP</strong></li>
<li>橙色：<strong>Bingo</strong></li>
<li>黄色：<strong>RICH</strong></li>
</ul>
</li>
<li>在绝大多数工作负载上，<strong>RICH</strong> 的加速比高于 <strong>Bingo</strong> 和 <strong>PMP</strong>，表明其综合性能更优。</li>
<li>部分工作负载上，<strong>RICH</strong> 的加速比显著领先，例如：<ul>
<li><code>603.bwaves-891</code>：RICH 达到 <strong>3.8</strong>，Bingo 为 3.6，PMP 为 2.5</li>
<li><code>601.bwaves-1740</code>：RICH 达到 <strong>4.8</strong>，Bingo 为 3.8，PMP 为 2.8</li>
<li><code>459.GemsFDTD-765B</code>：RICH 达到 <strong>4.8</strong>，Bingo 为 3.6，PMP 为 2.5</li>
</ul>
</li>
<li>在少数工作负载上（如 <code>605.mcf-782</code>、<code>605.mcf-1152</code>），三者性能接近，但 <strong>RICH</strong> 仍保持微弱优势。</li>
<li>数据表格化如下：</li>
</ul>
<table>
<thead>
<tr>
<th>Workload</th>
<th>PMP Speedup</th>
<th>Bingo Speedup</th>
<th>RICH Speedup</th>
</tr>
</thead>
<tbody>
<tr>
<td>602.gcc-754</td>
<td>~1.5</td>
<td>~1.6</td>
<td>~1.7</td>
</tr>
<tr>
<td>603.bwaves-891</td>
<td>~2.5</td>
<td>~3.6</td>
<td><strong>3.8</strong></td>
</tr>
<tr>
<td>601.bwaves-1740</td>
<td>~2.8</td>
<td>~3.8</td>
<td><strong>4.8</strong></td>
</tr>
<tr>
<td>459.GemsFDTD-765B</td>
<td>~2.5</td>
<td>~3.6</td>
<td><strong>4.8</strong></td>
</tr>
<tr>
<td>654.roms-294</td>
<td>~1.8</td>
<td>~2.0</td>
<td>~2.1</td>
</tr>
<tr>
<td>482.sphinx3-1297</td>
<td>~1.6</td>
<td>~1.7</td>
<td>~1.8</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>关键结论</strong>：RICH 在多数工作负载上实现了最高加速比，尤其在具有跨页空间局部性的工作负载（如 <code>603.bwaves</code>、<code>459.GemsFDTD</code>）中表现突出，验证了其多区域、多偏移触发机制的有效性。</li>
</ul>
<h3 id="figure-12-each-region-makes-a-significant-contribution-to-prefetchingand-we-achieve-a-significant-reduction-in-amat">Figure 12: Each region makes a significant contribution to prefetching,and we achieve a significant reduction in AMAT<a class="headerlink" href="#figure-12-each-region-makes-a-significant-contribution-to-prefetchingand-we-achieve-a-significant-reduction-in-amat" title="Permanent link">&para;</a></h3>
<p><img alt="836cb4d99b3e3003a70b1aa2323b5614058be871a892e135c08b4851954d72e4.jpg" src="../images/836cb4d99b3e3003a70b1aa2323b5614058be871a892e135c08b4851954d72e4.jpg" /></p>
<ul>
<li>图片包含两个子图，分别展示 RICH prefetcher 在不同工作负载下的区域贡献和平均缺失访问时间（AMAT）表现。</li>
<li>子图 a) 标题为“Contribution of Each Region to Prefetch Coverage”，显示了 <strong>2 KB-region</strong>、<strong>4 KB-region</strong> 和 <strong>16 KB-region</strong> 在四个基准测试套件（Parsec、Ligra、SPEC06、SPEC17）中的覆盖贡献比例。<ul>
<li>Parsec：2 KB-region 约占 0.5，4 KB-region 约占 0.2，16 KB-region 约占 0.3。</li>
<li>Ligra：2 KB-region 约占 0.3，4 KB-region 约占 0.2，16 KB-region 约占 0.5。</li>
<li>SPEC06：2 KB-region 约占 0.4，4 KB-region 约占 0.2，16 KB-region 约占 0.4。</li>
<li>SPEC17：2 KB-region 约占 0.3，4 KB-region 约占 0.2，16 KB-region 约占 0.5。</li>
</ul>
</li>
<li>子图 b) 标题为“Average Miss Access Time (AMAT) (cycles)”，比较了三种 prefetcher（PMP、Bingo、RICH）在 L1D、L2C、LLC 和 Main Memory 层级上的 AMAT。<ul>
<li>PMP：L1D 约 5 cycles，L2C 约 5 cycles，LLC 约 10 cycles，Main Memory 约 30 cycles，总计约 50 cycles。</li>
<li>Bingo：L1D 约 5 cycles，L2C 约 5 cycles，LLC 约 10 cycles，Main Memory 约 25 cycles，总计约 45 cycles。</li>
<li>RICH：L1D 约 5 cycles，L2C 约 5 cycles，LLC 约 5 cycles，Main Memory 约 20 cycles，总计约 35 cycles。</li>
</ul>
</li>
<li>数据表明，<strong>RICH 在所有层级上均实现了最低的 AMAT</strong>，尤其在 Main Memory 层级显著优于 Bingo 和 PMP。</li>
<li>各区域对覆盖的贡献因工作负载而异，说明 <strong>RICH 的多区域设计能自适应不同程序的内存访问模式</strong>。</li>
<li>综合来看，RICH 通过有效利用多尺度区域和分层存储策略，在保持高准确率的同时显著提升覆盖和及时性，从而降低整体访问延迟。</li>
</ul>
<h3 id="figure-13-rich-demonstrates-greater-performance-gains-compared-to-bingo-and-pmp-as-memory-latency-increases-highlighting-its-potential-for-future-high-latency-systems">Figure 13: RICH demonstrates greater performance gains compared to Bingo and PMP as memory latency increases, highlighting its potential for future high-latency systems<a class="headerlink" href="#figure-13-rich-demonstrates-greater-performance-gains-compared-to-bingo-and-pmp-as-memory-latency-increases-highlighting-its-potential-for-future-high-latency-systems" title="Permanent link">&para;</a></h3>
<p><img alt="98500fa03aab76d396357bbb8fa47cca4a1629e12e31ce3feae5b66be9acfa74.jpg" src="../images/98500fa03aab76d396357bbb8fa47cca4a1629e12e31ce3feae5b66be9acfa74.jpg" /></p>
<ul>
<li>图表展示了 RICH prefetcher 相较于 Bingo 和 PMP 在不同内存访问延迟下的性能增益，横轴为额外增加的内存访问延迟（0ns 至 120ns），纵轴为性能提升百分比。</li>
<li><strong>RICH vs Bingo</strong> 的性能增益随延迟增加呈线性上升趋势，从 0ns 时的约 3.4% 增长至 120ns 时的 <strong>8.3%</strong>，表明 RICH 在高延迟系统中优势显著。</li>
<li><strong>RICH vs PMP</strong> 的性能增益增长较平缓，从 0ns 时约 4.4% 上升至 120ns 时的 <strong>6.2%</strong>，说明 RICH 对 PMP 的领先幅度在高延迟下仍持续扩大。</li>
<li>数据点分布显示，随着延迟增加，RICH 的相对优势愈发明显，印证其设计初衷——通过利用丰富元数据和多尺度区域预取机制有效掩盖高延迟。</li>
<li>下表总结关键延迟点对应的性能增益：</li>
</ul>
<table>
<thead>
<tr>
<th>额外延迟</th>
<th>RICH vs Bingo</th>
<th>RICH vs PMP</th>
</tr>
</thead>
<tbody>
<tr>
<td>0ns</td>
<td>~3.4%</td>
<td>~4.4%</td>
</tr>
<tr>
<td>30ns</td>
<td>~5.0%</td>
<td>~4.8%</td>
</tr>
<tr>
<td>60ns</td>
<td>~6.0%</td>
<td>~5.2%</td>
</tr>
<tr>
<td>90ns</td>
<td>~7.0%</td>
<td>~5.8%</td>
</tr>
<tr>
<td>120ns</td>
<td><strong>8.3%</strong></td>
<td><strong>6.2%</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>图表标题明确指出：RICH 在高延迟系统中表现更优，凸显其面向未来内存架构（如 CXL、NVM）的设计前瞻性。</li>
</ul>
<h3 id="figure-14-performance-under-different-memory-bandwidth">Figure 14: Performance under different memory bandwidth<a class="headerlink" href="#figure-14-performance-under-different-memory-bandwidth" title="Permanent link">&para;</a></h3>
<p><img alt="ac26fd56c7458e04d1de3b82eefd5b28980b072696244293935ceee8ea963cc4.jpg" src="../images/ac26fd56c7458e04d1de3b82eefd5b28980b072696244293935ceee8ea963cc4.jpg" /></p>
<ul>
<li>图表标题为“Figure 14: Performance under different memory bandwidth”，展示不同内存带宽下各预取器的性能增益。</li>
<li>横轴为“Peak DRAM Bandwidth”，范围从5GB/s到35GB/s，共7个测试点；纵轴为“Performance Gain”，单位为百分比，范围0%至40%。</li>
<li>图中包含五条曲线，分别代表五个预取器：<strong>RICH</strong>（蓝色）、<strong>Bingo</strong>（橙色）、<strong>PMP</strong>（灰色）、<strong>SMS</strong>（黄色）、<strong>SPP-PPF</strong>（浅蓝色）。</li>
<li><strong>RICH</strong>在所有带宽条件下均表现最优，尤其在高带宽场景优势显著。在35GB/s时，其性能增益达<strong>39%</strong>，远超其他预取器。</li>
<li><strong>Bingo</strong>次之，在35GB/s时性能增益为<strong>34%</strong>，与RICH差距扩大。</li>
<li><strong>PMP</strong>和<strong>SMS</strong>表现接近，35GB/s时分别为<strong>33%</strong>和<strong>30%</strong>，但整体增长斜率低于RICH。</li>
<li><strong>SPP-PPF</strong>表现最弱，35GB/s时仅<strong>20%</strong>，且增长平缓。</li>
<li>在低带宽（5GB/s）时，<strong>RICH</strong>性能增益为<strong>19%</strong>，略低于<strong>Bingo</strong>的<strong>20.1%</strong>，表明其激进预取策略在带宽受限时可能引发竞争。</li>
<li>随着带宽提升，<strong>RICH</strong>性能增益快速上升，从5GB/s的19%跃升至35GB/s的39%，增幅达<strong>20个百分点</strong>，体现其对高带宽资源的高效利用能力。</li>
<li>其他预取器在带宽增加时也有提升，但幅度较小，例如<strong>Bingo</strong>从20.1%增至34%，增幅仅<strong>13.9个百分点</strong>。</li>
<li>数据汇总如下：</li>
</ul>
<table>
<thead>
<tr>
<th>Peak DRAM Bandwidth</th>
<th>RICH (%)</th>
<th>Bingo (%)</th>
<th>PMP (%)</th>
<th>SMS (%)</th>
<th>SPP-PPF (%)</th>
</tr>
</thead>
<tbody>
<tr>
<td>5GB/s</td>
<td>19.0</td>
<td>20.1</td>
<td>12.0</td>
<td>11.0</td>
<td>13.0</td>
</tr>
<tr>
<td>10GB/s</td>
<td>28.0</td>
<td>26.0</td>
<td>20.0</td>
<td>18.0</td>
<td>16.0</td>
</tr>
<tr>
<td>15GB/s</td>
<td>32.0</td>
<td>29.0</td>
<td>25.0</td>
<td>22.0</td>
<td>18.0</td>
</tr>
<tr>
<td>20GB/s</td>
<td>34.0</td>
<td>31.0</td>
<td>28.0</td>
<td>25.0</td>
<td>19.0</td>
</tr>
<tr>
<td>25GB/s</td>
<td>36.0</td>
<td>33.0</td>
<td>30.0</td>
<td>27.0</td>
<td>20.0</td>
</tr>
<tr>
<td>30GB/s</td>
<td>38.0</td>
<td>34.0</td>
<td>32.0</td>
<td>29.0</td>
<td>20.0</td>
</tr>
<tr>
<td>35GB/s</td>
<td><strong>39.0</strong></td>
<td><strong>34.0</strong></td>
<td><strong>33.0</strong></td>
<td><strong>30.0</strong></td>
<td><strong>20.0</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>结论：<strong>RICH</strong>设计针对高带宽内存趋势，能有效利用丰富元数据和多区域预取机制，在高带宽环境下实现显著性能提升；但在低带宽场景需权衡预取激进性以避免资源争用。</li>
</ul>
<h3 id="figure-15-multi-offset-trigger-mechanism-significantly-benefits-rich-while-offloading-part-of-the-16-kb-region-patterns-has-limited-performance-impact">Figure 15: Multi-offset trigger mechanism significantly benefits RICH, while offloading part of the 16 KB-Region patterns has limited performance impact.<a class="headerlink" href="#figure-15-multi-offset-trigger-mechanism-significantly-benefits-rich-while-offloading-part-of-the-16-kb-region-patterns-has-limited-performance-impact" title="Permanent link">&para;</a></h3>
<p><img alt="dfd25d1ed4dc6f27dc13c3a614814079f420c7f19f75ca4af2bb109b84edb4c1.jpg" src="../images/dfd25d1ed4dc6f27dc13c3a614814079f420c7f19f75ca4af2bb109b84edb4c1.jpg" /></p>
<ul>
<li>图表标题为 <strong>Figure 15</strong>，旨在展示 <strong>Multi-offset trigger mechanism</strong> 对 RICH 的显著增益，以及将部分 <strong>16 KB-region patterns</strong> 卸载至片外对性能影响有限。</li>
<li>图表上半部分为折线图，横轴表示七种不同配置（从 (1) 到 (7)），纵轴为“Performance Gain over No Prefetching”，范围从 10% 至 50%。</li>
<li>折线图显示：<strong>2 KB-region only</strong> 配置性能增益约 35%，<strong>4 KB-region only</strong> 约 25%，<strong>16 KB-region only</strong> 最低约 18%，随后逐步提升至 <strong>RICH</strong> 配置的约 40%。</li>
<li>下半部分表格详细列出各配置的关键特性与片上开销：<ul>
<li><strong>(1) 2KB-region only</strong>：仅支持 2KB 区域，无多区域、多偏移、区域仲裁或片外存储，片上开销 22 KB。</li>
<li><strong>(2) 4KB-region only</strong>：仅支持 4KB 区域，片上开销 10 KB。</li>
<li><strong>(3) 16KB-region only</strong>：仅支持 16KB 区域，片上开销 137 KB。</li>
<li><strong>(4) Naive multi-region</strong>：支持多区域但无多偏移触发和区域仲裁，片上开销 174 KB。</li>
<li><strong>(5) Multi-region multi-trigger</strong>：加入多偏移触发机制，片上开销仍为 174 KB。</li>
<li><strong>(6) All-on-chip</strong>：在 (5) 基础上增加区域仲裁，片上开销增至 175 KB。</li>
<li><strong>(7) RICH (proposed)</strong>：完整设计，包含区域仲裁与片外协作策略，片上开销大幅降至 <strong>47.3 KB</strong>。</li>
</ul>
</li>
<li>关键结论：引入 <strong>multi-offset trigger</strong> 和 <strong>region arbitration</strong> 显著提升性能；而将部分 16KB 模式卸载至片外，仅导致约 <strong>0.5% 性能损失</strong>，验证了其高效性。</li>
<li>数据表明，<strong>RICH 在保持高性能的同时，片上资源消耗仅为传统全片上方案的约 27%</strong>，体现其在高带宽、大容量内存系统中的设计优势。</li>
</ul>
<h3 id="figure-16-iso-storage-comparison-shows-rich-is-more-storage-efficient-than-bingo-and-pmp">Figure 16: Iso-storage comparison shows RICH is more storage efficient than Bingo and PMP.<a class="headerlink" href="#figure-16-iso-storage-comparison-shows-rich-is-more-storage-efficient-than-bingo-and-pmp" title="Permanent link">&para;</a></h3>
<p><img alt="c9e4509efc02be412f96960f3a4bcaff595947df5db30483deeb6253969c47e2.jpg" src="../images/c9e4509efc02be412f96960f3a4bcaff595947df5db30483deeb6253969c47e2.jpg" /></p>
<ul>
<li>图片展示了在<strong>相同存储预算</strong>下，RICH 与 Bingo、PMP 及其增强版本的性能对比，旨在验证 RICH 的<strong>存储效率</strong>。</li>
<li><strong>横轴</strong>为不同 prefetcher 配置：Bingo、Enhanced Bingo、PMP、Enhanced PMP、RICH。</li>
<li><strong>纵轴</strong>为“Speedup over No Prefetching”，即相对于无预取基线的加速比，数值越高代表性能越好。</li>
<li>数据显示，<strong>RICH 的加速比最高</strong>，约为 1.4，显著优于其他所有配置。</li>
<li>Bingo 和 Enhanced Bingo 的加速比相近，均约为 1.35，表明单纯扩大 Bingo 的 PHT 容量带来的收益有限。</li>
<li>PMP 和 Enhanced PMP 的加速比也相近，约为 1.33，同样说明简单扩容对 PMP 的提升不明显。</li>
<li>这一结果支持了论文中的核心观点：<strong>RICH 能更有效地将丰富的元数据转化为性能增益</strong>，而传统 prefetcher 在扩容后面临边际效益递减。</li>
<li>下表总结了各配置的存储开销和性能表现：</li>
</ul>
<table>
<thead>
<tr>
<th>Prefetcher</th>
<th>On-chip Storage (KB)</th>
<th>Off-chip Storage (KB)</th>
<th>Total Storage (KB)</th>
<th>Speedup over No Prefetching</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bingo</td>
<td>127</td>
<td>0</td>
<td>127</td>
<td>~1.35</td>
</tr>
<tr>
<td>Enhanced Bingo</td>
<td>193</td>
<td>0</td>
<td>193</td>
<td>~1.35</td>
</tr>
<tr>
<td>PMP</td>
<td>128</td>
<td>0</td>
<td>128</td>
<td>~1.33</td>
</tr>
<tr>
<td>Enhanced PMP</td>
<td>194</td>
<td>0</td>
<td>194</td>
<td>~1.33</td>
</tr>
<tr>
<td><strong>RICH</strong></td>
<td><strong>47</strong></td>
<td><strong>128</strong></td>
<td><strong>175</strong></td>
<td><strong>~1.40</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>尽管 RICH 的总存储开销（175 KB）介于 Bingo/PMP 与其增强版之间，但其<strong>性能优势明显</strong>，证明其设计能更高效地利用存储资源。</li>
<li>RICH 的成功在于其<strong>分层存储策略</strong>：将高频模式保留在片上，低频模式卸载到片外，既节省了宝贵的片上面积，又未牺牲太多性能。</li>
</ul>
<h3 id="figure-17-sensitivity-to-different-prefetch-count-thresholds-for-16-kb-region-under-different-memory-latencies">Figure 17: Sensitivity to different prefetch count thresholds for 16 KB-region under different memory latencies<a class="headerlink" href="#figure-17-sensitivity-to-different-prefetch-count-thresholds-for-16-kb-region-under-different-memory-latencies" title="Permanent link">&para;</a></h3>
<p><img alt="2b17544a46a6e5d8b489a68317ee3077425179981f2709c8e913cdccf424b403.jpg" src="../images/2b17544a46a6e5d8b489a68317ee3077425179981f2709c8e913cdccf424b403.jpg" /></p>
<ul>
<li>图片展示了 RICH prefetcher 在不同内存延迟下，其 16 KB-region 模式对 <strong>prefetch count threshold</strong> 的敏感性分析。该阈值用于决定是否将不频繁的 16 KB 模式写入 off-chip PHT，以避免因 row buffer miss 导致的性能损失。</li>
<li>图表分为三个子图 (a, b, c)，分别对应 <strong>0ns、30ns 和 60ns</strong> 的额外内存延迟场景，纵轴为 Performance Gain（相对于无 prefetch 基线），横轴为 Threshold 值（从 10 到 70）。</li>
<li>在 <strong>0ns 延迟</strong>（常规系统）下，性能增益在阈值为 <strong>10</strong> 时达到峰值（约 40%），随后随阈值增加而下降。这表明在低延迟环境下，较低的阈值能捕获更多有效模式，从而获得更高收益。</li>
<li>在 <strong>30ns 延迟</strong> 下，性能增益在阈值为 <strong>30</strong> 时达到最优（约 50%）。此时，过低的阈值会因频繁触发 off-chip 访问导致 row buffer miss，而过高阈值则会错过大量潜在的 prefetch 机会。</li>
<li>在 <strong>60ns 延迟</strong> 下，性能增益同样在阈值为 <strong>30</strong> 时达到最高点（约 56%），趋势与 30ns 场景类似。这进一步验证了在高延迟系统中，<strong>30</strong> 是一个平衡性能与开销的稳健选择。</li>
<li>综合三图可见，随着内存延迟增加，最优阈值从 10 上升至 30，说明在高延迟系统中，需要更严格的筛选机制来避免 off-chip 访问带来的负面影响。</li>
</ul>
<table>
<thead>
<tr>
<th>延迟 (ns)</th>
<th>最优 Threshold</th>
<th>最高 Performance Gain (%)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>10</td>
<td>~40</td>
</tr>
<tr>
<td>30</td>
<td>30</td>
<td>~50</td>
</tr>
<tr>
<td>60</td>
<td>30</td>
<td>~56</td>
</tr>
</tbody>
</table>
<h3 id="figure-18-sensitivity-to-different-pht-sizes">Figure 18: Sensitivity to different PHT sizes<a class="headerlink" href="#figure-18-sensitivity-to-different-pht-sizes" title="Permanent link">&para;</a></h3>
<p><img alt="2200d39f5d8f14e421629da636f1b7a2588a706f6aeca7ae1eb07c81c7728c3e.jpg" src="../images/2200d39f5d8f14e421629da636f1b7a2588a706f6aeca7ae1eb07c81c7728c3e.jpg" /></p>
<ul>
<li>图片展示了 RICH prefetcher 对不同 Pattern History Table (PHT) 尺寸的敏感性分析，分为三个子图：a) 2 KB-region PHT、b) 4 KB-region PHT、c) 16 KB-region PHT Cache。</li>
<li><strong>性能增益</strong>（Performance Gain）作为纵轴，横轴为对应区域的 PHT 条目数（Entries），用于衡量不同配置下 prefetcher 的性能表现。</li>
<li>子图 a) 显示 2 KB-region PHT 在条目数从 2048 增加到 16384 时，性能增益从约 38% 上升至 39.5%，并在 8192 条目后趋于饱和；<strong>低于 2048 条目时性能明显下降</strong>，表明该区域对容量较敏感。</li>
<li>子图 b) 显示 4 KB-region PHT 在条目数从 512 增加到 4096 时，性能增益从约 37.5% 上升至 39.5%，在 2048 条目后基本饱和；<strong>1024 条目已可实现接近最优性能</strong>，说明其容量需求适中。</li>
<li>子图 c) 显示 16 KB-region PHT Cache（仅限于 on-chip 部分）在条目数从 128 增加到 1024 时，性能增益从约 38% 上升至 39.5%，<strong>即使仅 256 条目也接近饱和</strong>，证明其设计高效，依赖 off-chip 存储补充。</li>
<li>综合来看，RICH 的多级存储策略有效平衡了 on-chip 容量与性能：2 KB 和 4 KB 区域需适度 on-chip 空间，而 16 KB 区域通过小容量 cache + off-chip 存储即可维持高性能。</li>
</ul>
<table>
<thead>
<tr>
<th>区域大小</th>
<th>最优条目数</th>
<th>性能饱和点</th>
<th>关键观察</th>
</tr>
</thead>
<tbody>
<tr>
<td>2 KB-region PHT</td>
<td>8192+</td>
<td>8192</td>
<td><strong>低于 2048 条目性能显著下降</strong></td>
</tr>
<tr>
<td>4 KB-region PHT</td>
<td>2048+</td>
<td>2048</td>
<td>1024 条目已接近最优</td>
</tr>
<tr>
<td>16 KB-region PHT Cache</td>
<td>256+</td>
<td>256</td>
<td><strong>极小容量即达饱和，依赖 off-chip 补充</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>此结果验证了论文中提出的<strong>分层存储机制</strong>的有效性：通过将高频模式保留在 on-chip，低频模式移至 off-chip，RICH 在控制面积开销的同时保持高覆盖率和及时性。</li>
</ul>
<h3 id="figure-19-rich-outperforms-bingo-in-both-homogeneous-and-heterogeneous-workloads-on-a-4-core-system">Figure 19: RICH outperforms Bingo in both homogeneous and heterogeneous workloads on a 4-core system<a class="headerlink" href="#figure-19-rich-outperforms-bingo-in-both-homogeneous-and-heterogeneous-workloads-on-a-4-core-system" title="Permanent link">&para;</a></h3>
<p><img alt="925a081f22cefd5269003918e1d36365a14e3135b2e15eeaa1e6ba7b5225406e.jpg" src="../images/925a081f22cefd5269003918e1d36365a14e3135b2e15eeaa1e6ba7b5225406e.jpg" /></p>
<ul>
<li>图表展示了在 4 核系统下，<strong>RICH</strong> 与其他四种主流 prefetcher（<strong>SPP-PPF</strong>、<strong>SMS</strong>、<strong>Bingo</strong>、<strong>PMP</strong>）在三种不同 workload 类型下的性能对比，性能指标为 <strong>Speedup over No Prefetching</strong>。</li>
<li>横轴分为三组：<strong>Heter Geomean</strong>（异构工作负载几何平均）、<strong>Homo Geomean</strong>（同构工作负载几何平均）、<strong>Geomean</strong>（所有工作负载的几何平均），纵轴表示相对于无预取基线的加速比。</li>
<li><strong>RICH</strong> 在所有三类 workload 中均取得最高加速比，其柱状图以红色实心填充，显著高于其他 prefetcher。</li>
<li>各 prefetcher 在不同 workload 下的表现如下：</li>
</ul>
<table>
<thead>
<tr>
<th>Workload Type</th>
<th>SPP-PPF</th>
<th>SMS</th>
<th>Bingo</th>
<th>PMP</th>
<th>RICH</th>
</tr>
</thead>
<tbody>
<tr>
<td>Heter Geomean</td>
<td>~1.15</td>
<td>~1.28</td>
<td>~1.20</td>
<td>~1.20</td>
<td><strong>~1.32</strong></td>
</tr>
<tr>
<td>Homo Geomean</td>
<td>~1.10</td>
<td>~1.25</td>
<td>~1.30</td>
<td>~1.28</td>
<td><strong>~1.36</strong></td>
</tr>
<tr>
<td>Geomean</td>
<td>~1.20</td>
<td>~1.28</td>
<td>~1.25</td>
<td>~1.23</td>
<td><strong>~1.34</strong></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>RICH</strong> 相较于 <strong>Bingo</strong> 的优势在异构负载中尤为明显（<strong>+3.4%</strong>），在同构负载中略有缩小（<strong>+4.6%</strong>），整体几何平均提升达 <strong>+7.2%</strong>。</li>
<li>尽管 <strong>RICH</strong> 采用激进预取策略，在多核环境下会占用更多带宽资源，但其仍能保持领先性能，验证了其在多核场景下的有效性。</li>
<li>图例清晰标注各 prefetcher 对应的颜色与图案，便于快速识别。<strong>RICH</strong> 的红色实心柱形在视觉上突出其最优表现。</li>
</ul>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.sections", "navigation.top", "navigation.indexes", "search.suggest", "search.highlight", "content.code.copy"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../../../javascripts/switcher.js"></script>
      
    
  </body>
</html>