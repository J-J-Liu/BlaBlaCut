
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://example.com/notes_repo/virtual-program-counter-vpc-prediction-very-low-cost-indirect-branch-prediction-using-conditional-branch-prediction-hardware/ELI5_notes/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Virtual Program Counter (VPC) Prediction: Very Low Cost Indirect Branch Prediction Using Conditional Branch Prediction Hardware 通俗讲解 - BlaBlaCut</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#virtual-program-counter-vpc-prediction-very-low-cost-indirect-branch-prediction-using-conditional-branch-prediction-hardware" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="BlaBlaCut" class="md-header__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            BlaBlaCut
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Virtual Program Counter (VPC) Prediction: Very Low Cost Indirect Branch Prediction Using Conditional Branch Prediction Hardware 通俗讲解
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到深色模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换到深色模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到浅色模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换到浅色模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="BlaBlaCut" class="md-nav__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    BlaBlaCut
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/Recent/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Recent
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/awesome-data-prefetchers/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Awesome Data Prefetchers
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/micro-2025/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    MICRO 2025
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/dyn-lang-acc/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Dynamic Language Acceleration
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#0" class="md-nav__link">
    <span class="md-ellipsis">
      
        0. 整体创新点通俗解读
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1-virtual-program-counter-vpc-prediction" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. Virtual Program Counter (VPC) Prediction
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-virtual-branch-and-virtual-pc-vpca" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. Virtual Branch and Virtual PC (VPCA)
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-iterative-prediction-and-training-algorithms" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. Iterative Prediction and Training Algorithms
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-dynamic-devirtualization-without-compiler-support" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. Dynamic Devirtualization without Compiler Support
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-low-cost-hardware-implementation" class="md-nav__link">
    <span class="md-ellipsis">
      
        5. Low-Cost Hardware Implementation
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="virtual-program-counter-vpc-prediction-very-low-cost-indirect-branch-prediction-using-conditional-branch-prediction-hardware">Virtual Program Counter (VPC) Prediction: Very Low Cost Indirect Branch Prediction Using Conditional Branch Prediction Hardware 通俗讲解<a class="headerlink" href="#virtual-program-counter-vpc-prediction-very-low-cost-indirect-branch-prediction-using-conditional-branch-prediction-hardware" title="Permanent link">&para;</a></h1>
<h3 id="0">0. 整体创新点通俗解读<a class="headerlink" href="#0" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击 (The "Why")</strong></p>
<ul>
<li>以前的处理器处理 <strong>间接分支 (indirect branch)</strong> 非常难受，尤其是在 <strong>Java、C++</strong> 这类面向对象语言里，因为它们到处都是 <strong>虚函数调用 (virtual function calls)</strong>。</li>
<li>传统的 <strong>BTB (Branch Target Buffer)</strong> 预测器只能记住“上次跳到哪”，但一个虚函数可能根据对象类型跳到几十个不同的地方，这种“上次有效”的假设完全失效，导致 <strong>预测准确率极低</strong>。</li>
<li>虽然学术界提出了很多更聪明的间接分支预测器（比如 <strong>TTC, Cascaded Predictor</strong>），但它们都需要 <strong>额外的、巨大的硬件存储</strong> 来存目标地址。这在芯片设计上是笔大开销，既 <strong>贵</strong> 又 <strong>耗电</strong>，所以工业界基本不用，宁愿忍受性能损失。</li>
</ul>
<p><strong>通俗比方 (The Analogy)</strong></p>
<ul>
<li>想象你是个图书管理员（处理器），负责给读者（CPU）快速找到书（下一条指令）。有个读者总问：“把《动物图鉴》给我。” 但这其实是个“间接请求”——他真正想要的是《动物图鉴》里的某一页，比如“老虎”、“大象”或“蚂蚁”页。</li>
<li>传统 BTB 的做法是：记住他上次要了“老虎”页，下次就直接给他“老虎”页。但如果他这次要“蚂蚁”，你就错了，还得重新找，浪费时间。</li>
<li>其他高级预测器的做法是：专门为这个读者建一个巨大的新索引柜（额外硬件），把所有他可能要的页面都记下来。效果好，但成本太高，图书馆（芯片）放不下那么多柜子。</li>
<li><strong>VPC 的巧妙之处在于</strong>：它不建新柜子，而是 <strong>复用</strong> 图书馆里已有的、为普通读者（条件分支）服务的那套高效索引系统。它把“给我《动物图鉴》”这个请求，在内部 <strong>动态地、虚拟地</strong> 拆解成一系列普通问题：“是不是要老虎？（不是）...是不是要大象？（不是）...是不是要蚂蚁？（是！）”。它用这套成熟的问答机制，来解决原本需要特殊处理的复杂请求。</li>
</ul>
<p><strong>关键一招 (The "How")</strong></p>
<ul>
<li>作者没有去设计一个新的、复杂的间接分支预测硬件，而是 <strong>巧妙地“欺骗”了现有的条件分支预测器</strong>。</li>
<li><strong>核心逻辑转换</strong>：对于每一个间接分支，硬件不再把它看作一个单一的、需要预测N个目标的难题，而是 <strong>在预测阶段将其动态展开为一串虚拟的条件分支 (Virtual Branches)</strong>。</li>
<li>具体来说：<ul>
<li>第一个虚拟分支的 <strong>虚拟程序计数器 (VPC)</strong> 就是原间接分支的 PC。预测器问：“跳到目标A吗？” 如果预测为 <strong>taken</strong>，就用 BTB 里 VPC 对应的目标；如果预测为 <strong>not-taken</strong>，就进入下一个虚拟分支。</li>
<li>下一个虚拟分支的 VPC 是通过 <strong>哈希(原PC, 迭代次数)</strong> 生成的一个新地址。预测器再问：“那跳到目标B吗？” 如此循环。</li>
<li>这个过程利用了现有 BTB 和方向预测器的所有能力，而目标地址就自然地分散存储在 BTB 的不同（虚拟）位置里。</li>
</ul>
</li>
<li>这样一来，<strong>间接分支预测的难题就被转化成了一个序列化的条件分支预测问题</strong>，完美复用了芯片上已经存在的、高度优化的条件分支预测硬件，几乎 <strong>零成本</strong> 地获得了高性能。<img alt="" src="../images/283fea9a3dbb8605fa7b42a34727e9519292bc2364f35c22347b8409c814ac9b.jpg" /> <em>Fig. 3. High-level conceptual overview of the VPC predictor.</em></li>
</ul>
<h3 id="1-virtual-program-counter-vpc-prediction">1. Virtual Program Counter (VPC) Prediction<a class="headerlink" href="#1-virtual-program-counter-vpc-prediction" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击</strong></p>
<ul>
<li>传统处理器处理<strong>间接分支</strong>（indirect branch）非常难受。它不像条件分支只有“跳”或“不跳”两种选择，而是要从<strong>N个可能的目标地址</strong>里猜一个，这本质上是个高难度的多分类问题。</li>
<li>过去的解决方案要么太<strong>简陋</strong>（比如BTB只记上一次跳哪，遇到多态调用就歇菜），要么太<strong>昂贵</strong>（比如Tagged Target Cache需要额外的、巨大的专用硬件来存目标地址）。对于芯片设计来说，面积和功耗就是钱，没人愿意为一个预测器搭个新“车库”。</li>
<li>更扎心的是，现代<strong>Java/C++</strong> 程序因为大量使用<strong>虚函数</strong>（virtual functions）和<strong>动态分派</strong>，间接分支又多又难搞，成了性能瓶颈，但硬件却没跟上。</li>
</ul>
<p><strong>通俗比方</strong></p>
<ul>
<li>想象你面前有一扇神秘的门（间接分支），门后有好几条路（目标地址）。你不知道该走哪条。</li>
<li>老办法是：只记住上次走的那条路（BTB），或者干脆给每条路都建个专属的岗亭和哨兵（专用预测器），成本太高。</li>
<li><strong>VPC Prediction</strong>的聪明之处在于：它不建新岗亭，而是把这扇神秘的门，在你的“大脑”（即现有的<strong>条件分支预测器</strong>）里，<strong>幻化成一排普通的、带开关的门</strong>（虚拟条件分支）。</li>
<li>你依次去推这些“虚拟门”：<ul>
<li>第一扇门（虚拟PC1）问：“是去A吗？” 预测器说“否”，那就去下一扇。</li>
<li>第二扇门（虚拟PC2）问：“是去B吗？” 预测器说“是！”，好，那就走B这条路。</li>
</ul>
</li>
<li>这样，你用处理简单“是/否”问题的成熟工具（条件分支预测器），巧妙地解决了复杂的“选哪个”的问题。</li>
</ul>
<p><strong>关键一招</strong></p>
<ul>
<li>作者并没有引入任何新的存储结构，而是对<strong>现有硬件的使用方式</strong>做了一个精妙的逻辑扭转。</li>
<li><strong>核心转换</strong>在于：当处理器取指单元发现一条<strong>间接分支</strong>指令时，它不再把它当作一个孤立事件，而是启动一个<strong>迭代查询</strong>过程。</li>
<li>在这个过程中，硬件会为同一个间接分支<strong>动态生成多个唯一的“虚拟PC”</strong>（Virtual PC Address, VPCA）。生成方式很简单，比如 <code>VPCA = Hash(原始PC, 迭代次数)</code>。</li>
<li>然后，它拿着这些<strong>不同的VPCA</strong>，像查询普通条件分支一样，去访问<strong>现有的BTB和方向预测器</strong>。<ul>
<li>如果预测器对某个VPCA返回“<strong>taken</strong>”，就用BTB里对应这个VPCA的地址作为预测目标。</li>
<li>如果返回“<strong>not-taken</strong>”，就用下一个VPCA继续查。</li>
</ul>
</li>
<li>这个过程将一个<strong>N选1</strong>的难题，拆解成了最多<strong>MAX_ITER次</strong>的<strong>二元决策</strong>（是/否）序列。论文数据显示，<strong>81%</strong> 的正确预测在<strong>前三次</strong>迭代内就完成了，效率非常高。</li>
<li><img alt="" src="../images/283fea9a3dbb8605fa7b42a34727e9519292bc2364f35c22347b8409c814ac9b.jpg" /> <em>Fig. 3. High-level conceptual overview of the VPC predictor.</em></li>
<li><img alt="" src="../images/cc59d1bb83ccc21cbefbc81dcc2b3a3cef100997897622419acc8f802c55ce2b.jpg" /> <em>Fig. 4. VPC prediction example: source, assembly, and the corresponding virtual branches.</em></li>
</ul>
<h3 id="2-virtual-branch-and-virtual-pc-vpca">2. Virtual Branch and Virtual PC (VPCA)<a class="headerlink" href="#2-virtual-branch-and-virtual-pc-vpca" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击</strong></p>
<ul>
<li>传统处理器处理 <strong>indirect branch</strong>（间接跳转）非常头疼。它不像条件分支只需猜“跳 or 不跳”，而是要猜“跳到哪”，这是一个多选题。</li>
<li>之前的做法要么是用 <strong>BTB (Branch Target Buffer)</strong> 简单地记住上次跳到哪，但这在目标频繁切换时（比如调用不同子类的虚函数）<strong>准确率极低</strong>。</li>
<li>要么就是设计一套全新的、复杂的 <strong>indirect branch predictor</strong>（如 Tagged Target Cache），但这套新硬件需要<strong>巨大的存储开销和设计复杂度</strong>，芯片厂商觉得不划算，所以大多数CPU干脆不用。</li>
</ul>
<p><strong>通俗比方</strong></p>
<ul>
<li>想象你是个图书管理员（处理器），负责给读者（指令流）快速找到下一本书（下一条指令）。有个读者总问：“把‘那本’书给我”，但他每次说的“那本”都指不同的书。</li>
<li>老办法1（BTB）：你只记住他上一次要的是《三体》，下次他再问“那本”，你就直接给他《三体》。但如果他这次想要《流浪地球》，你就错了。</li>
<li>老办法2（专用预测器）：你专门为这个爱说“那本”的读者建一个巨大的个人档案柜，记录他所有可能要的书和上下文。这很准，但太占地方，成本太高。</li>
<li><strong>VPC的妙招</strong>：你不建新档案柜，而是<strong>假装</strong>这个读者问了多个问题：“是不是要《三体》？是不是要《流浪地球》？是不是要《球状闪电》？” 这些问题在现实中不存在（所以叫 <strong>Virtual Branch</strong>），但你可以用你<strong>现有的、已经很成熟的“是/否”问题处理系统</strong>（即条件分支预测器）来挨个回答。你给每个假想的问题分配一个<strong>唯一的虚拟门牌号</strong>（<strong>VPCA</strong>），这样你的“是/否”系统就能区分它们，并为每个问题记住独立的答案和对应的书（目标地址）。</li>
</ul>
<p><strong>关键一招</strong></p>
<ul>
<li>作者没有去造一个昂贵的新“多选题答题机”，而是巧妙地把一个“多选题”（indirect branch）<strong>动态地、在硬件层面</strong>拆解成一系列“是/否”题（Virtual Branches）。</li>
<li>核心在于如何为这些虚构的“是/否”题生成<strong>唯一的、可区分的身份ID</strong>（VPCA），以便复用现有的条件分支预测硬件。</li>
<li>具体做法是：<ul>
<li>第一个虚拟分支的VPCA就是原始的 <strong>PC</strong>（程序计数器）。</li>
<li>如果第一个被预测为“否”（not-taken），就立刻生成第二个虚拟分支，其VPCA通过对原始PC和一个<strong>预设的、与迭代次数相关的随机常量</strong>进行哈希运算得到（<code>VPCA = Hash(PC, iter)</code>）。</li>
<li>这个哈希操作保证了不同迭代（即不同的虚拟分支）会映射到预测结构（BTB和方向预测器）中<strong>完全不同的位置</strong>，从而可以存储和学习各自独立的目标地址和预测历史。</li>
</ul>
</li>
<li>这个过程就像在一条流水线上，对同一个模糊请求，快速生成并验证多个具体的候选答案，直到有一个被预测为“是”（taken），就采用它作为最终的跳转目标。整个过程<strong>完全复用了现有硬件</strong>，几乎没有增加额外的存储成本。<img alt="" src="../images/283fea9a3dbb8605fa7b42a34727e9519292bc2364f35c22347b8409c814ac9b.jpg" /> <em>Fig. 3. High-level conceptual overview of the VPC predictor.</em></li>
</ul>
<h3 id="3-iterative-prediction-and-training-algorithms">3. Iterative Prediction and Training Algorithms<a class="headerlink" href="#3-iterative-prediction-and-training-algorithms" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击</strong></p>
<ul>
<li>传统的间接分支预测器（如 BTB）假设一个间接跳转总是去同一个地方，这在现代 <strong>object-oriented</strong> 程序里完全行不通。想想一个 <code>Shape</code> 对象的 <code>draw()</code> 方法，它可能是 <code>Circle::draw</code>、<code>Rectangle::draw</code> 或 <code>Triangle::draw</code>，具体调哪个取决于运行时对象的实际类型。</li>
<li>之前更聪明的办法是搞个专门的 <strong>indirect branch predictor</strong>（比如 Tagged Target Cache），用历史信息来区分不同目标。但这玩意儿需要<strong>额外的、巨大的硬件存储</strong>来存目标地址，成本太高，功耗太大，大多数 CPU 厂商根本不愿意加。</li>
</ul>
<p><strong>通俗比方</strong></p>
<ul>
<li>想象你是个图书管理员（CPU），负责给读者（fetch engine）快速找到他们要的书（下一条指令）。有个读者总问：“把‘那个作者’的新书给我”，但他从不直接说作者名字（间接分支）。</li>
<li>老办法（BTB）：你只记得他上次要的是《三体》，所以每次都给他《三体》。结果他这次想要《流浪地球》，你就错了。</li>
<li>新办法（专用预测器）：你专门为他建一个“心愿单”小本子，记下他每次要的不同作者。但这需要额外纸张和管理精力（硬件开销）。</li>
<li><strong>VPC 的绝妙主意</strong>：你不建新本子！你利用自己已有的、超大的“热门图书借阅趋势预测表”（conditional branch predictor + BTB）。你心里把他的一次模糊请求，拆成一系列具体的、虚拟的问题：“是不是要刘慈欣的书？（虚拟分支1）”、“是不是要阿西莫夫的书？（虚拟分支2）”……</li>
<li>你按顺序问他（预测器）这些问题。只要他对任何一个问题回答“是”（taken），你就把对应的书（目标地址）给他。这个过程完全是<strong>在你脑子里完成的</strong>，读者（程序）根本不知道你问了这么多问题，他只提了一次模糊请求。</li>
</ul>
<p><strong>关键一招</strong></p>
<ul>
<li>作者没有为间接分支设计任何新的存储结构，而是<strong>巧妙地复用</strong>了现有的 conditional branch prediction 硬件。其核心在于 <strong>“动态虚拟化”</strong> 和 <strong>“迭代查询”</strong>。</li>
<li><strong>预测时的关键扭转</strong>：<ul>
<li>当遇到一个间接分支时，硬件并不慌，而是启动一个<strong>迭代循环</strong>。</li>
<li>在第 <code>i</code> 次迭代中，它会生成一个<strong>虚拟的 PC 地址 (VPCA)</strong>。这个 VPCA 是通过对原始 PC 进行哈希（加上一个与迭代次数相关的随机数）得到的，确保每次迭代访问预测器的不同位置。</li>
<li>它用这个 VPCA 去查 <strong>BTB</strong>（看有没有存目标）和 <strong>方向预测器</strong>（看这个虚拟分支是不是 taken）。</li>
<li>如果方向预测器说 <strong>not-taken</strong>，就说明“不是这个目标”，于是进入下一次迭代，尝试下一个虚拟分支。</li>
<li>一旦方向预测器说 <strong>taken</strong>，就立刻用 BTB 里对应 VPCA 的地址作为预测目标，结束循环。</li>
<li><img alt="" src="../images/cc59d1bb83ccc21cbefbc81dcc2b3a3cef100997897622419acc8f802c55ce2b.jpg" /> <em>Fig. 4. VPC prediction example: source, assembly, and the corresponding virtual branches.</em></li>
</ul>
</li>
<li><strong>训练时的关键扭转</strong>：<ul>
<li>当间接分支最终执行完毕，真相大白（知道正确目标了），训练逻辑就开始工作。</li>
<li><strong>如果预测对了</strong>：那么，在预测循环中所有被判断为 not-taken 的虚拟分支，都要被训练成 <strong>not-taken</strong>；而那个最终被选中的（taken）虚拟分支，则要被强化为 <strong>taken</strong>，并且它在 BTB 里的条目也要更新（比如提升其 LRU/LFU 优先级）。</li>
<li><strong>如果预测错了</strong>（Wrong-target）：说明正确的目标其实在 BTB 里，但对应的那个虚拟分支被错误地预测为 not-taken。训练逻辑会遍历所有虚拟分支，找到存有正确目标的那个，把它训练成 <strong>taken</strong>。</li>
<li><strong>如果预测错了</strong>（No-target）：说明正确目标压根不在 BTB 里。这时，训练逻辑会选择一个“牺牲品”——通常是某个虚拟分支对应的 BTB 条目（比如 LFU 最低的），用正确的目标地址<strong>替换</strong>掉它，并把这个新条目对应的虚拟分支训练成 <strong>taken</strong>。</li>
<li>这个训练过程保证了预测器能<strong>动态适应</strong>程序行为的变化，比如新出现了某个类的对象，也能很快学会预测。</li>
</ul>
</li>
</ul>
<h3 id="4-dynamic-devirtualization-without-compiler-support">4. Dynamic Devirtualization without Compiler Support<a class="headerlink" href="#4-dynamic-devirtualization-without-compiler-support" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击</strong></p>
<ul>
<li>传统的 <strong>devirtualization</strong>（去虚拟化）是编译器干的活，它需要在编译时就“猜”出一个虚函数调用最可能指向哪几个具体的实现。这要求要么做复杂的<strong>whole-program analysis</strong>（全程序分析），要么依赖<strong>profiling</strong>（剖析）数据。</li>
<li>这个方法在现代软件里“很难受”，原因有三：<ul>
<li><strong>不适应变化</strong>：程序运行时的行为可能和编译时看到的完全不同，特别是对于<strong>Java</strong>这类支持<strong>dynamic class loading</strong>（动态类加载）的语言，新类可以在运行时凭空出现，编译器根本没法预测。</li>
<li><strong>成本太高</strong>：对大型商业软件做全程序分析或精确剖析，开销巨大，很多编译器干脆就不做了，或者只处理最简单的单态（monomorphic）情况。</li>
<li><strong>可能帮倒忙</strong>：即使猜对了，把一个间接跳转变成好几个带<strong>guard</strong>（守卫）的条件分支，虽然可能提高预测准确率，但会<strong>膨胀代码体积</strong>，甚至可能把一个错预测变成多个错预测，得不偿失。</li>
</ul>
</li>
</ul>
<p><strong>通俗比方</strong></p>
<ul>
<li>想象一下，你（处理器）面前有一扇神秘的门（间接分支），门后有无数条路（目标地址）。以前的做法是：<ul>
<li><strong>编译器</strong>（一个事前规划师）：在你出发前，根据地图（源代码）和过往经验（剖析数据），给你一张小抄，上面写着“这扇门后面90%可能是A路，10%是B路”。然后他直接在你面前放了两个岔路口（guard branches），让你选。但如果路上突然出现了C路（动态加载的新类），这张小抄就废了。</li>
</ul>
</li>
<li><strong>VPC Prediction</strong> 的做法完全不同：<ul>
<li>它没有事前规划师，而是给了你一个<strong>万能钥匙串</strong>（利用现有的<strong>conditional branch predictor</strong>硬件）。</li>
<li>当你走到这扇神秘门前，你并不知道后面是什么。于是你开始<strong>试钥匙</strong>：第一把钥匙（<strong>Virtual PC 1</strong>）对应A路，你问你的直觉（分支预测器）：“走A路吗？” 如果直觉说“不”，你就立刻换第二把钥匙（<strong>Virtual PC 2</strong>）试试B路，如此往复。</li>
<li>这个“试钥匙”的过程完全是在你脑子里（硬件内部）完成的，外面的世界（程序代码）根本不知道你试了多少次。一旦某把钥匙打开了门（预测器说“走这条路”），你就冲进去。</li>
<li>最关键的是，每次你实际走过这扇门后，你都会<strong>更新你的直觉和钥匙串</strong>。如果这次走的是新出现的C路，你就会把C路的信息也加到你的钥匙串里，下次就能更快地找到它。这就是<strong>dynamic devirtualization without compiler support</strong>——一种完全在硬件层面、自适应的、动态的“去虚拟化”。</li>
</ul>
</li>
</ul>
<p><strong>关键一招</strong></p>
<ul>
<li>作者并没有为间接分支设计一套全新的、昂贵的预测硬件（比如<strong>Tagged Target Cache</strong>），而是巧妙地<strong>复用</strong>了处理器里已经存在的、非常成熟的<strong>conditional branch prediction</strong>机制。</li>
<li>具体来说，他们做了一个精妙的<strong>逻辑转换</strong>：<ul>
<li>将一个<strong>N-ary</strong>（多路）的间接分支目标预测问题，<strong>动态地、按需地</strong>转换成一系列<strong>binary</strong>（二元）的条件分支预测问题。</li>
<li>实现这个转换的核心是<strong>Virtual Program Counter </strong>(VPC)。对于同一个物理的间接分支指令（PC地址固定），硬件在预测时会生成多个<strong>fake PC</strong>（即VPC）。每个VPC在分支预测器眼里就是一个独立的、普通的条件分支。</li>
<li>第一个VPC就是原始PC。如果预测器对第一个VPC的预测结果是<strong>not-taken</strong>，就意味着“第一个猜测的目标不对”，于是硬件立即用一个<strong>哈希函数</strong>（<code>PC XOR HASHVAL[iter]</code>）生成第二个VPC，并再次查询预测器。这个过程迭代进行，直到某个VPC被预测为<strong>taken</strong>，此时与该VPC关联的<strong>BTB</strong>（Branch Target Buffer）中的目标地址就被当作最终预测结果。</li>
</ul>
</li>
<li>这个设计的绝妙之处在于，<strong>目标地址的存储</strong>（在BTB里）和<strong>预测逻辑</strong>（在条件分支预测器里）都被现有的硬件结构自然地承担了，几乎<strong>没有增加额外的存储开销</strong>，只是增加了一点点控制逻辑来管理VPC的迭代。这就实现了用极低的成本，获得了接近专用复杂预测器的性能。<img alt="" src="../images/283fea9a3dbb8605fa7b42a34727e9519292bc2364f35c22347b8409c814ac9b.jpg" /> <em>Fig. 3. High-level conceptual overview of the VPC predictor.</em></li>
</ul>
<h3 id="5-low-cost-hardware-implementation">5. Low-Cost Hardware Implementation<a class="headerlink" href="#5-low-cost-hardware-implementation" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击</strong></p>
<ul>
<li>传统的间接分支预测器（如 Tagged Target Cache, Cascaded Predictor）为了记住一个间接跳转可能去的多个目标地址，必须配备<strong>专用的、庞大的存储结构</strong>。这在硬件上是笔巨大的开销。</li>
<li>这种开销不仅是<strong>面积成本</strong>（Die Area），更是<strong>功耗和设计复杂度</strong>的成本。处理器前端（Fetch Unit）本就时序紧张，再塞进一个复杂的预测器，会让设计雪上加霜。</li>
<li>结果就是，很多商用处理器干脆不用这些高级预测器，而是用最简单的 <strong>BTB (Branch Target Buffer)</strong> 来对付间接分支——它只记最后一次跳转的目标。这种方法对有多目标的间接分支（比如虚函数调用）<strong>准确率极低</strong>，成了性能瓶颈。</li>
</ul>
<p><strong>通俗比方</strong></p>
<ul>
<li>想象你是个图书管理员（处理器），负责给读者（指令流）快速找到他们要的书（下一条指令）。有个读者总问：“把上次那本《XXX》系列的下一册给我。” 但这个系列有几十本，他每次要的都不一样。</li>
<li>老派做法（专用预测器）：你专门为这个读者建一个<strong>私人书架</strong>，把他可能要的所有书都摆上去，并贴上标签。这很准，但占地方、费钱。</li>
<li>BTB的做法：你太懒了，只记得他<strong>上一次</strong>拿的是哪本，每次都给他同一本。结果他经常不满意，白跑一趟。</li>
<li><strong>VPC的做法</strong>：你很聪明，没有建新书架。你利用图书馆里<strong>已有的、给其他读者用的“热门推荐”系统</strong>（Conditional Branch Predictor + BTB）。你把这个读者的问题，巧妙地转化成一系列“他要不要《A》？”、“他要不要《B》？”……的二选一问题，挨个去问那个“热门推荐”系统。一旦系统说“要！”，你就把对应的书给他。你只是<strong>复用</strong>了现有设施，没花什么额外成本。</li>
</ul>
<p><strong>关键一招</strong></p>
<ul>
<li>作者的核心洞察是：<strong>间接分支的多个目标，其实可以被看作是一系列互斥的“虚拟”条件分支</strong>。每个虚拟分支对应一个可能的目标地址。</li>
<li>为了解决“低成本”这个痛点，作者没有引入任何新的存储单元来存这些目标地址，而是做了以下精妙的逻辑转换：<ul>
<li><strong>复用 BTB 存储</strong>：每个“虚拟分支”都被分配一个<strong>伪造的程序计数器（Virtual PC, VPC）</strong>。这个VPC不是真实的代码地址，而是一个由原始间接分支PC和一个迭代常数哈希生成的唯一ID。这个VPC被用来在<strong>现有的BTB里索引</strong>，从而将目标地址自然地存储在BTB中。</li>
<li><strong>复用方向预测器</strong>：预测过程变成了一个<strong>迭代查询</strong>。处理器用VPC去查BTB拿到一个目标，同时用VPC和一个虚拟的历史寄存器（VGHR）去查<strong>现有的条件分支方向预测器</strong>。如果预测器说“taken”，就采用这个目标；如果说“not-taken”，就生成下一个VPC，继续查。</li>
<li><strong>极简硬件开销</strong>：整个机制只需要增加极少的硬件：几个寄存器（存迭代次数、当前VPC/VGHR）、一个小型硬编码的<strong>随机哈希表</strong>（用于生成不同的VPC），以及一些简单的组合逻辑。所有繁重的存储和预测工作，都交给了<strong>已经存在的、为条件分支服务的硬件</strong>。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/283fea9a3dbb8605fa7b42a34727e9519292bc2364f35c22347b8409c814ac9b.jpg" /> <em>Fig. 3. High-level conceptual overview of the VPC predictor.</em></p>
<p>这种设计的绝妙之处在于，它把一个<strong>N选1</strong>的复杂问题（预测N个可能的目标），通过迭代的方式，转化成了多次<strong>2选1</strong>的简单问题（taken or not-taken），从而完美嫁接到了成熟、高效的条件分支预测硬件上，实现了<strong>零专用存储</strong>的低成本高性能预测。</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.sections", "navigation.top", "navigation.indexes", "search.suggest", "search.highlight", "content.code.copy"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../../../javascripts/switcher.js"></script>
      
        <script src="../../../javascripts/smart_back.js"></script>
      
    
  </body>
</html>