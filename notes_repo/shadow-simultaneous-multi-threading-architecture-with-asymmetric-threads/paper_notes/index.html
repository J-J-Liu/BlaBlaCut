
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://example.com/notes_repo/shadow-simultaneous-multi-threading-architecture-with-asymmetric-threads/paper_notes/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>SHADOW: Simultaneous Multi-Threading Architecture with Asymmetric Threads 论文解析 - BlaBlaCut</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#shadow-simultaneous-multi-threading-architecture-with-asymmetric-threads" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="BlaBlaCut" class="md-header__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            BlaBlaCut
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              SHADOW: Simultaneous Multi-Threading Architecture with Asymmetric Threads 论文解析
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到深色模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换到深色模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到浅色模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换到浅色模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="BlaBlaCut" class="md-nav__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    BlaBlaCut
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/Recent/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Recent
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/awesome-data-prefetchers/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Awesome Data Prefetchers
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/micro-2025/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    MICRO 2025
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#0" class="md-nav__link">
    <span class="md-ellipsis">
      
        0. 论文基本信息
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. 摘要
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. 背景知识与核心贡献
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. 核心技术和实现细节
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3. 核心技术和实现细节">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#0_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        0. 技术架构概览
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-asymmetric-thread-co-execution" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. 异构线程并发执行 (Asymmetric Thread Co-execution)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-dynamic-work-stealing-mechanism" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. 动态工作窃取机制 (Dynamic Work Stealing Mechanism)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-lightweight-in-order-threads" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. 轻量级顺序线程设计 (Lightweight In-Order Threads)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-runtime-configurable-resource-partitioning" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. 运行时可重构资源分区 (Runtime-Configurable Resource Partitioning)
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. 实验方法与实验结果
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="shadow-simultaneous-multi-threading-architecture-with-asymmetric-threads">SHADOW: Simultaneous Multi-Threading Architecture with Asymmetric Threads 论文解析<a class="headerlink" href="#shadow-simultaneous-multi-threading-architecture-with-asymmetric-threads" title="Permanent link">&para;</a></h1>
<h2 id="0">0. 论文基本信息<a class="headerlink" href="#0" title="Permanent link">&para;</a></h2>
<p><strong>作者 (Authors)</strong></p>
<ul>
<li>Ishita Chaturvedi (Princeton University)</li>
<li>Bhargav Reddy Godala (AheadComputing / Princeton University)</li>
<li>Abiram Gangavaram (Princeton University)</li>
<li>Daniel Flyer (Princeton University)</li>
<li>Tyler Sorensen (Microsoft / University of California Santa Cruz)</li>
<li>Tor M. Aamodt (University of British Columbia)</li>
<li>David I. August (Princeton University)</li>
</ul>
<p><strong>发表期刊/会议 (Journal/Conference)</strong></p>
<ul>
<li>58th IEEE/ACM International Symposium on Microarchitecture (MICRO '25)</li>
</ul>
<p><strong>发表年份 (Publication Year)</strong></p>
<ul>
<li>2025</li>
</ul>
<hr />
<h2 id="1">1. 摘要<a class="headerlink" href="#1" title="Permanent link">&para;</a></h2>
<p><strong>目的</strong></p>
<ul>
<li>解决传统CPU在处理具有不规则稀疏性和不可预测内存访问模式的应用时，难以在**指令级并行性 <strong>(ILP)和</strong>线程级并行性 **(TLP)之间取得平衡的问题。</li>
<li>克服现有**同时多线程 <strong>(SMT)架构的局限性，例如只能在纯</strong>乱序 <strong>(OoO)或纯</strong>顺序 **(InO)模式间切换（如MorphCore），或需要复杂的跨路径推测机制（如FIFOShelf）。</li>
<li>提出一种能在单个核心内<strong>同时</strong>执行OoO和InO线程的<strong>非对称SMT架构</strong>，以动态适应工作负载变化，最大化资源利用率，并保持极低的硬件开销。</li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li>设计并实现了名为<strong>SHADOW</strong>的新型CPU微架构，其核心是在一个物理核心内集成一个深度OoO线程和多个轻量级InO线程。</li>
<li><strong>硬件层面</strong>:<ul>
<li>OoO线程负责挖掘深度ILP，拥有完整的重排序缓冲区（ROB）、保留站（RS）和寄存器重命名能力。</li>
<li>InO线程执行严格顺序、非推测性的代码，绕过重命名和ROB，使用轻量级FIFO队列，显著降低硬件开销。</li>
<li>共享的物理寄存器文件（PRF）在运行时根据配置（如1 OoO + 4 InO）进行分区。</li>
<li>分支预测、加载/存储队列等资源也根据线程类型进行差异化配置。</li>
</ul>
</li>
<li><strong>软件层面</strong>:<ul>
<li>采用**软件工作窃取 **(software work stealing)机制（见Algorithm 1）来动态分配任务。线程在完成当前任务块后，会主动从全局任务池中“窃取”新任务。</li>
<li>该机制天然地实现了负载均衡：当OoO线程因高缓存未命中率而IPC下降时，空闲的InO线程会自动接管更多工作，反之亦然。</li>
<li><img alt="" src="../images/55b9d130369755da0560c6ce17669db65b00718ef5e3d416b5dcd93afb791d5e.jpg" /></li>
</ul>
</li>
</ul>
<p><em>Algorithm 1: SHADOW's Work Stealing Mechanism</em></p>
<ul>
<li><strong>评估方法</strong>:<ul>
<li>在<strong>gem5</strong>模拟器中基于高性能ARM Grace核心实现SHADOW模型。</li>
<li>使用包括<strong>SpMM</strong>（稀疏矩阵乘法）、CRONO和Rodinia在内的9个多样化基准测试程序进行评估。</li>
<li>对比基线包括纯OoO核心、MorphCore和FIFOShelf。</li>
</ul>
</li>
</ul>
<p><strong>结果</strong></p>
<ul>
<li><strong>性能提升</strong>:<ul>
<li>在9个基准测试上，SHADOW相比纯OoO CPU实现了最高<strong>3.16倍</strong>的加速比，平均提升<strong>1.33倍</strong>。</li>
<li>在高缓存未命中率的工作负载（如95%稀疏度的SpMM）上，混合配置（1 OoO + 4 InO）显著优于纯OoO或纯InO配置。</li>
<li><img alt="" src="../images/b6470f3c13f2aee6c49f0c390cd7c393b7b95af67b8a7f186d1eeafb38293903.jpg" /></li>
</ul>
</li>
</ul>
<p><em>Figure 13: Performance of SHADOW with varying degrees of sparsity for an 8 wide CPU over 1 OoO thread.</em></p>
<ul>
<li><strong>动态适应性</strong>:<ul>
<li>工作窃取机制能有效根据IPC动态调整各线程的工作量。在低稀疏度时，OoO线程承担大部分工作；在高稀疏度时，工作负载更均匀地分配给所有线程。</li>
<li><img alt="" src="../images/882fb687091b1b91a70b99910e9fe1f6c57e47ded3245a0ce1cc49633f0007d2.jpg" /></li>
</ul>
</li>
</ul>
<p><em>Figure 19: Distribution of work across threads with dynamic work stealing for various degrees of sparsity.</em></p>
<ul>
<li><strong>硬件开销</strong>:<ul>
<li>SHADOW仅引入了**1%**的面积和功耗开销，主要得益于InO线程省去了重命名和ROB等复杂逻辑。</li>
<li>关键硬件参数如下表所示：</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: left;">组件</th>
<th style="text-align: left;">基线 (OoO)</th>
<th style="text-align: left;">SHADOW (1 OoO + 4 InO)</th>
<th style="text-align: left;">开销</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">**物理寄存器文件 **(PRF)</td>
<td style="text-align: left;">256 Int / 192 FP</td>
<td style="text-align: left;">256 Int / 192 FP (分区)</td>
<td style="text-align: left;">0%</td>
</tr>
<tr>
<td style="text-align: left;">**重排序缓冲区 **(ROB)</td>
<td style="text-align: left;">320 entries</td>
<td style="text-align: left;">320 entries (OoO专用)</td>
<td style="text-align: left;">0%</td>
</tr>
<tr>
<td style="text-align: left;">**保留站 **(RS)</td>
<td style="text-align: left;">192 entries</td>
<td style="text-align: left;">192 entries (分区)</td>
<td style="text-align: left;">0%</td>
</tr>
<tr>
<td style="text-align: left;"><strong>总面积/功耗</strong></td>
<td style="text-align: left;">100%</td>
<td style="text-align: left;">~101%</td>
<td style="text-align: left;"><strong>1%</strong></td>
</tr>
</tbody>
</table>
<p><strong>结论</strong></p>
<ul>
<li><strong>SHADOW</strong>通过在单个核心内<strong>同时</strong>执行<strong>OoO</strong>和<strong>InO</strong>线程，成功地在<strong>ILP</strong>和<strong>TLP</strong>之间实现了动态、高效的平衡。</li>
<li>其创新的<strong>非对称SMT</strong>设计，结合简单的<strong>软件工作窃取</strong>机制，能够无缝适应从计算密集型到内存密集型的各种工作负载，尤其擅长加速具有不规则内存访问模式的稀疏应用。</li>
<li>该架构在仅增加**1%**硬件开销的前提下，显著提升了性能，为通用处理器在面对现代异构工作负载时提供了一种高效、低成本的解决方案。</li>
</ul>
<hr />
<h2 id="2">2. 背景知识与核心贡献<a class="headerlink" href="#2" title="Permanent link">&para;</a></h2>
<p><strong>研究背景与动机</strong></p>
<ul>
<li>现代重要应用（如深度学习、图计算、稀疏矩阵运算）常因<strong>不规则的稀疏性</strong>和<strong>不可预测的内存访问模式</strong>，在 <strong>Instruction-Level Parallelism (ILP)</strong> 和 <strong>Thread-Level Parallelism (TLP)</strong> 之间动态切换。</li>
<li><strong>传统CPU架构存在根本性缺陷</strong>：<ul>
<li><strong>Out-of-Order (OoO) 核心</strong>：擅长挖掘ILP，但在内存密集型、高缓存未命中率的工作负载下，其<strong>重排序缓冲区 (ROB)</strong> 和<strong>保留站 (RS)</strong> 会迅速被长延迟的内存请求占满，导致性能急剧下降。</li>
<li><strong>In-Order (InO) 核心</strong>：轻量级，可支持高TLP，但无法通过乱序执行隐藏内存延迟，在需要高ILP的场景下效率低下。</li>
</ul>
</li>
<li><strong>现有SMT方案无法有效平衡ILP与TLP</strong>：<ul>
<li><strong>对称SMT</strong>（如Intel）：通常只支持少量（如2个）同构的OoO线程，无法充分利用TLP。</li>
<li><strong>模式切换架构</strong>（如MorphCore）：在纯OoO模式和纯InO模式间切换，<strong>无法同时利用ILP和TLP</strong>，当工作负载特性介于两者之间时会造成资源浪费。</li>
<li><strong>指令级混合架构</strong>（如FIFOShelf, FIFOrder）：通过复杂的硬件机制在单线程内将指令分流到OoO和InO路径，引入了高昂的<strong>跨路径依赖跟踪</strong>和<strong>错误恢复开销</strong>。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/4ce9a91b85a5a5b6260201ede6e530e005dad4616d5e7508ef03a202b2545473.jpg" /></p>
<p><em>Figure 4: Breakdown of IPC contributions from all threads for 95% sparse SpMM.</em></p>
<p><img alt="" src="../images/ee60c1cacbb8840d2141136830ec53cc1093e73aedd1d9ff0cb64b3ba5399649.jpg" /></p>
<p><em>Figure 3: Speedup of 95%-sparse SpMM on a single OoO thread, showing diminishing returns from enlarging the ROB/RS or LSQ sizes.</em></p>
<p><strong>核心贡献</strong></p>
<ul>
<li>提出了 <strong>SHADOW</strong>，这是<strong>首个不对称SMT (Asymmetric SMT) 核心</strong>，能够在<strong>同一个物理核心上同时并发执行OoO线程和多个InO线程</strong>，从而动态、无缝地平衡ILP与TLP。</li>
<li>SHADOW的核心创新在于其<strong>线程粒度的异构执行模型</strong>：<ul>
<li><strong>OoO线程</strong>：负责在计算密集或缓存友好阶段挖掘深度ILP。</li>
<li><strong>轻量级InO线程</strong>：在内存密集、高缓存未命中阶段，以极低的硬件开销（无重命名、无ROB）维持高TLP，持续处理任务。</li>
<li><strong>动态工作分配</strong>：通过一个简单的<strong>软件工作窃取 (software work stealing)</strong> 机制（如Algorithm 1所示），让线程根据自身执行效率（IPC）自动竞争工作块，无需复杂的硬件调度器。高IPC的OoO线程自然获取更多工作，而当其因内存停顿而变慢时，InO线程便能接管更多负载。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/55b9d130369755da0560c6ce17669db65b00718ef5e3d416b5dcd93afb791d5e.jpg" /></p>
<p><em>Algorithm 1: SHADOW's Work Stealing Mechanism</em></p>
<p><img alt="" src="../images/8b08b5a2a75a76711486fc0cc4235b8cd2a6a2a558f75f7c3063674e3baf7c9a.jpg" /></p>
<p><em>Figure 1: SHADOW dynamically redistributes work as IPC changes.High ILP skews execution toward the OoO thread, while a low IPC distributes the work more evenly. SHADOW adapts to the application without software intervention.</em></p>
<ul>
<li><strong>实现了卓越的性能与能效比</strong>：<ul>
<li>在九个多样化基准测试中，SHADOW相比传统的OoO CPU，实现了<strong>最高3.16倍</strong>的加速比和<strong>1.33倍</strong>的平均性能提升。</li>
<li>其硬件开销极低，仅引入<strong>1%的面积和功耗</strong> overhead，远优于增加独立核心或其他复杂方案。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: left;">对比维度</th>
<th style="text-align: left;">传统OoO SMT</th>
<th style="text-align: left;">MorphCore</th>
<th style="text-align: left;">FIFOShelf/FIFOrder</th>
<th style="text-align: left;"><strong>SHADOW</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>执行模式</strong></td>
<td style="text-align: left;">同构OoO</td>
<td style="text-align: left;">模式切换 (OoO <em>或</em> InO)</td>
<td style="text-align: left;">指令分流 (单线程内)</td>
<td style="text-align: left;"><strong>并发异构 (OoO <em>和</em> InO)</strong></td>
</tr>
<tr>
<td style="text-align: left;"><strong>ILP/TLP平衡</strong></td>
<td style="text-align: left;">差</td>
<td style="text-align: left;">中等 (非同时)</td>
<td style="text-align: left;">好 (但开销大)</td>
<td style="text-align: left;"><strong>优秀 (同时且高效)</strong></td>
</tr>
<tr>
<td style="text-align: left;"><strong>硬件复杂度</strong></td>
<td style="text-align: left;">低</td>
<td style="text-align: left;">中等</td>
<td style="text-align: left;"><strong>高</strong> (跨路径逻辑)</td>
<td style="text-align: left;"><strong>低</strong> (线程级分区)</td>
</tr>
<tr>
<td style="text-align: left;"><strong>面积/功耗开销</strong></td>
<td style="text-align: left;">基准</td>
<td style="text-align: left;">较高</td>
<td style="text-align: left;">高</td>
<td style="text-align: left;"><strong>仅1%</strong></td>
</tr>
</tbody>
</table>
<hr />
<h2 id="3">3. 核心技术和实现细节<a class="headerlink" href="#3" title="Permanent link">&para;</a></h2>
<h3 id="0_1">0. 技术架构概览<a class="headerlink" href="#0_1" title="Permanent link">&para;</a></h3>
<p><strong>整体架构概述</strong></p>
<p>SHADOW 是一种<strong>不对称的 SMT (Asymmetric SMT)</strong> 核心架构，其核心思想是在<strong>单个物理核心</strong>内<strong>同时</strong>执行 <strong>out-of-order (OoO)</strong> 和 <strong>in-order (InO)</strong> 两种类型的线程，以动态平衡 <strong>instruction-level parallelism (ILP)</strong> 与 <strong>thread-level parallelism (TLP)</strong>。</p>
<ul>
<li>OoO 线程负责在计算密集、缓存命中率高的阶段<strong>深度挖掘 ILP</strong>。</li>
<li>轻量级的 InO 线程则在内存密集、高缓存缺失率的阶段<strong>高效扩展 TLP</strong>，且不引入 OoO 执行的复杂性和开销（如寄存器重命名、推测执行）。</li>
<li>该架构通过一个简单的<strong>软件工作窃取 (software work stealing)</strong> 机制实现动态负载均衡，无需复杂的硬件协调逻辑。</li>
</ul>
<p><img alt="" src="../images/8b08b5a2a75a76711486fc0cc4235b8cd2a6a2a558f75f7c3063674e3baf7c9a.jpg" /></p>
<p><em>Figure 1: SHADOW dynamically redistributes work as IPC changes.High ILP skews execution toward the OoO thread, while a low IPC distributes the work more evenly. SHADOW adapts to the application without software intervention.</em></p>
<hr />
<p><strong>微架构设计细节</strong></p>
<p>SHADOW 的微架构基于一个高性能的 OoO 核心进行扩展，关键修改点如下：</p>
<ul>
<li>
<p><strong>Fetch &amp; Decode 阶段</strong>:</p>
<ul>
<li>支持最多 <strong>6 个 SMT 上下文</strong>，每个上下文拥有独立的 PC。</li>
<li><strong>OoO 线程</strong>拥有独立的 <strong>Return Address Stack (RAS)</strong> 用于分支预测。</li>
<li><strong>InO 线程</strong>不进行分支预测，遇到分支时会暂停取指，直到分支解析完成。</li>
<li>使用 <strong>ICOUNT</strong> 策略选择线程进行取指和解码，并在资源占用相当时优先 OoO 线程以最大化 ILP。</li>
</ul>
</li>
<li>
<p><strong>Rename &amp; Issue 阶段</strong>:</p>
<ul>
<li><strong>OoO 指令</strong>：正常进行寄存器重命名，消除伪依赖，并分配到 <strong>Reorder Buffer (ROB)</strong> 和 <strong>Reservation Station (RS)</strong>。</li>
<li><strong>InO 指令</strong>：<strong>绕过重命名</strong>，直接进入一个<strong>每线程独立的轻量级 FIFO 队列</strong>。它们不占用 ROB 条目。</li>
<li><strong>RS 资源分区</strong>：运行时对 RS 进行分区，每个 InO 线程固定分配一个条目，其余条目由 OoO 线程均分。</li>
<li><strong>依赖追踪</strong>：InO 线程使用一个<strong>每线程的记分板 (scoreboard)</strong> 来追踪依赖，而非复杂的 CAM 广播。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/c64dcaa40be972466d4ce58da6c16bcb1dac63a8f11a741030b83334dd349f29.jpg" /></p>
<p><em>Figure 6: Microarchitecture of the fetch and decode stage configured with 1 OoO and 4 InO threads.</em></p>
<p><img alt="" src="../images/92f27eb7d0c1c9ce3c625c401476c7dcf672164a45b743b99227846c548fe33c.jpg" /></p>
<p><em>Figure 7: SHADoW's microarchitecture of the Rename and Wakeup+Select stages configured with 1OoO and 4 inO threads</em></p>
<ul>
<li><strong>Register File 分区</strong>:<ul>
<li>物理寄存器文件 (PRF) 在上下文切换时被动态分区。</li>
<li>每个 <strong>InO 线程</strong>被分配数量等于<strong>架构寄存器文件 (ARF)</strong> 大小的寄存器。</li>
<li>剩余的寄存器由 <strong>OoO 线程</strong>共享。</li>
<li>OoO 线程采用类似 <strong>Pentium 4</strong> 的重命名方案，使用 <strong>Register Alias Table (RAT)</strong> 来管理推测状态和架构状态。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/a01a27e8489933d9fd4f92dfc71a227674c139e8344d13e9e2366e5f299a4376.jpg" /></p>
<p><em>Figure 8: Register File partitioning in SHADOW.</em></p>
<ul>
<li>
<p><strong>Load/Store Queues (LSQ)</strong>:</p>
<ul>
<li><strong>OoO 线程</strong>：拥有专用的 LSQ 分区，支持<strong>推测性加载</strong>。</li>
<li><strong>InO 线程</strong>：<strong>不使用 Load Queue</strong>，执行保守的非推测性加载；每个 InO 线程分配少量 Store Queue 条目。</li>
</ul>
</li>
<li>
<p><strong>Commit 阶段</strong>:</p>
<ul>
<li><strong>只有 OoO 线程需要提交 (commit)</strong>，因为它们是推测执行的。</li>
<li><strong>InO 线程是非推测性的</strong>，指令在执行完成后即生效，无需提交阶段。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/8d28aa1cbe5ba02357a36985ddd5b6eaa0005ea5445e853fd4ea1781d8b53f52.jpg" /></p>
<p><em>Figure 5: Microarchitecture design of SHADOW configured with 1 OoO and 4 InO threads.</em></p>
<hr />
<p><strong>动态工作分配与配置</strong></p>
<ul>
<li><strong>软件工作窃取</strong>: 应用程序通过一个简单的 Pthreads 工作窃取循环（见 Algorithm 1）来分配任务。OoO 线程在 IPC 高时自然窃取更多工作，而当其因内存停顿导致 IPC 下降时，InO 线程会接管更多工作负载。</li>
</ul>
<p><img alt="" src="../images/55b9d130369755da0560c6ce17669db65b00718ef5e3d416b5dcd93afb791d5e.jpg" /></p>
<p><em>Algorithm 1: SHADOW's Work Stealing Mechanism</em></p>
<ul>
<li><strong>运行时可配置性</strong>: 通过一个特殊的 <code>shdw_cfg</code> 指令，操作系统可以在上下文切换时动态设置 OoO 和 InO 线程的数量（例如 1 OoO + 4 InO, 2 OoO + 2 InO 等），配置信息存储在进程控制块 (PCB) 中。</li>
</ul>
<hr />
<p><strong>硬件开销与性能</strong></p>
<p>SHADOW 在保持高性能的同时，实现了极低的硬件开销。</p>
<table>
<thead>
<tr>
<th style="text-align: left;">开销类型</th>
<th style="text-align: left;">数值</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>面积开销</strong></td>
<td style="text-align: left;"><strong>~1%</strong></td>
<td style="text-align: left;">主要来自额外的 FIFO 队列、记分板和多路复用器，PRF、ROB、RS 等主要结构大小不变。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>功耗开销</strong></td>
<td style="text-align: left;"><strong>~1%</strong></td>
<td style="text-align: left;">与面积开销一致。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>频率影响</strong></td>
<td style="text-align: left;"><strong>~2.5% 降低</strong></td>
<td style="text-align: left;">与 MorphCore 类似，源于关键路径上增加的多路复用器。</td>
</tr>
</tbody>
</table>
<p><img alt="" src="../images/efec98a9627c2c1ce68ca0956e70191f88ea96a8e568aa5c20a8c3cedac80c1d.jpg" /></p>
<p><em>Table 4: Hardware overhead of SHADOW</em></p>
<p>在性能方面，SHADOW 相比传统 OoO 核心，在多样化的基准测试中实现了显著提升：</p>
<ul>
<li><strong>最高加速比</strong>: <strong>3.16X</strong></li>
<li><strong>平均加速比</strong>: <strong>1.33X</strong></li>
</ul>
<h3 id="1-asymmetric-thread-co-execution">1. 异构线程并发执行 (Asymmetric Thread Co-execution)<a class="headerlink" href="#1-asymmetric-thread-co-execution" title="Permanent link">&para;</a></h3>
<p><strong>核心实现原理</strong></p>
<p>SHADOW 的核心创新在于其 <strong>异构线程并发执行 (Asymmetric Thread Co-execution)</strong> 模型，它打破了传统 SMT 中所有线程必须采用相同微架构策略（全为 OoO 或全为 InO）的限制。其实现原理并非通过复杂的指令流动态重定向或模式切换，而是通过在硬件层面为不同类型的线程提供专用的、隔离的执行路径。</p>
<ul>
<li><strong>线程类型划分</strong>：软件在运行时通过一个特殊的 <code>shdw_cfg</code> 指令向硬件声明线程配置（例如，1个 OoO 线程 + 4个 InO 线程）。操作系统将此配置保存在进程控制块（PCB）中，并在上下文切换时应用。</li>
<li><strong>硬件资源分区</strong>：硬件根据配置对关键共享资源进行静态或半静态分区：<ul>
<li><strong>寄存器文件 (Register File)</strong>：如</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/a01a27e8489933d9fd4f92dfc71a227674c139e8344d13e9e2366e5f299a4376.jpg" /></p>
<p><em>Figure 8: Register File partitioning in SHADOW.</em></p>
<p>所示，InO 线程直接使用 <strong>Architectural Register File (ARF)</strong> 的映射，每个 InO 线程分配固定数量的物理寄存器。剩余的物理寄存器则在 OoO 线程间共享，并通过 <strong>Register Alias Table (RAT)</strong> 进行重命名管理。
- <strong>重排序缓冲区 (ROB)</strong>：仅 OoO 线程的指令会分配 ROB 条目，用于支持乱序执行和精确异常。InO 线程完全绕过 ROB。
- <strong>保留站 (Reservation Station, RS)</strong>：RS 被划分为两个区域。OoO 线程的指令进入传统的、支持复杂依赖唤醒的 RS。每个 InO 线程则被分配一个轻量级的 <strong>FIFO 队列</strong>（本质上是单个或少量 RS 条目），其依赖检查通过简单的 <strong>scoreboard</strong> 机制完成，避免了昂贵的 CAM 比较。</p>
<ul>
<li><strong>流水线阶段协同</strong>：如</li>
</ul>
<p><img alt="" src="../images/8d28aa1cbe5ba02357a36985ddd5b6eaa0005ea5445e853fd4ea1781d8b53f52.jpg" /></p>
<p><em>Figure 5: Microarchitecture design of SHADOW configured with 1 OoO and 4 InO threads.</em></p>
<p>所示，两种线程在前端（Fetch/Decode）共享资源，但在 Rename 阶段分道扬镳。OoO 指令进行重命名后进入 RS，而 InO 指令则直接进入其专属 FIFO。在后端（Execute/Writeback），它们共享执行单元，但只有 OoO 指令需要经过 Commit 阶段。</p>
<p><strong>动态工作负载分配算法</strong></p>
<p>SHADOW 本身不包含复杂的硬件调度器来分配工作。其动态适应性源于一个简单的 <strong>软件工作窃取 (Software Work Stealing)</strong> 机制，该机制与异构硬件天然契合。</p>
<ul>
<li><strong>算法流程 (Algorithm 1)</strong>：<ul>
<li>应用程序将总工作负载划分为多个 <strong>Chunk</strong>。</li>
<li>所有线程（无论 OoO 或 InO）在一个循环中运行。</li>
<li>每次循环，线程通过获取一个全局锁来“窃取”一个 Chunk 的索引。</li>
<li>线程处理完分配到的 Chunk 后，立即返回循环顶部尝试窃取下一个 Chunk。</li>
</ul>
</li>
<li><strong>输入输出关系</strong>：<ul>
<li><strong>输入</strong>：一个可并行化的任务（由多个独立或弱依赖的 Chunk 组成）；一个指定的 <code>CHUNK_SIZE</code>。</li>
<li><strong>输出</strong>：任务被所有线程（OoO 和 InO）共同完成。</li>
</ul>
</li>
<li><strong>在整体中的作用</strong>：这个看似简单的机制是 SHADOW 实现 <strong>动态 ILP-TLP 平衡</strong>的关键。当 OoO 线程因高缓存未命中率而 IPC（Instructions Per Cycle）下降时，它窃取新 Chunk 的速度变慢。此时，轻量级的 InO 线程（不受长延迟停顿影响）能更快地完成自己的 Chunk 并窃取更多工作，从而自动承担起更多的计算负载。反之，在计算密集型场景下，高 IPC 的 OoO 线程会主导工作窃取。这种负载分配是 <strong>去中心化</strong> 且 <strong>自适应</strong> 的，无需硬件干预。</li>
</ul>
<p><strong>关键参数设置与配置</strong></p>
<p>SHADOW 的性能高度依赖于正确的线程配置，这需要根据工作负载特性进行选择。</p>
<ul>
<li><strong>主要配置参数</strong>：<code>&lt;#OoO&gt;, &lt;#InO&gt;</code>，即 OoO 线程数和 InO 线程数。总和受物理寄存器总数限制。</li>
<li><strong>典型配置示例</strong>：<ul>
<li><strong>1 OoO + 4 InO</strong>：这是论文中针对 <strong>内存密集型</strong> 工作负载（如高稀疏度 SpMM）的最优配置，能在 ILP 和 TLP 之间取得最佳平衡。</li>
<li><strong>1 OoO</strong>：适用于 <strong>计算密集型</strong> 且 <strong>缓存敏感</strong> 的工作负载（如 Dense Matrix Multiplication），避免多线程带来的缓存冲突。</li>
<li><strong>3 OoO</strong>：适用于能从更高 ILP 中受益且 L2 未命中率能因 TLP 而降低的工作负载（如 TSP）。</li>
</ul>
</li>
<li><strong>其他重要参数</strong>：<ul>
<li><strong>CHUNK_SIZE</strong>：工作窃取的粒度。较小的值（如 1）能实现更精细的负载均衡，但会增加锁竞争开销。论文指出，对于混合配置，<code>CHUNK_SIZE=1</code> 通常能获得最佳性能。</li>
</ul>
</li>
</ul>
<p><strong>性能优势与硬件开销</strong></p>
<p>通过这种设计，SHADOW 在极低的硬件成本下实现了显著的性能提升。</p>
<ul>
<li><strong>性能指标</strong>：在九个多样化基准测试中，SHADOW 相比纯 OoO 核心实现了最高 <strong>3.16X</strong> 的加速比和 <strong>1.33X</strong> 的平均加速比。</li>
<li><strong>硬件开销</strong>：如</li>
</ul>
<p><img alt="" src="../images/efec98a9627c2c1ce68ca0956e70191f88ea96a8e568aa5c20a8c3cedac80c1d.jpg" /></p>
<p><em>Table 4: Hardware overhead of SHADOW</em></p>
<p>所示，由于 InO 线程复用了大部分执行单元并省略了重命名、ROB 等复杂结构，其面积和功耗开销仅为 <strong>1%</strong>。</p>
<ul>
<li><strong>与竞品对比</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: left;">架构</th>
<th style="text-align: left;">核心思想</th>
<th style="text-align: left;">主要缺点</th>
<th style="text-align: left;">SHADOW 优势</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>MorphCore</strong></td>
<td style="text-align: left;">在 OoO 模式和 InO 模式间切换</td>
<td style="text-align: left;">无法同时利用 ILP 和 TLP</td>
<td style="text-align: left;"><strong>并发执行</strong>，无缝适应</td>
</tr>
<tr>
<td style="text-align: left;"><strong>FIFOShelf/FIFOrder</strong></td>
<td style="text-align: left;">在单线程内将指令分流到 OoO/InO 路径</td>
<td style="text-align: left;">需要复杂的跨路径依赖跟踪和恢复逻辑</td>
<td style="text-align: left;"><strong>线程级分区</strong>，无推测开销，硬件简单</td>
</tr>
</tbody>
</table>
<hr />
<p><img alt="" src="../images/71829aec55b1fa03a28462b26db7f62b428c5f97fbc3eba5a5af98543dd377f3.jpg" /></p>
<p><em>Figure 9: Impact of adding an InO Thread to an OoO system: An illustrative assembly example.</em></p>
<p>该图直观地展示了异构并发执行的优势。在纯 OoO 执行中，一个长延迟的 Load 指令会阻塞整个 ROB，即使后续指令已准备好也无法发射。而在 SHADOW 的 1-OoO+1-InO 配置下，InO 线程的指令完全绕过 ROB，可以持续利用空闲的执行单元，从而显著提升了 <strong>Memory-Level Parallelism (MLP)</strong> 和整体吞吐量。</p>
<h3 id="2-dynamic-work-stealing-mechanism">2. 动态工作窃取机制 (Dynamic Work Stealing Mechanism)<a class="headerlink" href="#2-dynamic-work-stealing-mechanism" title="Permanent link">&para;</a></h3>
<p><strong>实现原理与核心思想</strong></p>
<ul>
<li>SHADOW 的动态工作窃取机制是一种<strong>去中心化 (decentralized)</strong> 的软件策略，完全在<strong>用户空间 (user space)</strong> 实现，无需硬件干预或复杂的 OS 调度器支持。</li>
<li>其核心思想是利用 <strong>OoO 线程</strong>和 <strong>InO 线程</strong>在不同 workload 特征下的<strong>固有执行效率差异</strong>，让线程通过一个简单的、竞争性的协议来“贪婪地”获取工作。</li>
<li>当 <strong>ILP 高、缓存命中率高</strong>时，OoO 线程的 <strong>IPC (Instructions Per Cycle)</strong> 远高于 InO 线程，因此它能更快地完成手头工作并返回去窃取下一块任务，从而自然地承担了大部分负载。</li>
<li>当 <strong>内存瓶颈严重、L2 cache misses 高</strong>时，OoO 线程因 <strong>ROB (Reorder Buffer)</strong> 被长延迟的 load 指令填满而停滞，其 IPC 急剧下降。此时，轻量级的 InO 线程不受 speculative overhead 影响，能够持续地窃取并处理新任务，维持系统吞吐量。</li>
<li>这种负载再分配是<strong>自适应 (adaptive)</strong> 和<strong>涌现式 (emergent)</strong> 的，源于线程独立的行为，而非中央控制器的指令。</li>
</ul>
<p><strong>算法流程与参数设置</strong></p>
<ul>
<li>该机制通过标准的 <strong>Pthreads</strong> 库实现，其伪代码如 Algorithm 1 所示。</li>
<li>关键参数是 <strong><code>CHUNK_SIZE</code></strong>，它定义了每次窃取的工作单元大小（例如，循环迭代的次数）。<ul>
<li>较小的 <code>CHUNK_SIZE</code>（如 1）能实现更精细的负载均衡，但会增加锁竞争开销。</li>
<li>较大的 <code>CHUNK_SIZE</code> 会降低锁竞争，但可能导致负载不均，尤其是在 workload 特征快速变化时。</li>
</ul>
</li>
<li>算法流程如下：<ul>
<li>主线程初始化一个全局的 <strong><code>currentChunk</code></strong> 计数器和一个互斥锁。</li>
<li>工作线程（无论是 OoO 还是 InO 类型）被创建后，进入一个无限循环。</li>
<li>在循环中，线程首先<strong>获取锁</strong>，以原子方式读取并更新 <code>currentChunk</code>，从而获得自己本次要处理的 chunk 索引。</li>
<li>线程<strong>释放锁</strong>后，独立执行分配给它的 <code>CHUNK_SIZE</code> 个任务单元。</li>
<li>执行完毕后，线程立即回到循环起点，尝试窃取下一个 chunk，直到所有工作完成（<code>currentChunk</code> 超出总工作量）。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/55b9d130369755da0560c6ce17669db65b00718ef5e3d416b5dcd93afb791d5e.jpg" /></p>
<p><em>Algorithm 1: SHADOW's Work Stealing Mechanism</em></p>
<p><strong>输入输出关系及在整体架构中的作用</strong></p>
<ul>
<li><strong>输入</strong>: 一个可被分割成多个独立或近似独立单元的<strong>并行 workload</strong>（例如，SpMM 中的矩阵行）。</li>
<li><strong>输出</strong>: 一个根据实时执行效率（由 ILP/TLP 特性决定）动态调整的<strong>工作负载分配方案</strong>。</li>
<li><strong>在 SHADOW 架构中的作用</strong>:<ul>
<li><strong>桥梁作用</strong>: 它是连接上层应用并行模型与底层不对称硬件（OoO + InO lanes）的关键桥梁。没有它，硬件的不对称性无法被有效利用。</li>
<li><strong>简化编程模型</strong>: 对程序员而言，只需将 workload 按 chunk 分割，并使用标准的 Pthreads 或类似 runtime（如 <strong>Intel TBB</strong>, <strong>Cilk</strong>, <strong>OpenMP</strong>），SHADOW 就能自动优化执行。这保持了<strong>通用可编程性 (general-purpose programmability)</strong>。</li>
<li><strong>实现动态平衡</strong>: 它是 SHADOW 能够“无缝且高效地适应 workload 变化”的核心驱动力，使得 <strong>ILP-TLP balancing</strong> 成为可能。</li>
</ul>
</li>
</ul>
<p><strong>效果验证与数据支撑</strong></p>
<ul>
<li>Figure 19 直观地展示了该机制的效果。随着 SpMM <strong>sparsity</strong> 增加（从 50% 到 98%），OoO 线程处理的迭代次数占比从主导地位逐渐下降，最终与 InO 线程趋于均等，完美体现了动态再分配。</li>
<li>实验表明，对于 95% sparse 的 SpMM，<code>CHUNK_SIZE</code> 的选择对混合配置（1 OoO + 4 InO）有一定影响：从 <code>CHUNK_SIZE=1</code> 时的 <strong>1.53x</strong> speedup 下降到 <code>CHUNK_SIZE=50</code> 时的 <strong>1.25x</strong>，证明了细粒度窃取的优势。</li>
</ul>
<p><img alt="" src="../images/882fb687091b1b91a70b99910e9fe1f6c57e47ded3245a0ce1cc49633f0007d2.jpg" /></p>
<p><em>Figure 19: Distribution of work across threads with dynamic work stealing for various degrees of sparsity.</em></p>
<hr />
<p><strong>潜在挑战与考量</strong></p>
<ul>
<li><strong>锁竞争 (Lock Contention)</strong>: 当大量线程同时完成工作并试图窃取新 chunk 时，对 <code>currentChunk</code> 锁的竞争会成为瓶颈，尤其是在 <code>CHUNK_SIZE</code> 很小的情况下。</li>
<li><strong>缓存性能影响</strong>: 动态的工作分配可能导致数据在不同线程间迁移，破坏数据局部性，对 <strong>cache-sensitive</strong> 的 workload 产生负面影响（如 Section 5.1 所述）。</li>
<li><strong>操作系统透明性</strong>: <strong>OS scheduler</strong> 将每个 pthread 视为普通内核线程，对 SHADOW 内部的 OoO/InO 不对称性一无所知。这意味着 OS 的调度决策（如 core migration）可能与 SHADOW 的优化目标不一致。目前的设计假设单个应用独占一个 SHADOW 核心。</li>
</ul>
<h3 id="3-lightweight-in-order-threads">3. 轻量级顺序线程设计 (Lightweight In-Order Threads)<a class="headerlink" href="#3-lightweight-in-order-threads" title="Permanent link">&para;</a></h3>
<p><strong>轻量级顺序线程（In-Order Threads）的核心设计原理</strong></p>
<p>SHADOW架构中的轻量级顺序线程（In-Order, InO）是其能够以极低开销实现高TLP的关键。其设计理念是通过大幅简化硬件逻辑，避免传统OoO执行带来的复杂性和资源消耗。</p>
<ul>
<li><strong>绕过关键OoO结构</strong>：InO线程在流水线中完全<strong>绕过重命名（Rename）阶段</strong>和<strong>重排序缓冲区（ROB）</strong>。这意味着它们不参与寄存器重命名，也不需要为每条指令分配ROB条目来管理推测状态和提交。</li>
<li><strong>使用轻量级FIFO队列</strong>：解码后的InO指令被直接送入一个<strong>per-thread circular FIFO queue</strong>（每个线程一个循环FIFO队列），该队列在空闲时可以断电以节省能耗。这个FIFO替代了ROB的功能，用于暂存待发射的指令。</li>
<li><strong>非推测性执行</strong>：InO线程<strong>不进行任何推测执行（speculation）</strong>。分支指令不会被预测，而是会阻塞取指直到分支结果确定。同样，加载指令也是保守执行的，必须等待TLB命中后才能继续，以避免因重放（replay）导致的错误状态。</li>
<li><strong>简化的依赖跟踪</strong>：为了在不使用重命名的情况下处理数据依赖，每个InO线程配备了一个<strong>per-thread scoreboard</strong>（每个线程一个记分板）。这是一个多端口的位表，用于跟踪源寄存器的就绪状态。当一条指令的所有源操作数都就绪时，它才会被标记为可执行。</li>
<li><strong>精简的保留站（RS）分配</strong>：在运行时，保留站（RS）会被动态划分。<strong>每个InO线程仅被分配一个RS条目</strong>，这极大地降低了硬件复杂度。相比之下，OoO线程会共享剩余的大部分RS资源。</li>
</ul>
<p><img alt="" src="../images/92f27eb7d0c1c9ce3c625c401476c7dcf672164a45b743b99227846c548fe33c.jpg" /></p>
<p><em>Figure 7: SHADoW's microarchitecture of the Rename and Wakeup+Select stages configured with 1OoO and 4 inO threads</em></p>
<p><strong>在整体流水线中的作用与输入输出关系</strong></p>
<p>InO线程的设计使其能够与OoO线程无缝协同工作，共同提升核心的整体资源利用率。</p>
<ul>
<li><strong>输入</strong>：来自独立程序计数器（PC）的指令流。每个InO线程拥有自己的PC和取指队列，但不包含返回地址栈（RAS）等用于推测的结构。</li>
<li><strong>处理流程</strong>：<ul>
<li><strong>取指与译码</strong>：与其他SMT线程一样，通过ICOUNT策略从指令缓存（ICache）中轮流取指并译码。</li>
<li><strong>指令放置</strong>：译码后的指令绕过重命名，直接进入其专属的FIFO队列，并根据静态物理寄存器文件（PRF）映射获取操作数。</li>
<li><strong>唤醒与选择</strong>：通过记分板检查依赖。一旦依赖满足，指令便占用其唯一的RS条目，并请求执行单元。</li>
<li><strong>执行与写回</strong>：与OoO线程共享执行单元（ALU等）和写回旁路网络，从PRF读取操作数并写回结果。</li>
<li><strong>提交</strong>：由于是非推测执行，InO线程<strong>没有提交（Commit）阶段</strong>。指令一旦写回，其结果即为最终的、正确的架构状态。</li>
</ul>
</li>
<li><strong>输出</strong>：对物理寄存器文件（PRF）的更新。这些更新是即时且不可逆的。</li>
<li><strong>在SHADOW中的作用</strong>：<ul>
<li><strong>填补OoO空窗期</strong>：当OoO线程因长延迟的<strong>cache miss</strong>而停滞，其ROB被占满无法发射新指令时，InO线程可以利用空闲的执行单元继续处理任务，从而维持核心的吞吐量。</li>
<li><strong>高效利用TLP</strong>：对于具有大量<strong>thread-level parallelism (TLP)</strong> 的工作负载（如SpMM），多个InO线程可以并行处理独立的数据块，而无需承担OoO硬件的开销。</li>
<li><strong>降低硬件成本</strong>：通过复用OoO核心的大部分后端资源（执行单元、PRF、Cache），仅增加极少量的专用逻辑（FIFO、记分板），实现了<strong>仅1%的面积和功耗开销</strong>。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/71829aec55b1fa03a28462b26db7f62b428c5f97fbc3eba5a5af98543dd377f3.jpg" /></p>
<p><em>Figure 9: Impact of adding an InO Thread to an OoO system: An illustrative assembly example.</em></p>
<hr />
<p><strong>硬件开销与资源配置细节</strong></p>
<p>InO线程的轻量化设计直接体现在其极低的硬件资源占用上。</p>
<ul>
<li><strong>寄存器文件（Register File）分配</strong>：InO线程仅使用与<strong>架构寄存器文件（ARF）</strong> 数量相等的物理寄存器。例如，如果ARF有32个整数寄存器，那么每个InO线程就分配32个物理寄存器。剩余的物理寄存器则由OoO线程共享。</li>
<li><strong>无重命名开销</strong>：省去了重命名表（RAT）、空闲列表（Free List）以及相关的CAM（内容寻址存储器）比较逻辑，这是OoO设计中最复杂的部分之一。</li>
<li><strong>精简的Load/Store处理</strong>：InO线程<strong>不使用加载队列（Load Queue）</strong>，其加载指令只检查存储队列（Store Queue）以确保正确性。每个InO线程仅分配<strong>5个存储队列（Store Queue）</strong> 条目。</li>
<li><strong>无分支预测单元</strong>：InO线程的分支预测逻辑被完全移除，进一步简化了前端设计。</li>
</ul>
<p>下表总结了SHADOW引入InO线程所带来的主要硬件改动和开销：</p>
<table>
<thead>
<tr>
<th style="text-align: left;">组件</th>
<th style="text-align: left;">OoO线程行为</th>
<th style="text-align: left;">InO线程行为</th>
<th style="text-align: left;">硬件影响</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>重命名 (Rename)</strong></td>
<td style="text-align: left;">执行寄存器重命名</td>
<td style="text-align: left;"><strong>绕过</strong></td>
<td style="text-align: left;">移除InO的重命名逻辑</td>
</tr>
<tr>
<td style="text-align: left;"><strong>ROB</strong></td>
<td style="text-align: left;">每条指令分配条目</td>
<td style="text-align: left;"><strong>不使用</strong></td>
<td style="text-align: left;">InO不消耗ROB资源</td>
</tr>
<tr>
<td style="text-align: left;"><strong>指令窗口</strong></td>
<td style="text-align: left;">大型ROB/RS</td>
<td style="text-align: left;"><strong>Per-thread FIFO</strong></td>
<td style="text-align: left;">增加小型FIFO队列</td>
</tr>
<tr>
<td style="text-align: left;"><strong>依赖跟踪</strong></td>
<td style="text-align: left;">通过Tag广播</td>
<td style="text-align: left;"><strong>Per-thread Scoreboard</strong></td>
<td style="text-align: left;">增加简单记分板</td>
</tr>
<tr>
<td style="text-align: left;"><strong>推测执行</strong></td>
<td style="text-align: left;">支持</td>
<td style="text-align: left;"><strong>不支持</strong></td>
<td style="text-align: left;">移除InO的推测和回滚机制</td>
</tr>
<tr>
<td style="text-align: left;"><strong>分支预测</strong></td>
<td style="text-align: left;">支持</td>
<td style="text-align: left;"><strong>不支持</strong></td>
<td style="text-align: left;">移除InO的分支预测器</td>
</tr>
<tr>
<td style="text-align: left;"><strong>加载队列</strong></td>
<td style="text-align: left;">使用</td>
<td style="text-align: left;"><strong>不使用</strong></td>
<td style="text-align: left;">InO不消耗Load Queue资源</td>
</tr>
<tr>
<td style="text-align: left;"><strong>提交</strong></td>
<td style="text-align: left;">需要提交阶段</td>
<td style="text-align: left;"><strong>无提交阶段</strong></td>
<td style="text-align: left;">简化提交逻辑</td>
</tr>
</tbody>
</table>
<p>这种设计使得SHADOW能够在几乎不增加成本的情况下，将一个强大的OoO核心转变为一个能同时高效处理ILP和TLP的混合引擎。</p>
<h3 id="4-runtime-configurable-resource-partitioning">4. 运行时可重构资源分区 (Runtime-Configurable Resource Partitioning)<a class="headerlink" href="#4-runtime-configurable-resource-partitioning" title="Permanent link">&para;</a></h3>
<p><strong>运行时可重构资源分区的实现原理</strong></p>
<p>SHADOW 的核心创新在于其 <strong>Runtime-Configurable Resource Partitioning</strong> 能力，这使其能够根据应用需求动态调整 OoO 与 InO 线程的数量配比。该机制通过一个名为 <code>shdw_cfg</code> 的特殊指令触发，并在 <strong>上下文切换 (context switch)</strong> 时由操作系统协同完成。</p>
<ul>
<li>
<p><strong>触发与控制</strong>:</p>
<ul>
<li>该过程由一个软件层面的 <strong>“delegate thread”</strong> 在 <code>pthread</code> 创建或上下文切换时透明地发起。</li>
<li>delegate thread 执行 <code>shdw_cfg &lt;#OoO&gt;, &lt;#InO&gt;</code> 指令，明确指定所需 OoO 和 InO 线程的数量。</li>
<li>操作系统将此配置信息存储在进程控制块 <strong>(PCB)</strong> 中，以便后续恢复。</li>
</ul>
</li>
<li>
<p><strong>硬件重配置流程</strong>:</p>
<ul>
<li><strong>前端重置</strong>: 激活指定数量的 OoO 和 InO 线程对应的程序计数器 <strong>(PC)</strong>。</li>
<li><strong>重命名表重配置</strong>: 将前 <code>&lt;#OoO&gt;</code> 个硬件线程上下文分配给 OoO 线程，其余分配给 InO 线程。每个 OoO 线程维护独立的物理寄存器 <strong>(PR)</strong> 空闲列表。</li>
<li><strong>执行资源分区</strong>: 根据指定的线程配置，动态划分后端关键结构，如 ROB 和 RS。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/a01a27e8489933d9fd4f92dfc71a227674c139e8344d13e9e2366e5f299a4376.jpg" /></p>
<p><em>Figure 8: Register File partitioning in SHADOW.</em></p>
<p><strong>关键共享资源的动态分区策略</strong></p>
<p><strong>物理寄存器文件 (PRF) 分区</strong></p>
<ul>
<li>PRF 的分区是整个机制的基础，其总大小固定（例如，256 个整数寄存器和 192 个浮点寄存器）。</li>
<li><strong>InO 线程</strong>: 每个 InO 线程被分配数量等于 <strong>架构寄存器文件 (ARF)</strong> 大小的连续物理寄存器。它们不进行寄存器重命名，因此无需额外的映射开销。</li>
<li><strong>OoO 线程</strong>: 所有剩余的物理寄存器被平均分配给 OoO 线程。每个 OoO 线程使用 <strong>Register Alias Table (RAT)</strong> 来管理其专属的物理寄存器池，以支持推测执行。</li>
<li><strong>分配公式</strong>: 若总物理寄存器数为 P，ARF 大小为 A，InO 线程数为 I，OoO 线程数为 O，则每个 OoO 线程获得 <code>(P - A·I) / O</code> 个寄存器。</li>
</ul>
<p><strong>重排序缓冲区 (ROB) 与保留站 (RS) 分区</strong></p>
<ul>
<li><strong>ROB</strong>: 仅由 OoO 线程使用。当存在多个 OoO 线程时，ROB 被 <strong>静态分区 (statically partitioned)</strong>，以防止线程间争用。</li>
<li><strong>RS</strong>: 在运行时进行动态分区。<ul>
<li>每个 InO 线程被分配 <strong>一个</strong> RS 条目，用于其严格的顺序发射。</li>
<li>剩余的所有 RS 条目被平均分配给 OoO 线程，供其进行乱序调度。</li>
</ul>
</li>
</ul>
<p><strong>加载/存储队列 (LSQ) 配置</strong></p>
<ul>
<li><strong>OoO 线程</strong>: 拥有专用的 LSQ 分区，支持推测性加载和存储。</li>
<li><strong>InO 线程</strong>: 不使用加载队列，执行保守的非推测性加载。每个 InO 线程被分配固定的 <strong>5 个</strong> 存储队列条目。</li>
</ul>
<p><strong>输入输出关系及在整体架构中的作用</strong></p>
<ul>
<li>
<p><strong>输入</strong>:</p>
<ul>
<li>应用程序通过 <code>shdw_cfg</code> 指令提供的 <strong>期望的 OoO/InO 线程数量</strong>。</li>
<li>操作系统的 <strong>上下文切换事件</strong>。</li>
</ul>
</li>
<li>
<p><strong>输出</strong>:</p>
<ul>
<li>一个 <strong>完全重配置的 CPU 核心微架构状态</strong>，其前端、重命名逻辑和后端执行资源均按照新配置进行了划分。</li>
<li>一组准备好执行的硬件线程上下文，其中 OoO 线程具备完整的乱序执行能力，而 InO 线程则以极简的顺序方式运行。</li>
</ul>
</li>
<li>
<p><strong>在 SHADOW 架构中的作用</strong>:</p>
<ul>
<li><strong>实现动态适应性</strong>: 该机制是 SHADOW 能够 <strong>无缝适应 (seamlessly adapt)</strong> 从计算密集型到内存密集型工作负载变化的根本保障。它允许硬件资源在 ILP 和 TLP 之间进行最优分配。</li>
<li><strong>支撑混合执行模型</strong>: 通过精确的资源隔离，确保了 OoO 和 InO 线程可以 <strong>并发执行 (concurrently execute)</strong> 而互不干扰，OoO 线程的推测失败不会影响 InO 线程。</li>
<li><strong>维持低开销</strong>: 整个重配置过程仅在上下文切换时发生，避免了运行时的性能损失。同时，由于 InO 线程的硬件开销极低（如每个线程仅需一个 RS 条目），使得这种灵活性带来的 <strong>面积和功耗开销仅为 1%</strong>。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: left;">资源类型</th>
<th style="text-align: left;">OoO 线程使用方式</th>
<th style="text-align: left;">InO 线程使用方式</th>
<th style="text-align: left;">分区策略</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>物理寄存器文件 (PRF)</strong></td>
<td style="text-align: left;">通过 RAT 重命名，使用分配到的私有池</td>
<td style="text-align: left;">直接映射到 ARF 大小的固定区域，无重命名</td>
<td style="text-align: left;">动态划分，基于 <code>shdw_cfg</code> 参数</td>
</tr>
<tr>
<td style="text-align: left;"><strong>重排序缓冲区 (ROB)</strong></td>
<td style="text-align: left;">用于指令排序、推测管理和提交</td>
<td style="text-align: left;"><strong>不使用</strong></td>
<td style="text-align: left;">静态分区（仅在多 OoO 线程间）</td>
</tr>
<tr>
<td style="text-align: left;"><strong>保留站 (RS)</strong></td>
<td style="text-align: left;">用于乱序调度和唤醒</td>
<td style="text-align: left;">每个线程使用 <strong>1 个</strong> 条目，顺序发射</td>
<td style="text-align: left;">运行时动态分区</td>
</tr>
<tr>
<td style="text-align: left;"><strong>加载/存储队列 (LSQ)</strong></td>
<td style="text-align: left;">完整的推测性加载/存储支持</td>
<td style="text-align: left;">无加载队列；<strong>5 个</strong> 固定存储条目</td>
<td style="text-align: left;">静态预留</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>当前限制与未来工作</strong></p>
<ul>
<li><strong>多应用支持限制</strong>: 当前设计仅支持 <strong>单个多线程应用</strong> 或 <strong>多个单线程应用</strong>。若要支持多个并发的多线程应用，操作系统需要在不同应用的不对称配置间复杂地划分共享资源，这会极大增加调度和上下文切换的复杂性。</li>
<li><strong>扩展性</strong>: 论文指出，将此模型扩展到 <strong>多核 (multi-core)</strong> 场景（例如，在 big.LITTLE 架构中将一个 big core 改造成 SHADOW core）是可行的，但跨多个 SHADOW 核心进行 OoO/InO 线程的负载均衡是一个留待未来研究的挑战。</li>
</ul>
<hr />
<h2 id="4">4. 实验方法与实验结果<a class="headerlink" href="#4" title="Permanent link">&para;</a></h2>
<p><strong>实验设置</strong></p>
<ul>
<li><strong>模拟平台</strong>: 基于 <strong>gem5</strong> 系统仿真模式实现，模拟了一个高性能的 <strong>ARM Grace</strong> 核心。</li>
<li><strong>基准配置</strong>: 详细的微架构参数见下表。该配置旨在代表一个现代高性能 OoO CPU。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: left;">组件</th>
<th style="text-align: left;">参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>Fetch Width</strong></td>
<td style="text-align: left;">8 (for 8-wide CPU) / 4 (for 4-wide CPU)</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Issue/Commit Width</strong></td>
<td style="text-align: left;">8 (for 8-wide CPU) / 4 (for 4-wide CPU)</td>
</tr>
<tr>
<td style="text-align: left;"><strong>ROB Size</strong></td>
<td style="text-align: left;">320 entries</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Physical Integer Registers</strong></td>
<td style="text-align: left;">256</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Physical FP Registers</strong></td>
<td style="text-align: left;">192</td>
</tr>
<tr>
<td style="text-align: left;"><strong>L1 I/D Cache</strong></td>
<td style="text-align: left;">64 KB, 4-way</td>
</tr>
<tr>
<td style="text-align: left;"><strong>L2 Cache</strong></td>
<td style="text-align: left;">2 MB, 16-way</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>对比基线</strong>:<ul>
<li><strong>单线程 OoO 核心</strong>: 作为主要性能基准。</li>
<li><strong>MorphCore</strong>: 一种模式切换型 SMT 架构，在 2 个 OoO 线程和最多 8 个 InO 线程之间切换。</li>
<li><strong>FIFOShelf</strong>: 一种指令级混合执行架构，通过推测性地将指令路由到 OoO 或 InO 路径来工作。评估时对其进行了乐观建模（例如，加倍 ROB）以提供性能上限。</li>
</ul>
</li>
<li><strong>测试集</strong>: 包含 <strong>9 个多样化</strong>的基准测试程序，涵盖计算密集型（如 Dense Matrix Multiplication, Pathfinder）和内存密集型（如 SpMM, APSP, Backprop）工作负载。SpMM（稀疏矩阵乘法）被用作主要的分析案例，通过调整<strong>稀疏度</strong>（50% 到 99%）和<strong>矩阵大小</strong>来系统性地改变工作负载特性。</li>
<li><strong>SHADOW 配置</strong>: 评估了多种线程组合，包括 <code>1 OoO</code>, <code>2 OoO</code>, <code>1 OoO + 4 InO</code>, 和 <code>6 InO</code>，以探索 ILP-TLP 平衡的最佳点。</li>
</ul>
<p><strong>结果数据分析</strong></p>
<ul>
<li><strong>整体性能</strong>: 在九个基准测试上，SHADOW 相对于单线程 OoO 核心实现了最高 <strong>3.16X</strong> 的加速比和 <strong>1.33X</strong> 的平均加速比。</li>
<li><strong>工作负载依赖性</strong>: SHADOW 的最佳配置高度依赖于工作负载特性。<ul>
<li><strong>高缓存未命中率工作负载</strong>（如 APSP, Backprop）: 混合配置（如 <code>1 OoO + 4 InO</code>）表现最佳，因为它能同时利用 OoO 线程的 ILP 和 InO 线程的 TLP，而不会像纯 OoO 那样因 ROB/RF 争用而饱和。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/c3f3a89c5608b14e7d1ecac5c9de6bb84634c30c84c52405d456af27e943af97.jpg" /></p>
<p><em>Figure 11: Geometric mean performance of SHADOW configurations on high D-cache miss rate benchmarks from Table 2, normalized to a single-threaded OoO core.</em></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a>- **低缓存未命中率工作负载**（如 Dense MM, NN）: 单 OoO 线程通常表现最好，因为增加线程会引入**缓存冲突未命中**，损害 OoO 线程的 ILP。
</code></pre></div>
<p><img alt="" src="../images/42292afc2ef60f23da1ddbf5c08bc567272f61e1b63461bfe21a6733462abba2.jpg" /></p>
<p><em>Figure 12: Geometric mean performance of SHADOW configurations on low D-cache miss rate benchmarks from Table 2, normalized to a single-threaded OoO core.</em></p>
<ul>
<li><strong>SpMM 案例研究</strong>:<ul>
<li><strong>稀疏度影响</strong>: 随着稀疏度增加（ILP 降低），纯 OoO 配置的性能急剧下降。<code>1 OoO + 4 InO</code> 配置在所有稀疏度下都保持领先，在 99% 稀疏度下达到 <strong>3.1X</strong> 加速比。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/b6470f3c13f2aee6c49f0c390cd7c393b7b95af67b8a7f186d1eeafb38293903.jpg" /></p>
<p><em>Figure 13: Performance of SHADOW with varying degrees of sparsity for an 8 wide CPU over 1 OoO thread.</em></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a>- **动态工作分配**: 通过软件工作窃取机制，工作负载能根据线程的即时吞吐能力（IPC）自动重新分配。在低稀疏度下，高 IPC 的 OoO 线程处理更多工作；在高稀疏度下，工作更均匀地分配给所有线程。
</code></pre></div>
<p><img alt="" src="../images/882fb687091b1b91a70b99910e9fe1f6c57e47ded3245a0ce1cc49633f0007d2.jpg" /></p>
<p><em>Figure 19: Distribution of work across threads with dynamic work stealing for various degrees of sparsity.</em></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a>- **IPC 分析**: `1 OoO + 4 InO` 配置在高稀疏度下维持了最高的总体 IPC，证明了其有效平衡 ILP 和 TLP 的能力。
</code></pre></div>
<p><img alt="" src="../images/96ef9c06b0f42979bf3890c4f6ed98d44c264234783f0b4192fbf7a19ff1ec47.jpg" /></p>
<p><em>Figure 18: Breakdown of IPC contribution from each thread with varying degrees of sparsity over 1 OoO thread.</em></p>
<p><strong>消融实验与开销分析</strong></p>
<ul>
<li><strong>硬件开销</strong>: SHADOW 的设计极其精简。InO 线程绕过重命名和 ROB，仅使用轻量级 FIFO 队列。评估显示，相比基础 OoO 核心，SHADOW 仅引入 <strong>1%</strong> 的面积和功耗开销。</li>
</ul>
<p><img alt="" src="../images/efec98a9627c2c1ce68ca0956e70191f88ea96a8e568aa5c20a8c3cedac80c1d.jpg" /></p>
<p><em>Table 4: Hardware overhead of SHADOW</em></p>
<ul>
<li><strong>与替代方案的对比</strong>:<ul>
<li><strong>vs. MorphCore</strong>: SHADOW 的 <code>1 OoO + 4 InO</code> 配置显著优于 MorphCore 的纯 OoO（2线程）或纯 InO（6线程）模式，因为它能<strong>同时</strong>利用两种并行性，而非在二者间切换。</li>
<li><strong>vs. FIFOShelf</strong>: SHADOW 的性能优于 FIFOShelf。这表明在<strong>线程粒度</strong>上进行划分（避免了跨路径依赖跟踪、推测唤醒等复杂机制）比在<strong>指令粒度</strong>上进行推测性路由更高效。</li>
</ul>
</li>
<li><strong>资源扩展的无效性</strong>: 实验表明，单纯扩大 OoO 核心的关键结构（如 ROB、RS、LSQ）对内存密集型工作负载（如 95% 稀疏的 SpMM）的收益<strong>递减</strong>，且带来巨大的面积和功耗成本。这凸显了引入 TLP（通过 InO 线程）的必要性。</li>
</ul>
<p><img alt="" src="../images/ee60c1cacbb8840d2141136830ec53cc1093e73aedd1d9ff0cb64b3ba5399649.jpg" /></p>
<p><em>Figure 3: Speedup of 95%-sparse SpMM on a single OoO thread, showing diminishing returns from enlarging the ROB/RS or LSQ sizes.</em></p>
<ul>
<li><strong>工作窃取机制的影响</strong>: 实验发现，<code>CHUNK_SIZE</code>（每次窃取的工作块大小）对混合配置的性能有一定影响，但总体上该机制是鲁棒的，能有效适应不同的工作负载压力。</li>
</ul>
<hr />












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.sections", "navigation.top", "navigation.indexes", "search.suggest", "search.highlight", "content.code.copy"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../../../javascripts/switcher.js"></script>
      
    
  </body>
</html>