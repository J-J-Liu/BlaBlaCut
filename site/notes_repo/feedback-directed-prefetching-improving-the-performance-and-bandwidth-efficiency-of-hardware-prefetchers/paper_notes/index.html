
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://example.com/notes_repo/feedback-directed-prefetching-improving-the-performance-and-bandwidth-efficiency-of-hardware-prefetchers/paper_notes/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Feedback Directed Prefetching: Improving the Performance and Bandwidth-Efficiency of Hardware Prefetchers 论文解析 - BlaBlaCut</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#feedback-directed-prefetching-improving-the-performance-and-bandwidth-efficiency-of-hardware-prefetchers" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="BlaBlaCut" class="md-header__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            BlaBlaCut
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Feedback Directed Prefetching: Improving the Performance and Bandwidth-Efficiency of Hardware Prefetchers 论文解析
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到深色模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换到深色模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到浅色模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换到浅色模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="BlaBlaCut" class="md-nav__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    BlaBlaCut
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/Recent/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Recent
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/awesome-data-prefetchers/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Awesome Data Prefetchers
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/micro-2025/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    MICRO 2025
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#0" class="md-nav__link">
    <span class="md-ellipsis">
      
        0. 论文基本信息
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. 摘要
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. 背景知识与核心贡献
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. 核心技术和实现细节
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3. 核心技术和实现细节">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#0_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        0. 技术架构概览
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. 动态反馈驱动的预取器激进度调整
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. 基于布隆过滤器的预取缓存污染估算
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. 基于污染感知的动态缓存插入策略
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. 基于采样的运行时反馈收集机制
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. 实验方法与实验结果
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="feedback-directed-prefetching-improving-the-performance-and-bandwidth-efficiency-of-hardware-prefetchers">Feedback Directed Prefetching: Improving the Performance and Bandwidth-Efficiency of Hardware Prefetchers 论文解析<a class="headerlink" href="#feedback-directed-prefetching-improving-the-performance-and-bandwidth-efficiency-of-hardware-prefetchers" title="Permanent link">&para;</a></h1>
<h2 id="0">0. 论文基本信息<a class="headerlink" href="#0" title="Permanent link">&para;</a></h2>
<p><strong>作者 (Authors)</strong>
- Santhosh Srinath†‡
- Onur Mutlu§
- Hyesoon Kim‡
- Yale N. Patt‡</p>
<p><strong>发表期刊/会议 (Journal/Conference)</strong>
- 该论文未在提供的文本中明确指出其发表的期刊或会议名称。</p>
<p><strong>发表年份 (Publication Year)</strong>
- 该论文未在提供的文本中明确指出其发表年份。</p>
<hr />
<h2 id="1">1. 摘要<a class="headerlink" href="#1" title="Permanent link">&para;</a></h2>
<p><strong>目的</strong>
- 解决传统硬件数据预取器（hardware data prefetcher）存在的两大核心问题：<strong>性能不稳定</strong>（在某些程序上因过度激进的预取导致性能严重下降）和<strong>内存带宽效率低下</strong>（产生大量无用预取，浪费带宽并引发缓存污染）。
- 提出一种通用的、基于动态反馈的机制，以提升预取器的<strong>性能</strong>和<strong>带宽效率</strong>。</p>
<p><strong>方法</strong>
- 提出 <strong>Feedback Directed Prefetching (FDP)</strong> 机制，通过实时监控三个关键指标来动态调整预取行为：
  - <strong>Prefetch Accuracy </strong>(预取准确率)：衡量预取的数据块中有多少被后续的实际需求（demand access）所使用。
  - <strong>Prefetch Lateness </strong>(预取延迟)：衡量有用的预取请求中有多少未能及时返回，导致需求访问时仍需等待。
  - <strong>Prefetcher-Generated Cache Pollution </strong>(预取器引发的缓存污染)：衡量因预取数据而被驱逐、且后续又被需求访问的缓存块数量。
- 设计了低成本的硬件结构来收集上述反馈信息：
  - 使用 <strong>pref-bit</strong> 标记预取块，并通过计数器 <code>pref-total</code> 和 <code>used-total</code> 计算准确率。
  - 利用 <strong>MSHR </strong>(Miss Status Holding Register) 中的 <code>pref-bit</code> 和计数器 <code>late-total</code> 来检测延迟的预取。
  - 采用 <strong>Bloom filter</strong> 结构（一个4096-entry的位向量）来近似估算缓存污染，避免了为每个被驱逐块维护状态的高昂开销 </p>
<p><img alt="" src="../images/00535b5d378692089bc46ed2258d275e0e6d1cd80ea05c2799eef09253a25325.jpg" /></p>
<p><em>Figure 3. IPC performance (left) and prefetch lateness (right) with different aggressiveness configurations Figure 4. Filter to estimate prefetcher-generated cache pollution</em></p>
<p>。
- 基于采样间隔（以L2缓存驱逐次数为单位）收集的指标，动态调整两个方面：
  1.  <strong>预取器的激进度 </strong>(Aggressiveness)：通过一个3-bit的饱和计数器，在“非常保守”到“非常激进”五个配置间切换。调整策略综合考虑了准确率、延迟和污染三个指标 </p>
<p><img alt="" src="../images/259f1d313ba55402790845e6f0b34855d99d5731a54f5972b0a78ef7c2b6c014.jpg" /></p>
<p>。
  2.  <strong>预取块的缓存插入位置 </strong>(Cache Insertion Policy)：根据估算的污染程度，动态决定将预取块插入LRU栈的 <strong>MRU</strong>（最近使用）、<strong>MID</strong>（中间）、<strong>LRU-4</strong> 或 <strong>LRU</strong>（最久未使用）位置。</p>
<p><strong>结果</strong>
- 在17个内存密集型SPEC CPU2000基准测试上，与表现最佳的传统流式预取器（Very Aggressive）相比：
  - FDP（同时调整激进度和插入策略）实现了 <strong>6.5%</strong> 的平均性能（IPC）提升。
  - 内存带宽消耗（BPKI）减少了 <strong>18.7%</strong>。
- 与消耗相似带宽的传统预取器（Middle-of-the-Road）相比，FDP提供了 <strong>13.6%</strong> 的更高性能。
- <strong>完全消除了</strong>传统激进预取器在 <code>ammp</code> 和 <code>applu</code> 等基准测试上的巨大性能损失 </p>
<p><img alt="" src="../images/ad3a41f6c96bd07ee1044157778e6e3516c03903241a6d77c514c279a7088bf1.jpg" /></p>
<p><em>Figure 9. Overall performance of FDP</em></p>
<p>。
- FDP机制具有良好的通用性，在 <strong>Global-History-Buffer </strong>(GHB) 和 <strong>PC-based stride prefetcher</strong> 上同样有效。
- 硬件开销极低，仅为 <strong>2.54 KB</strong>，不到1MB L2缓存数据存储大小的0.25%。</p>
<table>
<thead>
<tr>
<th style="text-align: left;">配置</th>
<th style="text-align: left;">平均 IPC</th>
<th style="text-align: left;">平均 BPKI</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">No Prefetching</td>
<td style="text-align: left;">1.00x</td>
<td style="text-align: left;">1.00x</td>
</tr>
<tr>
<td style="text-align: left;">Very Conservative</td>
<td style="text-align: left;">1.08x</td>
<td style="text-align: left;">1.06x</td>
</tr>
<tr>
<td style="text-align: left;">Middle-of-the-Road</td>
<td style="text-align: left;">1.12x</td>
<td style="text-align: left;">1.13x</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Very Aggressive </strong>(Best Conventional)</td>
<td style="text-align: left;"><strong>1.18x</strong></td>
<td style="text-align: left;"><strong>1.30x</strong></td>
</tr>
<tr>
<td style="text-align: left;"><strong>FDP </strong>(Proposed)</td>
<td style="text-align: left;"><strong>1.26x </strong>(+6.5%)</td>
<td style="text-align: left;"><strong>1.06x </strong>(-18.7%)</td>
</tr>
</tbody>
</table>
<p><strong>结论</strong>
- 将<strong>动态反馈</strong>机制引入硬件预取器设计是提升其性能和带宽效率的有效途径。
- <strong>综合考量准确率、延迟和缓存污染</strong>这三个维度，比仅依赖单一指标（如准确率）能带来更显著的收益（+3.4%性能，-2.5%带宽）。
- 所提出的低成本硬件方案（特别是基于Bloom filter的污染估算和动态LRU插入策略）具有很高的实用价值和可扩展性，适用于多种现代预取器架构。</p>
<hr />
<h2 id="2">2. 背景知识与核心贡献<a class="headerlink" href="#2" title="Permanent link">&para;</a></h2>
<p><strong>研究背景与动机</strong></p>
<ul>
<li>现代高性能处理器普遍采用<strong>硬件数据预取 (hardware data prefetching)</strong> 技术来隐藏巨大的<strong>主存延迟 (main memory latency)</strong>，通过预测程序的内存访问模式并提前将数据加载到缓存中。</li>
<li>尽管预取能显著提升许多程序的性能，但它也存在两大严重弊端：</li>
<li><strong>带宽浪费与争用</strong>: 不准确的预取请求会消耗宝贵的<strong>内存带宽 (memory bandwidth)</strong>，并与关键的<strong>需求请求 (demand requests)</strong> 产生争用，反而增加延迟。</li>
<li><strong>缓存污染 (cache pollution)</strong>: 预取的数据可能驱逐掉未来会被程序真正使用的缓存块，不仅降低性能，还会因需要重新加载被驱逐的数据而进一步浪费带宽。</li>
<li>传统的预取器（如<strong>流式预取器 (stream-based prefetcher)</strong>）通常采用<strong>静态的、固定激进度 (fixed aggressiveness)</strong> 配置。如图1所示，这种“一刀切”的策略在某些基准测试（如 <code>ammp</code>, <code>applu</code>）上会导致<strong>严重的性能下降</strong>，迫使现代处理器不得不采用相对保守的策略，从而牺牲了在其他程序上的潜在性能收益。</li>
</ul>
<p><img alt="" src="../images/b0ccac832bd92283fd730c808fc1fd78ed36dba08792d2e31becc85ffcda9309.jpg" /></p>
<p><em>Figure 1. Performance vs. aggressiveness of the prefetcher</em></p>
<ul>
<li>预取器本身是一个<strong>正反馈系统</strong>：错误的预取导致缓存缺失，新的缺失又可能触发更多无用的预取，形成恶性循环。因此，亟需引入一个<strong>负反馈机制</strong>来动态调节其行为，使其稳定高效。</li>
</ul>
<p><strong>核心贡献</strong></p>
<ul>
<li>提出了一种名为<strong>反馈导向预取 (Feedback Directed Prefetching, FDP)</strong> 的通用动态调节框架，该框架通过实时监控三个关键指标来调整预取器的行为：</li>
<li><strong>预取准确率 (Prefetch Accuracy)</strong>: 衡量预取地址的预测准确性。</li>
<li><strong>预取及时性/延迟 (Prefetch Lateness)</strong>: 衡量预取数据是否在需求到来前已就绪。</li>
<li><strong>预取器引发的缓存污染 (Prefetcher-Generated Cache Pollution)</strong>: 衡量预取操作导致的有用数据被驱逐的程度。</li>
<li>设计了一种<strong>低成本、基于布隆过滤器 (Bloom filter)</strong> 的硬件机制，用于在运行时高效地估算<strong>缓存污染</strong>，解决了精确追踪污染开销过大的难题。</li>
</ul>
<p><img alt="" src="../images/00535b5d378692089bc46ed2258d275e0e6d1cd80ea05c2799eef09253a25325.jpg" /></p>
<p><em>Figure 3. IPC performance (left) and prefetch lateness (right) with different aggressiveness configurations Figure 4. Filter to estimate prefetcher-generated cache pollution</em></p>
<ul>
<li>FDP 从两个维度动态调整预取行为：</li>
<li><strong>动态调节预取激进度</strong>: 根据上述三个指标的反馈，使用一个<strong>饱和计数器 (saturating counter)</strong> 在多个预设配置（从非常保守到非常激进）之间切换。</li>
<li><strong>动态调节缓存插入策略</strong>: 根据估算的缓存污染程度，决定将预取块插入到 LRU 栈的不同位置（如 MRU, MID, LRU-4, LRU），以平衡保留有用预取和减少污染之间的矛盾。</li>
<li>实验结果表明，FDP 在 <strong>SPEC CPU2000</strong> 的 17 个内存密集型基准测试上，相比性能最佳的传统流式预取器配置，实现了 <strong>6.5%</strong> 的平均性能提升，并减少了 <strong>18.7%</strong> 的内存带宽消耗。更重要的是，它<strong>完全消除了</strong>传统激进预取在 <code>ammp</code> 和 <code>applu</code> 等程序上的巨大性能损失。</li>
<li>FDP 具有<strong>良好的通用性</strong>，同样适用于 <strong>GHB-based delta correlation prefetcher</strong> 和 <strong>PC-based stride prefetcher</strong>，证明了其作为一种通用优化框架的价值。其硬件开销仅为 <strong>2.54 KB</strong>，且不增加关键路径延迟。</li>
</ul>
<hr />
<h2 id="3">3. 核心技术和实现细节<a class="headerlink" href="#3" title="Permanent link">&para;</a></h2>
<h3 id="0_1">0. 技术架构概览<a class="headerlink" href="#0_1" title="Permanent link">&para;</a></h3>
<p><strong>整体技术架构</strong></p>
<p>本文提出的 <strong>Feedback Directed Prefetching (FDP)</strong> 是一种动态反馈机制，旨在通过实时监控硬件预取器（Hardware Prefetcher）的运行效果，来动态调整其行为，从而在提升性能的同时降低内存带宽消耗。其核心架构围绕三个关键指标的收集、分析与反馈执行展开。</p>
<ul>
<li><strong>反馈信息收集层 (Feedback Collection Layer)</strong></li>
<li>该层负责在硬件层面实时估算三个核心指标：<ul>
<li><strong>Prefetch Accuracy (预取准确率)</strong>: 通过在 L2 缓存的每个 tag 条目中增加一个 <strong>pref-bit</strong> 标记位，并配合两个计数器 <strong>preftotal</strong> (总预取数) 和 <strong>used-total</strong> (有用预取数) 来计算。当预取块被需求访问时，该位被重置并增加 used-total。</li>
<li><strong>Prefetch Lateness (预取延迟度)</strong>: 利用 <strong>Miss Status Holding Register (MSHR)</strong> 结构。MSHR 中的每个条目也包含一个 <strong>pref-bit</strong>。当一个需求请求命中了一个 pref-bit 被置位的 MSHR 条目时，说明该预取是延迟的，此时递增 <strong>late-total</strong> 计数器。</li>
<li><strong>Prefetcher-Generated Cache Pollution (预取器引发的缓存污染)</strong>: 采用基于 <strong>Bloom filter</strong> 概念的硬件结构（称为 pollution filter）来低成本地近似估算。该 filter 是一个位向量，用于追踪因预取而被驱逐的需求块。当发生需求缺失时，查询此 filter 可判断该缺失是否由预取引起，并更新 <strong>pollution-total</strong> 计数器。</li>
</ul>
</li>
<li>
<p>所有指标的收集都采用<strong>基于采样的区间更新策略</strong>，以适应程序的阶段性行为变化。一个采样区间的长度由 L2 缓存的驱逐块数量（<strong>eviction-count</strong>）决定，而非固定时间周期。</p>
</li>
<li>
<p><strong>决策与调整层 (Decision &amp; Adaptation Layer)</strong></p>
</li>
<li>在每个采样区间结束时，系统会根据收集到的三个指标的加权平均值，与预设的静态阈值进行比较，从而做出调整决策。</li>
<li>FDP 通过两种互补的方式来调整预取器行为：<ul>
<li><strong>动态调整预取器激进程度 (Dynamic Aggressiveness)</strong>:</li>
<li>使用一个 <strong>3-bit 饱和计数器 (Dynamic Configuration Counter)</strong> 来表示当前的预取配置，范围从 <strong>Very Conservative</strong> 到 <strong>Very Aggressive</strong>。</li>
<li>根据 <strong>Accuracy</strong>, <strong>Lateness</strong>, 和 <strong>Pollution</strong> 三个指标的组合情况（共12种场景），查表（Table 2）决定是增加、减少还是保持计数器的值，从而动态改变 <strong>Prefetch Distance</strong> 和 <strong>Prefetch Degree</strong>。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/259f1d313ba55402790845e6f0b34855d99d5731a54f5972b0a78ef7c2b6c014.jpg" /></p>
<div class="highlight"><pre><span></span><code>- **动态调整预取块缓存插入策略 (Dynamic Insertion Policy)**:
  - 不再将所有预取块无差别地插入 LRU 栈的 **MRU (Most-Recently-Used)** 位置。
  - 而是根据估算的 **Cache Pollution** 程度，动态选择插入位置：**MID** (中间位置), **LRU-4** (四分之一位置), 或 **LRU** (最不常用位置)。污染越高，插入位置越靠近 LRU 端，以减少对有用数据的干扰。
</code></pre></div>
<ul>
<li><strong>适用性与评估</strong></li>
<li>FDP 被设计为一个通用框架，论文验证了其在 <strong>Stream-based prefetcher</strong>, <strong>Global-History-Buffer (GHB) based delta correlation prefetcher</strong>, 和 <strong>PC-based stride prefetcher</strong> 三种主流硬件预取器上的有效性。</li>
<li>实验结果表明，FDP 在 <strong>SPEC CPU2000</strong> 套件的 17 个内存密集型基准测试中，相比最佳的传统预取器配置，实现了 <strong>6.5%</strong> 的平均性能提升和 <strong>18.7%</strong> 的内存带宽节省。</li>
<li>其硬件开销极低，仅为 <strong>2.54 KB</strong> 的额外存储，且不增加关键路径延迟。</li>
</ul>
<h3 id="1_1">1. 动态反馈驱动的预取器激进度调整<a class="headerlink" href="#1_1" title="Permanent link">&para;</a></h3>
<p><strong>动态反馈驱动的预取器激进度调整机制</strong></p>
<p>该机制的核心在于通过一个闭环控制系统，利用运行时收集的反馈信息来动态调节硬件预取器的行为，从而在最大化性能收益的同时，最小化其带来的负面影响。</p>
<ul>
<li>
<p><strong>输入：三大核心反馈指标</strong></p>
<ul>
<li><strong>Prefetch Accuracy (预取准确率)</strong>: 衡量预取请求中有多少是真正被程序使用的。计算公式为 <code>有用预取数 / 总预取数</code>。低准确率意味着大量带宽被浪费在无用数据上。</li>
<li><strong>Prefetch Lateness (预取及时性)</strong>: 衡量有用的预取请求中有多少是“迟到”的，即在程序真正需要数据时，数据尚未从内存返回。计算公式为 <code>迟到的有用预取数 / 有用预取数</code>。高延迟会削弱甚至抵消预取带来的性能增益。</li>
<li><strong>Prefetcher-Generated Cache Pollution (预取器引发的缓存污染)</strong>: 衡量由预取操作直接导致的额外需求缺失（Demand Misses）的比例。高污染意味着预取的数据挤占了未来会被使用的有效数据，反而增加了总缺失率和带宽消耗。</li>
</ul>
</li>
<li>
<p><strong>反馈信息的硬件实现</strong></p>
<ul>
<li><strong>准确率追踪</strong>: 在L2缓存的每个tag条目中增加一个 <strong>pref-bit</strong>。当预取块被插入缓存时，该位被置位；当该块被需求访问（useful）时，该位被清除，并累加 <strong>used-total</strong> 计数器。同时，每次发送预取请求都会累加 <strong>pref-total</strong> 计数器。</li>
<li><strong>及时性追踪</strong>: 利用 <strong>MSHR (Miss Status Holding Register)</strong> 结构。MSHR中的每个条目也包含一个 <strong>pref-bit</strong>。当一个需求请求命中了一个pref-bit被置位的MSHR条目时，说明该预取请求还未完成，即为“迟到”，此时累加 <strong>late-total</strong> 计数器。</li>
<li><strong>缓存污染追踪</strong>: 采用基于 <strong>Bloom filter</strong> 概念的低成本硬件结构（称为污染过滤器）。该过滤器是一个位向量。<ul>
<li>当一个因需求缺失而加载的块被预取请求驱逐出缓存时，在过滤器中对应地址的位置1。</li>
<li>当一个预取请求完成并插入缓存时，在过滤器中对应地址的位置0。</li>
<li>当发生一个新的需求缺失时，查询过滤器。如果对应位为1，则认为此次缺失是由预取器造成的，并累加 <strong>pollution-total</strong> 计数器。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>采样与更新策略</strong></p>
<ul>
<li>为了避免对瞬时噪声过度反应，系统采用<strong>基于采样的区间更新</strong>策略。</li>
<li>一个采样区间的长度由L2缓存的<strong>驱逐事件</strong>数量定义（实验中阈值 Tinterval=8192）。</li>
<li>在每个区间结束时，使用指数移动平均（如 <code>CounterValue = α * CounterValueDuringInterval + (1-α) * CounterValue</code>）来平滑历史数据，并据此计算最新的三个指标值。</li>
<li>这些更新后的指标值将用于决定下一个区间的预取器行为。</li>
</ul>
</li>
<li>
<p><strong>输出：动态调整预取器激进度</strong></p>
<ul>
<li>预取器的激进度由两个关键参数控制：<strong>Prefetch Distance</strong>（预取距离，决定预取多远）和 <strong>Prefetch Degree</strong>（预取度，决定一次预取多少块）。</li>
<li>系统维护一个3位的<strong>Dynamic Configuration Counter (动态配置计数器)</strong>，其值（1-5）对应五种预设的激进度配置，从 <strong>Very Conservative</strong> 到 <strong>Very Aggressive</strong>。</li>
<li>在每个采样区间结束时，根据三个指标与预设阈值（Ahigh, Alow, Tlateness, Tpollution）的比较结果，查表（Table 2）决定如何更新该计数器。<ul>
<li>例如，如果检测到<strong>高污染</strong>，通常会<strong>降低</strong>激进度以减少带宽浪费和缓存干扰。</li>
<li>如果检测到<strong>低准确率但高延迟</strong>，可能会<strong>降低</strong>激进度，因为盲目提前预取只会带来更多无用流量。</li>
<li>如果检测到<strong>低污染、低延迟但高准确率</strong>，则维持当前激进度，因为此时预取效果最佳。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/259f1d313ba55402790845e6f0b34855d99d5731a54f5972b0a78ef7c2b6c014.jpg" /></p>
<ul>
<li><strong>在整体系统中的作用</strong><ul>
<li>该机制充当了一个<strong>自适应的负反馈控制器</strong>，解决了传统固定激进度预取器的根本缺陷：无法适应不同程序或同一程序不同执行阶段的内存访问特性。</li>
<li>它成功地将预取器从一个可能带来巨大性能损失的“双刃剑”，转变为一个稳定、高效且带宽友好的性能提升工具。</li>
<li>实验结果表明，该机制能<strong>完全消除</strong>传统激进预取器在某些基准测试（如 ammp, applu）上造成的严重性能下降，同时在其他受益于预取的程序上保持甚至超越其性能，并显著降低内存带宽消耗（平均减少18.7%）。</li>
</ul>
</li>
</ul>
<h3 id="2_1">2. 基于布隆过滤器的预取缓存污染估算<a class="headerlink" href="#2_1" title="Permanent link">&para;</a></h3>
<p><strong>实现原理与核心思想</strong></p>
<ul>
<li>该机制的核心挑战在于，精确追踪所有因预取而被驱逐的 <strong>demand-fetched L2 cache blocks</strong> 在硬件上是不切实际的，因为这需要为每个被驱逐块维护历史记录，开销巨大。</li>
<li>论文提出了一种基于 <strong>Bloom filter</strong> 概念的低成本近似方案。其核心思想是：用一个共享的 <strong>bit-vector</strong>（即布隆过滤器）来“标记”那些<strong>可能</strong>因预取而被驱逐的块的地址。</li>
<li>这是一种<strong>有损但高效</strong>的估算方法，它牺牲了精确性（存在假阳性），换取了极低的硬件存储成本（论文中仅使用 <strong>4096-entry bit vector</strong>）。</li>
</ul>
<p><strong>算法流程与状态机</strong></p>
<ul>
<li><strong>初始化</strong>: 污染过滤器（Pollution Filter）是一个全零的位向量。</li>
<li><strong>事件1: 需求块被预取驱逐 (Demand Block Evicted by Prefetch)</strong>:<ul>
<li>当一个因 <strong>demand miss</strong> 而加载进L2缓存的块，被一个 <strong>prefetch request</strong> 驱逐出缓存时，系统会获取该被驱逐块的地址。</li>
<li>使用该地址（通过 <code>lower_bits XOR higher_bits</code> 的哈希函数）索引到过滤器的特定位，并将该位<strong>置为1</strong>。这表示“此地址对应的块可能已被预取污染”。</li>
</ul>
</li>
<li><strong>事件2: 预取块被加载 (Prefetch Block Inserted)</strong>:<ul>
<li>当一个 <strong>prefetch request</strong> 从内存返回并被插入L2缓存时，系统会获取该预取块的地址。</li>
<li>同样通过哈希函数索引到过滤器，并将对应位<strong>重置为0</strong>。这是一个关键的“清理”步骤，用于防止过滤器饱和和假阳性率过高。其逻辑是：如果一个预取块成功进入缓存，那么它就不再是“被驱逐的需求块”，应该清除之前的潜在标记。</li>
</ul>
</li>
<li><strong>事件3: 需求未命中发生 (Demand Miss Occurs)</strong>:<ul>
<li>当一个 <strong>demand access</strong> 在L2缓存中未命中时，系统会检查污染过滤器。</li>
<li>使用该需求未命中地址通过相同的哈希函数索引过滤器。</li>
<li><strong>如果对应位为1</strong>，则认为这次 <strong>demand miss</strong> 很可能是由预取器造成的（即 <strong>prefetcher-caused demand miss</strong>），并将 <strong>pollution-total</strong> 计数器加一。</li>
<li><strong>如果对应位为0</strong>，则认为这次未命中与预取无关。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/00535b5d378692089bc46ed2258d275e0e6d1cd80ea05c2799eef09253a25325.jpg" /></p>
<p><em>Figure 3. IPC performance (left) and prefetch lateness (right) with different aggressiveness configurations Figure 4. Filter to estimate prefetcher-generated cache pollution</em></p>
<p><strong>输入、输出与在整体中的作用</strong></p>
<ul>
<li><strong>输入</strong>:<ul>
<li>L2缓存的<strong>驱逐事件</strong>（特别是由预取请求触发的驱逐）。</li>
<li>L2缓存的<strong>插入事件</strong>（特别是预取块的插入）。</li>
<li>L2缓存的<strong>需求未命中事件</strong>。</li>
</ul>
</li>
<li><strong>输出</strong>:<ul>
<li>一个硬件计数器 <strong>pollution-total</strong>，用于统计估算出的 <strong>prefetcher-caused demand misses</strong> 数量。</li>
<li>结合另一个计数器 <strong>demand-total</strong>（总需求未命中数），可以计算出 <strong>Prefetcher-Generated Cache Pollution</strong> 指标：<code>pollution-total / demand-total</code>。</li>
</ul>
</li>
<li><strong>在整体中的作用</strong>:<ul>
<li>这个估算出的 <strong>cache pollution</strong> 指标是 <strong>Feedback Directed Prefetching (FDP)</strong> 机制的关键反馈信号之一。</li>
<li>它直接驱动两个核心决策：<ol>
<li><strong>动态调整预取器激进程度 (Dynamic Aggressiveness)</strong>: 如表2所示，当检测到高污染时，系统会倾向于降低预取器的激进程度（减少Prefetch Distance和Degree），以减轻对缓存的干扰。</li>
<li><strong>动态调整预取块插入策略 (Dynamic Insertion Policy)</strong>: 如3.3.2节所述，根据污染程度的高低，系统会决定将新预取的块插入到LRU栈的不同位置（MRU, MID, LRU-4, 或 LRU），高污染时插入更靠近LRU的位置，使其更快被驱逐，从而减少对有用数据的挤占。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>参数设置与设计考量</strong></p>
<ul>
<li><strong>过滤器大小</strong>: 论文中使用了 <strong>4096-entry</strong> 的位向量。这是一个在硬件开销和估算精度之间的权衡。更大的过滤器可以降低假阳性率，但会增加面积；更小的则相反。</li>
<li><strong>哈希函数</strong>: 采用了简单的 <code>lower_bits XOR higher_bits</code> 方式，这是一种轻量级的哈希方法，易于硬件实现，能有效分散地址空间，避免局部冲突。</li>
<li><strong>“插入时清零”策略</strong>: 这是该设计的一个精妙之处。它不仅防止了过滤器被长期占用而失效，还隐含地模拟了缓存的时间局部性——一个很久以前被驱逐的块，其标记被后续插入的预取块覆盖是合理的。</li>
</ul>
<h3 id="3_1">3. 基于污染感知的动态缓存插入策略<a class="headerlink" href="#3_1" title="Permanent link">&para;</a></h3>
<p><strong>核心机制与实现原理</strong></p>
<ul>
<li>该策略的核心思想是，<strong>预取块的缓存价值与其造成的污染成反比</strong>。当预取器准确性高、污染低时，应让预取块在缓存中存活更久（插入靠近MRU的位置）；反之，当污染严重时，应让其快速被淘汰（插入靠近LRU的位置）。</li>
<li>具体实现依赖于一个<strong>动态决策模块</strong>，该模块在每个<strong>采样间隔 (sampling interval)</strong> 结束时，根据估算出的 <strong>Prefetcher-Generated Cache Pollution</strong> 指标来决定下一个间隔内所有预取块的插入位置。</li>
<li>插入位置并非随意选择，而是定义了三个离散的、与缓存<strong>set-associativity (n)</strong> 相关的固定位置：<ul>
<li><strong>MID (Middle) 位置</strong>: 定义为 LRU 栈中第 <code>floor(n/2)</code> 个最不常使用的位置。这是一个折中策略，既非最热也非最冷。</li>
<li><strong>LRU-4 位置</strong>: 定义为 LRU 栈中第 <code>floor(n/4)</code> 个最不常使用的位置。比 MID 更靠近淘汰端，生存时间更短。</li>
<li><strong>LRU (Least Recently Used) 位置</strong>: 直接插入到即将被淘汰的位置，生存时间最短。</li>
</ul>
</li>
</ul>
<p><strong>算法流程与输入输出</strong></p>
<ul>
<li><strong>输入</strong>: 算法的主要输入是 <strong>Prefetcher-Generated Cache Pollution</strong> 的估算值。该值通过一个基于 <strong>Bloom filter</strong> 概念的硬件结构（文中称为 pollution filter）在运行时动态追踪和计算得出。<ul>
<li>该 filter 通过跟踪因预取而被驱逐的<strong>需求块 (demand-fetched blocks)</strong> 来间接估算污染。</li>
<li>在每个采样间隔结束时，会计算出一个污染比率：<code>pollution-total / demand-total</code>。</li>
</ul>
</li>
<li><strong>决策逻辑</strong>: 将计算出的污染比率与两个静态阈值 <strong>Plow</strong> 和 <strong>Phigh</strong> 进行比较，进行三分类：<ul>
<li><strong>低污染 (Low)</strong>: 污染比率 &lt; Plow → 下一间隔插入 <strong>MID</strong> 位置。</li>
<li><strong>中等污染 (Medium)</strong>: Plow ≤ 污染比率 &lt; Phigh → 下一间隔插入 <strong>LRU-4</strong> 位置。</li>
<li><strong>高污染 (High)</strong>: 污染比率 ≥ Phigh → 下一间隔插入 <strong>LRU</strong> 位置。</li>
</ul>
</li>
<li><strong>输出</strong>: 决策结果是一个<strong>插入位置指针</strong>，该指针被缓存控制器用于指导所有预取请求的缓存填充操作。</li>
<li><strong>在整体中的作用</strong>: 此策略与 <strong>动态调整预取器激进程度 (Dynamic Aggressiveness)</strong> 机制相辅相成。后者控制“预取多少”，前者控制“预取的数据在缓存里待多久”。两者共同构成了 <strong>Feedback Directed Prefetching (FDP)</strong> 的完整闭环反馈系统，旨在最大化性能收益的同时最小化带宽开销和缓存污染。</li>
</ul>
<p><strong>参数设置与实验效果</strong></p>
<ul>
<li>文中使用的具体阈值（来自 Section 4.3）为：<strong>Plow = 0.1</strong>, <strong>Phigh = 0.2</strong>。</li>
<li>实验结果表明，静态插入策略各有缺陷：<ul>
<li>始终插入 <strong>MRU</strong> 会导致高污染场景下性能严重下降。</li>
<li>始终插入 <strong>LRU</strong> 虽能避免污染，但会使有用的预取数据过早被淘汰，损失性能。</li>
</ul>
</li>
<li>动态策略成功地为不同基准测试选择了最优或接近最优的静态策略。例如，在 <code>applu</code> 和 <code>ammp</code> 等高污染基准上，动态策略大部分时间选择 <strong>LRU</strong> 插入；而在 <code>wupwise</code> 等低污染基准上，则更多地使用 <strong>MID</strong> 或更靠前的位置。</li>
<li></li>
</ul>
<p><img alt="" src="../images/70f8d913f7463350949980738a8c1304c6e031abbb64d9302047e97800c10cb0.jpg" /></p>
<p><em>Figure 8. Distribution of the insertion position of prefetched blocks</em></p>
<ul>
<li>性能对比数据显示，<strong>Dynamic Insertion</strong> 策略相比最佳静态策略（LRU-4）还能再提升 <strong>1.9%</strong> 的性能，充分证明了其有效性。</li>
</ul>
<hr />
<p><strong>关键数据对比</strong></p>
<p>下表总结了不同缓存插入策略在 <strong>Very Aggressive</strong> 预取器配置下的平均性能表现（以 IPC 为指标，MRU 策略为基准 1.0）：</p>
<table>
<thead>
<tr>
<th style="text-align: left;">插入策略</th>
<th style="text-align: center;">相对 IPC (vs. MRU)</th>
<th style="text-align: left;">特点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>MRU</strong></td>
<td style="text-align: center;">1.000</td>
<td style="text-align: left;">基准，高收益高风险</td>
</tr>
<tr>
<td style="text-align: left;"><strong>MID</strong></td>
<td style="text-align: center;">~1.015</td>
<td style="text-align: left;">折中策略</td>
</tr>
<tr>
<td style="text-align: left;"><strong>LRU-4</strong></td>
<td style="text-align: center;"><strong>1.032</strong></td>
<td style="text-align: left;">最佳静态策略</td>
</tr>
<tr>
<td style="text-align: left;"><strong>LRU</strong></td>
<td style="text-align: center;">~0.950</td>
<td style="text-align: left;">避免污染，但牺牲收益</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Dynamic Insertion</strong></td>
<td style="text-align: center;"><strong>1.051</strong></td>
<td style="text-align: left;"><strong>最优，自适应平衡</strong></td>
</tr>
</tbody>
</table>
<h3 id="4">4. 基于采样的运行时反馈收集机制<a class="headerlink" href="#4" title="Permanent link">&para;</a></h3>
<p><strong>核心机制：基于采样的运行时反馈收集</strong></p>
<p>该机制的核心思想是将程序执行划分为动态的、非固定时间长度的<strong>采样区间 (sampling interval)</strong>，并在每个区间结束时对预取器的性能进行评估，从而为下一区间的决策提供依据。</p>
<ul>
<li>
<p><strong>采样区间的定义与触发</strong>:</p>
<ul>
<li>区间的边界并非由固定的指令数或时钟周期决定，而是由<strong>L2缓存的实际活动</strong>来驱动。</li>
<li>具体而言，系统维护一个名为 <strong><code>eviction-count</code></strong> 的硬件计数器，用于追踪从L2缓存中驱逐出的块的总数。</li>
<li>当 <code>eviction-count</code> 的值超过一个预设的静态阈值 <strong><code>Tinterval</code></strong> 时，当前采样区间即告结束。</li>
<li>在实验中，<code>Tinterval</code> 被设置为 <strong>8192</strong>，这恰好是基准配置中1MB L2缓存总块数（16384）的一半。这种设计确保了采样频率与缓存的实际压力相关联。</li>
</ul>
</li>
<li>
<p><strong>反馈指标的计算与更新</strong>:</p>
<ul>
<li>在每个采样区间内，系统会持续累加三个关键指标的原始计数：<ul>
<li><strong><code>pref-total</code></strong>: 发送到内存的预取请求数。</li>
<li><strong><code>used-total</code></strong>: 被需求访问命中的有用预取数。</li>
<li><strong><code>late-total</code></strong>: 因预取请求仍在处理中而导致的需求访问延迟数。</li>
<li><strong><code>pollution-total</code></strong>: 通过Bloom Filter估算的、由预取器导致的需求缺失数。</li>
</ul>
</li>
<li>当一个采样区间结束时，这些计数器的值会被用来计算三个核心反馈指标：<ul>
<li><strong>Prefetch Accuracy (预取准确率)</strong> = <code>used-total</code> / <code>pref-total</code></li>
<li><strong>Prefetch Lateness (预取延迟率)</strong> = <code>late-total</code> / <code>used-total</code></li>
<li><strong>Prefetcher-Generated Cache Pollution (预取器生成的缓存污染)</strong> = <code>pollution-total</code> / <code>demand-total</code></li>
</ul>
</li>
<li>计算完成后，所有原始计数器（<code>pref-total</code>, <code>used-total</code>等）会被<strong>重置为零</strong>，为下一个区间做准备。</li>
</ul>
</li>
<li>
<p><strong>历史行为的平滑处理</strong>:</p>
<ul>
<li>为了防止因单个异常区间而导致预取策略剧烈波动，系统并未完全丢弃历史信息。</li>
<li>相反，它采用了一种<strong>指数加权移动平均</strong>的更新策略。在论文的公式(1)中，每个指标的全局状态值（<code>CounterValueGlobal</code>）会根据当前区间的测量值（<code>CounterValueDuringInterval</code>）进行更新：
    <code>CounterValueGlobal = (7/8) * CounterValueGlobal + (1/8) * CounterValueDuringInterval</code></li>
<li>这种方式赋予了<strong>最近区间的行为更高的权重</strong>，同时保留了对历史行为的记忆，使得反馈信号更加平滑和稳健。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/37b369db103b2e05a4f6345de6d966d64132e588811d2bb0658add10438d7d10.jpg" /></p>
<p><strong>输入输出关系及在整体架构中的作用</strong></p>
<ul>
<li>
<p><strong>输入</strong>:</p>
<ul>
<li><strong>原始事件流</strong>: 来自L2缓存和MSHR（Miss Status Holding Register）的底层硬件事件，包括预取请求的发送、需求访问对预取块的命中、需求访问与预取请求在MSHR中的冲突、以及通过Bloom Filter检测到的潜在污染事件。</li>
<li><strong>L2驱逐事件</strong>: 作为触发采样区间结束的信号。</li>
</ul>
</li>
<li>
<p><strong>输出</strong>:</p>
<ul>
<li><strong>三个量化指标</strong>: 经过平滑处理后的 <strong>Prefetch Accuracy</strong>, <strong>Prefetch Lateness</strong>, 和 <strong>Prefetcher-Generated Cache Pollution</strong> 的数值。这些是高层决策逻辑的直接输入。</li>
</ul>
</li>
<li>
<p><strong>在整体架构中的作用</strong>:</p>
<ul>
<li>该机制是<strong>Feedback Directed Prefetching (FDP)</strong> 架构的<strong>感知层 (Perception Layer)</strong>。它负责将底层复杂的、瞬时的硬件交互，抽象并聚合为三个简洁、可操作的性能指标。</li>
<li>它充当了<strong>动态调整策略</strong>（如改变预取激进程度和缓存插入位置）与<strong>实际硬件行为</strong>之间的桥梁。没有这个实时、低成本的反馈回路，上层的自适应策略就失去了决策依据。</li>
<li>通过将采样与<strong>L2驱逐</strong>这一与缓存污染和带宽压力高度相关的事件绑定，该机制能够敏锐地捕捉到程序行为的变化（例如，从具有良好空间局部性的循环进入一个随机访问阶段），并及时做出反应。</li>
</ul>
</li>
</ul>
<hr />
<h2 id="4_1">4. 实验方法与实验结果<a class="headerlink" href="#4_1" title="Permanent link">&para;</a></h2>
<p><strong>实验设置</strong></p>
<ul>
<li><strong>模拟器与处理器模型</strong>：使用一个内部的、基于执行驱动的 <strong>Alpha ISA</strong> 模拟器，该模拟器建模了一个高性能的乱序超标量处理器。具体的基线处理器配置参数见下表。</li>
<li><strong>内存模型</strong>：采用了一个详细的内存模型，忠实地模拟了内存系统中所有硬件结构（如总线、队列）的行为和带宽/端口限制。内存总线带宽为 <strong>4.5 GB/s</strong>。</li>
<li><strong>基线预取器</strong>：建模了一个 <strong>stream prefetcher</strong>，能够跟踪 <strong>64</strong> 个不同的数据流。预取请求被放入一个 <strong>128</strong> 项的预取请求队列，并以最低优先级处理，以避免阻塞需求请求。</li>
<li><strong>缓存配置</strong>：L2 缓存大小为 <strong>1MB</strong>，采用 <strong>16-way</strong> 组相联。在基线配置中，预取的数据块被插入到 LRU 栈的 <strong>MRU (Most-Recently-Used)</strong> 位置。</li>
<li><strong>基准测试集</strong>：主要评估对象是 <strong>SPEC CPU2000</strong> 套件中的 <strong>17</strong> 个内存密集型基准测试程序。选择标准是，在最激进的预取器配置下，这些程序在 2.5 亿条指令的运行过程中至少会发出 <strong>200K</strong> 条预取请求。此外，还对剩余的 <strong>9</strong> 个程序进行了评估。</li>
<li><strong>运行配置</strong>：所有基准测试均使用 Compaq C/Fortran 编译器，开启 <code>-fast</code> 优化和 profile-driven feedback。模拟前会跳过初始化阶段，然后运行 <strong>250 million instructions</strong>。</li>
</ul>
<p><img alt="" src="../images/2aa95016c5ebdc1228e39a0a13bcdcb6eabe2038bbcd98301f46de0da75e714e.jpg" /></p>
<p><em>Table 3. Baseline processor configuration</em></p>
<p><strong>结果数据</strong></p>
<ul>
<li><strong>整体性能提升</strong>：与性能最佳的传统 <strong>stream prefetcher</strong> 配置（即 <strong>Very Aggressive</strong>）相比，<strong>Feedback Directed Prefetching (FDP)</strong> 将 <strong>17</strong> 个内存密集型基准测试的平均性能提升了 <strong>6.5%</strong>。</li>
<li><strong>消除负面性能影响</strong>：FDP 完全消除了传统激进预取器在某些基准测试（如 <code>ammp</code>, <code>applu</code>）上造成的巨大性能损失。例如，在 <code>applu</code> 上，FDP 相比无预取实现了 <strong>13.4%</strong> 的性能提升，而传统激进预取器则导致 <strong>28.9%</strong> 的性能下降。</li>
<li><strong>带宽效率</strong>：FDP 比 <strong>Very Aggressive</strong> 配置消耗 <strong>18.7%</strong> 更少的内存带宽（以 <strong>BPKI</strong>, Bus accesses Per Kilo Instructions 衡量）。与消耗相似带宽的传统配置相比，FDP 提供了 <strong>13.6%</strong> 更高的性能。</li>
<li><strong>通用性</strong>：FDP 的优势不仅限于 stream prefetcher。应用到 <strong>GHB-based delta correlation prefetcher</strong> 上时，在相似带宽下性能提升 <strong>9.9%</strong>；应用到 <strong>PC-based stride prefetcher</strong> 上时，平均性能提升 <strong>4%</strong>，带宽减少 <strong>24%</strong>。</li>
<li><strong>对其他基准的影响</strong>：在剩余的 <strong>9</strong> 个 SPEC 基准测试上，FDP 也表现稳健，平均性能提升 <strong>0.4%</strong>，且没有任何程序出现性能下降。</li>
</ul>
<p><img alt="" src="../images/ad3a41f6c96bd07ee1044157778e6e3516c03903241a6d77c514c279a7088bf1.jpg" /></p>
<p><em>Figure 9. Overall performance of FDP</em></p>
<p><img alt="" src="../images/f1ace0e99fd907a732738620ca676335d85d31db685f8c1d9a1daff3165347ee.jpg" /></p>
<p><em>Table 5. Average IPC and BPKI for FDP vs conventional prefetchers</em></p>
<p><strong>消融实验</strong></p>
<p>论文通过一系列消融实验，验证了 FDP 中各个组件的有效性和必要性。</p>
<ul>
<li><strong>动态调整预取激进度 (Dynamic Aggressiveness) vs. 静态配置</strong>：</li>
<li>仅使用动态调整激进度（固定 MRU 插入策略），其平均性能就超过了所有静态配置（No, Very Conservative, Middle-of-the-Road, Very Aggressive）。</li>
<li>与 <strong>Very Aggressive</strong> 配置相比，性能提升 <strong>4.7%</strong>，并几乎完全消除了 <code>ammp</code> 和 <code>applu</code> 上的性能损失。</li>
<li></li>
</ul>
<p><img alt="" src="../images/48a7f881981e7386629c8a257bcbbd0852280640199823f654041d147eb8296a.jpg" /></p>
<p><em>Figure 5. Dynamic adjustment of prefetcher aggressiveness</em></p>
<ul>
<li>机制能自适应地为不同程序选择最优的激进度级别，例如在 <code>wupwise</code> 上几乎总是选择 <strong>Very Aggressive</strong>，而在 <code>ammp</code> 上几乎总是选择 <strong>Very Conservative</strong>。</li>
<li></li>
</ul>
<p><img alt="" src="../images/d34f1b5fcd4997faab231c40bef64baa6eebc82d6e893cc3bc30c93e0cbaff9b.jpg" /></p>
<p><em>Figure 6. Distribution of the dynamic aggressiveness level</em></p>
<ul>
<li><strong>动态调整缓存插入策略 (Dynamic Insertion) vs. 静态策略</strong>：</li>
<li>在固定 <strong>Very Aggressive</strong> 配置下，动态插入策略的性能优于任何静态策略（MRU, MID, LRU-4, LRU）。</li>
<li>与最佳静态策略 <strong>LRU-4</strong> 相比，性能提升 <strong>1.9%</strong>；与基线 <strong>MRU</strong> 相比，性能提升 <strong>5.1%</strong>。</li>
<li></li>
</ul>
<p><img alt="" src="../images/faeff948fd441f807661f315188552e676e2224832ec7abc50f8b273ddf8009c.jpg" /></p>
<p><em>Figure 7. Dynamic adjustment of prefetch insertion policy</em></p>
<ul>
<li>该机制能根据污染情况动态选择插入位置，例如在 <code>ammp</code> 上主要使用 <strong>LRU</strong> 位置以减少污染。</li>
<li></li>
</ul>
<p><img alt="" src="../images/70f8d913f7463350949980738a8c1304c6e031abbb64d9302047e97800c10cb0.jpg" /></p>
<p><em>Figure 8. Distribution of the insertion position of prefetched blocks</em></p>
<ul>
<li><strong>仅使用预取准确率 (Accuracy-only) vs. 完整反馈机制</strong>：</li>
<li>一个仅基于 <strong>Prefetch Accuracy</strong> 来调整激进度的简化版 FDP，其性能和带宽效率均低于完整的 FDP。</li>
<li>
<p>完整的 FDP（同时考虑 <strong>Accuracy</strong>, <strong>Timeliness/Lateness</strong>, <strong>Pollution</strong>）比仅用准确率的版本性能高 <strong>3.4%</strong>，带宽消耗低 <strong>2.5%</strong>。这证明了综合多维度反馈信息的重要性。</p>
</li>
<li>
<p><strong>FDP vs. 预取缓存 (Prefetch Cache)</strong>：</p>
</li>
<li>为了对比解决缓存污染的另一种方案，作者将 FDP 与使用专用 <strong>prefetch cache</strong> 的方案进行了比较。</li>
<li>FDP（直接预取到 L2）的性能比使用 <strong>32KB prefetch cache</strong> 的激进预取器高 <strong>5.3%</strong>，并且带宽消耗更低。</li>
<li>FDP 在性能上接近 <strong>64KB prefetch cache</strong> 的方案，但硬件开销远小于后者。</li>
<li></li>
</ul>
<p><img alt="" src="../images/db1b40b8af8daaa8871a965a13cda94e0a885f14747451c3269479bc3f4270c2.jpg" /></p>
<p><em>Figure 11. Performance of prefetch cache vs. FDP</em></p>
<ul>
<li></li>
</ul>
<p><img alt="" src="../images/26fb57050fca59062249afbb0507bc33eb46646d3a5fedcbe87771851247f7cd.jpg" /></p>
<p><em>Figure 12. Bandwidth consumption of prefetch cache vs. FDP</em></p>
<hr />












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.sections", "navigation.top", "navigation.indexes", "search.suggest", "search.highlight", "content.code.copy"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../../../javascripts/switcher.js"></script>
      
    
  </body>
</html>