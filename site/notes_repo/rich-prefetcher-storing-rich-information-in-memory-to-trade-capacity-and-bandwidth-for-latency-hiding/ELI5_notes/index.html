
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://example.com/notes_repo/rich-prefetcher-storing-rich-information-in-memory-to-trade-capacity-and-bandwidth-for-latency-hiding/ELI5_notes/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>RICH Prefetcher: Storing Rich Information in Memory to Trade Capacity and Bandwidth for Latency Hiding 通俗讲解 - BlaBlaCut</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#rich-prefetcher-storing-rich-information-in-memory-to-trade-capacity-and-bandwidth-for-latency-hiding" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="BlaBlaCut" class="md-header__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            BlaBlaCut
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              RICH Prefetcher: Storing Rich Information in Memory to Trade Capacity and Bandwidth for Latency Hiding 通俗讲解
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到深色模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换到深色模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到浅色模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换到浅色模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="BlaBlaCut" class="md-nav__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    BlaBlaCut
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/Recent/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Recent
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/awesome-data-prefetchers/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Awesome Data Prefetchers
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/micro-2025/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    MICRO 2025
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#0" class="md-nav__link">
    <span class="md-ellipsis">
      
        0. 整体创新点通俗解读
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1-eli5" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. 多尺度空间预取与多偏移触发机制 (ELI5)
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-eli5" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. 基于优先级的区域仲裁策略 (ELI5)
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-eli5" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. 分层元数据存储架构 (ELI5)
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-eli5" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. 片外元数据访问过滤机制 (ELI5)
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="rich-prefetcher-storing-rich-information-in-memory-to-trade-capacity-and-bandwidth-for-latency-hiding">RICH Prefetcher: Storing Rich Information in Memory to Trade Capacity and Bandwidth for Latency Hiding 通俗讲解<a class="headerlink" href="#rich-prefetcher-storing-rich-information-in-memory-to-trade-capacity-and-bandwidth-for-latency-hiding" title="Permanent link">&para;</a></h1>
<h3 id="0">0. 整体创新点通俗解读<a class="headerlink" href="#0" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击 (The "Why")</strong></p>
<p>传统硬件预取器（Prefetcher）在设计上陷入了两难困境：
- <strong>为了省面积，牺牲了能力</strong>：像 Bingo、SMS 这类先进的空间预取器，为了控制宝贵的 <strong>on-chip area</strong> 开销，通常只敢在一个固定的 <strong>4KB</strong> 页内学习访问模式。这就像是一个视力很好的人，却被强制戴上了一个只能看眼前一米的隧道视野眼镜。当程序的数据结构跨越多个页面（比如一个大对象分布在16KB空间里），这种预取器就完全“看不见”了，导致 <strong>coverage</strong>（覆盖率）严重不足。
- <strong>为了追求数量，牺牲了质量</strong>：如果简单地把预取区域扩大到16KB，问题又来了。仅凭第一次访问的地址（PC, offset）就去预测后面整个16KB区域的访问模式，会遇到大量“<strong>common-origin, later-divergent</strong>”（同源异流）的情况——即很多不同的数据流都从同一个地方开始访问，但后续走向完全不同。这会导致 <strong>accuracy</strong>（准确率）暴跌，产生大量无用的预取，不仅浪费 <strong>bandwidth</strong>，还会污染缓存。</p>
<p>更根本的问题是，现代和未来的内存系统（如 <strong>CXL-based memory pooling</strong>, <strong>NVM</strong>）正朝着 <strong>高带宽、大容量、高延迟</strong> 的方向发展。旧的预取器设计理念（极度吝啬元数据）已经无法充分利用这种新硬件的优势来隐藏越来越长的 <strong>memory access latency</strong>。</p>
<p><strong>通俗比方 (The Analogy)</strong></p>
<p>想象你是一个图书管理员（Prefetcher），负责在读者（CPU）需要之前，把书（数据）从远处的仓库（Main Memory）搬到手边的阅览室（Cache）。</p>
<ul>
<li><strong>老派管理员（传统预取器）</strong>：他有一个很小的记事本（on-chip storage），只能记录“某某教授（PC）每次来都会拿走A书架（4KB页）上的第3、5、7本书”。这个方法很省纸，但如果教授这次要研究一个大课题，需要A、B、C三个书架（16KB区域）的书，管理员就傻眼了，因为他的记事本没地方记这么复杂的模式。</li>
<li><strong>冒进的管理员（简单扩大区域）</strong>：他换了个大记事本，开始记录“A书架+B书架+C书架”的组合。但他有个坏习惯：只要看到教授拿了A书架的第一本书，就立刻把ABC三个书架的所有书都搬过来。结果发现，有时候教授只是顺手拿一下A书架的书，根本不需要后面的，导致阅览室堆满了没用的书，真正需要的书反而没地方放了。</li>
</ul>
<p><strong>RICH 的管理员</strong>则非常聪明：
1.  <strong>他有不同尺寸的搬运策略</strong>：对于小需求（2KB/4KB），他动作快、覆盖广，看到一点苗头就搬；对于大需求（16KB），他非常谨慎，一定要看到教授连续拿了好几本（比如5本）来自这个大区域的书，才确认教授真的要搞大项目，然后才一次性把整个区域的书高效地搬过来。
2.  <strong>他有分层的记事系统</strong>：他把最常用、最重要的大项目清单（高频16KB模式）记在手边的小本子上（on-chip cache）。那些不常用的、生僻的大项目清单，他则存放在仓库里的一个专用文件柜里（off-chip main memory）。虽然去仓库拿清单要花点时间，但因为他只在确认是大项目时才去拿，而且大项目本身能带来巨大的收益，这点等待时间完全值得。</p>
<p><strong>关键一招 (The "How")</strong></p>
<p>RICH 的核心创新在于，它没有在“小而精”和“大而全”之间做非此即彼的选择，而是通过两个精妙的设计，将二者动态结合：</p>
<ul>
<li><strong>多尺度触发机制（Multi-level Trigger Mechanism）</strong>：</li>
<li>对于 <strong>2KB/4KB 小区域</strong>，采用 <strong>coverage-first</strong> 策略。触发条件宽松（如 Bingo 的 <code>(PC, address)</code> 或 <code>(PC, 3 offsets)</code>），确保能捕捉到尽可能多的访问机会，即使偶尔出错，代价也很小。</li>
<li>对于 <strong>16KB 大区域</strong>，采用 <strong>accuracy-first</strong> 策略。触发条件极其严格，必须观察到 <strong>(PC, 5 offsets)</strong> 这样多的访问足迹后，才认为模式足够可靠，可以发起大规模预取。这从根本上解决了大区域预取准确率低的难题。</li>
<li>
<p>当多个区域同时被触发时，通过一个 <strong>固定优先级仲裁</strong>（2KB-(PC,address) &gt; 16KB &gt; 4KB &gt; 2KB-(PC,offset)）来决定执行哪个，避免了重复和冲突。</p>
</li>
<li>
<p><strong>分层元数据存储（Hierarchical Metadata Storage）</strong>：</p>
</li>
<li><strong>作者并没有把所有元数据都塞进昂贵的 on-chip 存储</strong>，而是巧妙地利用了16KB模式本身的特性：它们 <strong>访问频率低</strong>、<strong>单次收益高</strong>、<strong>对延迟容忍度高</strong>。</li>
<li>因此，只在片上保留一个很小的 <strong>16KB PHT Cache</strong>（256项），用于存放高频模式。</li>
<li>绝大部分低频的16KB模式被卸载（offload）到 <strong>main memory</strong> 中。通过一个 <strong>Valid Map</strong> 和 <strong>prefetch count threshold</strong>（阈值为30）机制，确保只有那些值得的（能预取超过30行数据的）模式才会被写入或读取主存，极大地减少了不必要的 off-chip 访问开销。</li>
<li></li>
</ul>
<p><img alt="" src="../images/8a2bbe0f30407dfa37e775c401d9144a90a7e78df58cfb7eabcdb2ec24266775.jpg" /></p>
<p><em>Figure 4: Achieving high accuracy in large spatial regions and high coverage in small spatial regions by using different numbers of trigger offsets Figure 5: Placing 16 KB PHT off-chip keeps most prefetch opportunities, even with additional memory access latency</em></p>
<div class="highlight"><pre><span></span><code>这张图清晰地表明，即使加上50ns的额外延迟，将16KB PHT放在片外也只会损失不到15%的预取机会，证明了该设计的可行性。
</code></pre></div>
<p>最终，RICH 通过这种“<strong>小区域广撒网，大区域精耕细作，并用分层存储降低成本</strong>”的策略，在几乎不增加片上面积（on-chip area）的前提下，显著提升了 <strong>coverage</strong> 和 <strong>timeliness</strong>，从而在高延迟内存系统中获得了远超现有技术的性能优势。</p>
<h3 id="1-eli5">1. 多尺度空间预取与多偏移触发机制 (ELI5)<a class="headerlink" href="#1-eli5" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击</strong></p>
<ul>
<li>传统的空间预取器（比如 Bingo、SMS）通常只盯着 <strong>4KB</strong> 这一个固定区域大小干活，这在现实中非常“难受”。</li>
<li><strong>顾此失彼</strong>：对于访问模式跨越多个页面的大型数据结构（比如科学计算中的大数组），4KB 的视野太窄，导致 <strong>覆盖率</strong> 不足，很多本该预取的数据没抓到。</li>
<li><strong>浪费带宽</strong>：反过来，如果强行用一个很大的区域（比如 16KB）去预取所有东西，一旦预测错了，就会拉回一大堆 <strong>无用数据</strong>，严重 <strong>污染缓存</strong> 并 <strong>浪费宝贵的内存带宽</strong>。</li>
<li><strong>触发机制太粗糙</strong>：老方法通常只看第一次访问的偏移量 <code>(PC, offset)</code> 或完整地址 <code>(PC, address)</code> 就决定预取整个区域。但现实程序里，很多不同的访问流可能从同一个起点出发，很快就分道扬镳了（见图2）。这种“<strong>同源异流</strong>”的情况会让大区域预取的 <strong>准确性</strong> 暴跌。</li>
</ul>
<p><img alt="" src="../images/422c82dae797ba1a7110178407e9347cf3d4bdb82956c403ca656ded0eb8e80a.jpg" /></p>
<p><em>Figure 2: The multi-offset trigger mechanism can distinguish "common-origin, later-divergent" access streams</em></p>
<p><strong>通俗比方</strong></p>
<ul>
<li>想象你是个图书管理员，负责给读者提前把书从仓库（主存）搬到阅览室（缓存）。</li>
<li><strong>老派管理员</strong>：他只会按“标准书架”（4KB页）来搬书。如果读者要看一本超大画册（16KB数据），他得跑四次才能搬完，等书都齐了，读者早就等烦了（<strong>timeliness 差</strong>）。</li>
<li><strong>莽撞的管理员</strong>：他听说有大画册，就不管三七二十一，只要看到有人进美术区（第一次访问），就把整个美术区的书（16KB）全搬过来。结果发现读者只是来查个目录，白忙活一场，还把阅览室堆满了没用的书（<strong>accuracy 低，cache pollution</strong>）。</li>
<li><strong>RICH管理员</strong>：他聪明多了。他手里有三种尺寸的推车：小（2KB）、中（4KB）、大（16KB）。</li>
<li>对于不确定的小需求，他先用小推车快速响应，保证不漏掉任何读者（<strong>coverage-first for small regions</strong>）。</li>
<li>对于可能的大需求，他不会立刻行动。他会先观察，看到同一个读者连续拿了5本相关的书（<strong>5 offsets</strong>），才确信他真的要研究这个专题，然后才推出大推车一次性把全套资料搬来（<strong>accuracy-first for large regions</strong>）。</li>
<li>这样，他既满足了普通读者的即时需求，又高效地服务了深度研究者，还避免了无谓的体力浪费。</li>
</ul>
<p><strong>关键一招</strong></p>
<ul>
<li>作者没有沿用“一刀切”的区域大小和触发逻辑，而是做了一个精妙的 <strong>分而治之 + 动态仲裁</strong> 的设计。</li>
<li><strong>替换触发条件</strong>：对于 <strong>16KB</strong> 这样的大区域，作者彻底抛弃了单点触发的旧思路，将其替换为 <strong>多偏移触发 (multi-offset trigger)</strong> 机制。必须观察到 <code>(PC, 5 offsets)</code> 这样更丰富的上下文，才认为模式足够稳定，值得冒险进行大范围预取。这从根本上解决了“同源异流”导致的误判问题。</li>
<li><strong>扭转区域策略</strong>：作者将不同尺寸的区域赋予了截然不同的使命：</li>
<li><strong>2KB/4KB 区域</strong>：采用轻量级触发（如 <code>(PC, address)</code> 或 <code>(PC, 3 offsets)</code>），目标是 <strong>最大化覆盖率</strong>，确保不放过任何潜在的访问模式。</li>
<li><strong>16KB 区域</strong>：采用重量级触发 <code>(PC, 5 offsets)</code>，目标是 <strong>最大化准确性</strong>，只在高度确信时才启动，以充分利用高带宽优势。</li>
<li><strong>引入仲裁机制</strong>：当多个区域同时被触发时，系统会根据预设的 <strong>优先级</strong>（2KB-(PC,address) &gt; 16KB &gt; 4KB &gt; 2KB-(PC,offset)）和 <strong>去重逻辑</strong>（大区域预取会阻止其覆盖范围内的小区域预取）来选择最优方案，避免了资源内耗。</li>
</ul>
<p><img alt="" src="../images/1f10b5e59c03da97147d1e6f49132168e55c6d8bffc6ba398eef1107e5abb7ce.jpg" /></p>
<p><em>Figure 3: By using more access offsets in a trigger, we can trade off between the accuracy and coverage of prefetching. Specifically, a), b),and c) correspond to 16 KB-region, 4 KBregion, and 2 KB-region.</em></p>
<p>这种设计的核心在于，它不再试图用一个僵化的模型去拟合所有程序，而是通过 <strong>多尺度感知</strong> 和 <strong>自适应触发</strong>，让预取器能像一个经验丰富的专家一样，在 <strong>覆盖率</strong> 和 <strong>准确性</strong> 这对天然矛盾的目标之间，根据不同场景动态地找到最佳平衡点。最终结果就是，在常规系统中性能提升 <strong>3.4%</strong>，而在高延迟内存系统中，优势更是扩大到 <strong>8.3%</strong>。</p>
<h3 id="2-eli5">2. 基于优先级的区域仲裁策略 (ELI5)<a class="headerlink" href="#2-eli5" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击 (The "Why")</strong></p>
<ul>
<li>传统的空间预取器（如 Bingo）通常只在一个固定的 <strong>4KB</strong> 区域内工作。这就像你只能用一种尺寸的渔网捕鱼——遇到小鱼群浪费网眼，遇到大鱼群又捕不全。</li>
<li>RICH 的核心思想是同时使用 <strong>2KB、4KB、16KB</strong> 三种“渔网”来适应不同程序的访存模式。但这就引出了一个新麻烦：当同一个内存区域同时被多个“渔网”盯上时（比如一个 16KB 大网和它内部的几个 2KB 小网都触发了），如果全都去抓，就会造成严重的 <strong>冗余预取</strong>。</li>
<li>冗余预取的危害极大：</li>
<li><strong>浪费宝贵的 off-chip 带宽</strong>，把通道塞满无用数据。</li>
<li><strong>污染 cache</strong>，把真正有用的数据挤出去。</li>
<li>最终导致 <strong>性能不升反降</strong>，好心办坏事。</li>
</ul>
<p><strong>通俗比方 (The Analogy)</strong></p>
<ul>
<li>想象一个高效的物流调度中心。仓库里有不同规格的打包区：<strong>小件区 (2KB)</strong>、<strong>标准区 (4KB)</strong> 和 <strong>大宗货物区 (16KB)</strong>。</li>
<li>当一批货物（内存访问）到来时，系统会判断这批货最适合在哪个区打包。但如果判断逻辑混乱，可能会出现同一批货既在小件区被打包成几十个小包裹，又在大宗区被打包成一个大集装箱。</li>
<li>这显然极其低效。<strong>基于优先级的区域仲裁策略</strong>就像是一个聪明的调度员，他的规则是：</li>
<li>如果这批货能被识别为一个高价值、高确定性的<strong>完整订单</strong>（对应 <strong>2KB-(PC, address)</strong> 触发，因为它捕捉了精确的时空局部性），就优先用小件区快速处理。</li>
<li>否则，就看它是否符合<strong>大宗货物</strong>的特征（对应 <strong>16KB</strong> 区域，由多偏移验证保证了高 <strong>accuracy</strong>）。如果是，就直接用一个大集装箱搞定，省时省力。</li>
<li>只有在以上都不满足时，才退而求其次用标准区或最普通的打包方式。</li>
<li>这个调度员还有一个铁律：<strong>一旦决定用大集装箱发货，就立刻封锁里面所有的小件打包位，防止重复劳动</strong>。这就是文中的 <strong>去重机制 (de-duplication mechanism)</strong>。</li>
</ul>
<p><img alt="" src="../images/e7db11d6666a6329d6f2f885db1cc278ea284b557d2571e2444b5f024a5d2ead.jpg" /></p>
<p><em>Figure 8: The Region Arbitration unit selects the appropriate region to prefetch (Step P3)</em></p>
<p><strong>关键一招 (The "How")</strong></p>
<ul>
<li>作者没有简单地让所有区域“自由竞争”，而是设计了一个 <strong>固定优先级 + 覆盖检查</strong> 的两层仲裁逻辑。</li>
<li><strong>第一层：基于准确率和成本的静态优先级排序</strong>。这个排序不是拍脑袋定的，而是基于对不同区域特性的深刻洞察：</li>
<li><strong>2KB-(PC, address)</strong>: 虽然区域小，但触发条件苛刻（需要精确地址），<strong>accuracy</strong> 极高，且误判成本（只取2KB）很低，所以给最高优先级。</li>
<li><strong>16KB</strong>: 区域大，一次预取收益高（<strong>timeliness</strong> 好），但通过 <strong>multi-offset trigger</strong> 机制保证了其 <strong>accuracy</strong> 也超过90%，因此排第二。</li>
<li><strong>4KB</strong>: 作为折中方案，排第三。</li>
<li><strong>2KB-(PC, offset)</strong>: 触发条件最宽松，<strong>coverage</strong> 高但 <strong>accuracy</strong> 相对最低，误判成本虽小但容易泛滥，所以优先级最低。</li>
<li><strong>第二层：动态覆盖检查 (overlap check)</strong>。即使一个低优先级的请求先到，如果此时一个高优先级的请求覆盖了同一片区域，低优先级的请求也会被 <strong>block</strong> 掉。反之，如果一个 16KB 请求已经发出，那么在其完成前，该区域内的所有 4KB 和 2KB 请求都会被禁止。</li>
<li><strong>作者最关键的扭转在于</strong>：将“选择哪个区域预取”这个问题，从一个复杂的在线优化问题，简化为一个基于离线分析得出的、高效且可预测的 <strong>静态优先级决策</strong>，并辅以简单的硬件表（<strong>Inflight Prefetch Table</strong>）来执行去重。这既保证了性能，又控制了硬件开销。</li>
</ul>
<h3 id="3-eli5">3. 分层元数据存储架构 (ELI5)<a class="headerlink" href="#3-eli5" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击</strong></p>
<p>传统硬件预取器（如 Bingo、SMS）为了控制 <strong>on-chip area overhead</strong>，把所有元数据都塞在片上，这导致了一个根本性的矛盾：它们只能处理 <strong>4KB 以内的小区域空间局部性</strong>。但现实 workload 中，很多程序（比如科学计算、图处理）的访问模式跨越多个页面，呈现出 <strong>16KB 甚至更大的空间局部性</strong>。如果强行用小区域去覆盖，就会出现“只见树木，不见森林”的问题——<strong>coverage</strong>（覆盖率）极低。可如果直接把大区域的元数据（比如 16KB 的 bit-vector pattern）全放片上，那动辄上百 KB 的存储开销是处理器设计无法承受的奢侈。更麻烦的是，如果简单地把所有元数据都扔到 off-chip memory，每次预测都要去主存读一次，那 <strong>metadata access latency</strong> 本身就可能吃掉预取带来的所有收益，得不偿失。</p>
<hr />
<p><strong>通俗比方</strong></p>
<p>想象你是一个图书管理员（Prefetcher），负责给读者（CPU）提前准备好他们可能要看的书（data）。</p>
<ul>
<li>以前的管理员（传统预取器）只有一个很小的办公桌（on-chip storage）。他只能把最热门的几本畅销书（small-region patterns）的目录摘要放在桌上，方便快速查找。但他完全没法处理那些需要整套丛书（large-region patterns）的读者请求，因为丛书目录太厚，桌子放不下。</li>
<li>RICH 的管理员则聪明得多。他依然保留一张小办公桌，上面只放两类东西：一是最畅销的单本书目录（2KB/4KB patterns），二是一个 <strong>“高频丛书索引缓存”</strong>（on-chip PHT cache for 16KB）。对于绝大多数冷门的丛书目录，他并不放在桌上，而是存在图书馆后面的大型仓库里（off-chip main memory）。当他接到一个可能需要丛书的请求时，先看一眼自己的小索引缓存。如果有，立刻行动；如果没有，他才去仓库调取。关键是，他知道调取一套丛书本身就能服务读者很久，所以即使去仓库拿目录花点时间（latency），只要这套书真的有用，总体还是赚的。这就是利用了 <strong>大区域预取天然的高延迟容忍度</strong>。</li>
</ul>
<p><img alt="" src="../images/8a2bbe0f30407dfa37e775c401d9144a90a7e78df58cfb7eabcdb2ec24266775.jpg" /></p>
<p><em>Figure 4: Achieving high accuracy in large spatial regions and high coverage in small spatial regions by using different numbers of trigger offsets Figure 5: Placing 16 KB PHT off-chip keeps most prefetch opportunities, even with additional memory access latency</em></p>
<hr />
<p><strong>关键一招</strong></p>
<p>作者并没有把所有元数据平等对待，而是做了一次精妙的 <strong>“分类托管”</strong>：</p>
<ul>
<li><strong>对元数据进行三维评估</strong>：根据 <strong>访问频率 (access frequency)</strong>、<strong>延迟容忍度 (latency tolerance)</strong> 和 <strong>面积开销 (area overheads)</strong> 这三个维度，将元数据拆解。</li>
<li><strong>2KB/4KB 区域的模式</strong>：<ul>
<li><em>特点</em>：访问非常频繁，且预取距离短，对延迟极度敏感。</li>
<li><em>处理</em>：全部放在 <strong>on-chip PHT</strong> 中，保证最低延迟。</li>
</ul>
</li>
<li><strong>16KB 区域的模式</strong>：<ul>
<li><em>特点</em>：单个模式体积大（256-bit vector），总面积开销巨大；但一旦触发，能预取大量数据，因此对 metadata 的访问延迟有很高的容忍度；并且其访问具有 <strong>高度集中性</strong>（少数模式覆盖大部分请求）。</li>
<li><em>处理</em>：采用 <strong>tiered storage strategy</strong>（分层存储策略）。</li>
<li>在片上保留一个很小的 <strong>PHT Cache</strong>（仅256 entries），专门缓存 <strong>高频</strong> 的 16KB 模式。</li>
<li>绝大部分 <strong>低频</strong> 模式被卸载到 <strong>off-chip main memory</strong> 中的一个专用区域（128KB）。</li>
<li>引入一个 <strong>Valid Map</strong>（位图）来快速判断某个模式是否存在于主存中，避免无效的 off-chip 访问。</li>
<li>更绝的是，只有当一个 16KB 模式的 <strong>prefetch count</strong>（即 bit-vector 中 '1' 的数量）超过阈值（如30）时，才值得将其写入主存。这相当于设置了一个 ROI（投资回报率）门槛，确保 off-chip 操作的性价比。</li>
</ul>
</li>
</ul>
<p>这种设计的核心逻辑转换在于：<strong>将“存储位置”的决策从“能不能放得下”转变为“值不值得为它付出延迟代价”</strong>。通过承认并利用不同类型元数据的内在属性差异，RICH 用极小的片上代价（仅增加一个小型缓存和 Valid Map），就撬动了 off-chip 内存的巨大容量，从而支持了性能更强的大区域预取，完美解决了传统方案的两难困境。</p>
<p><img alt="" src="../images/caca357af3f3213087919d97821353c5fd143706cce1834eabdabd91fa574906.jpg" /></p>
<p><em>Table 2: Categorization of RICH's metadata</em></p>
<h3 id="4-eli5">4. 片外元数据访问过滤机制 (ELI5)<a class="headerlink" href="#4-eli5" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击</strong></p>
<ul>
<li>传统做法里，只要有个新的 <strong>16KB-region pattern</strong>（一个256-bit的位向量），就一股脑地往<strong>片外主存</strong>里读或写。这在直觉上很“完整”，但实际运行起来非常难受。</li>
<li>难受在哪？一次片外访问很可能导致<strong>两次 row buffer miss</strong>。在未来的高延迟内存系统里，这个代价极其高昂。</li>
<li>更要命的是，很多 pattern 根本不值得这么干。比如一个 pattern 里只有两三个 '1'，意味着它只会触发两三次预取。为了这点微薄的收益，去冒两次 row buffer miss 的巨大风险，完全是<strong>得不偿失</strong>，甚至会拖累整体性能。</li>
</ul>
<p><strong>通俗比方</strong></p>
<ul>
<li>这就像你开了一家快递中转站（CPU），旁边有个超大仓库（Off-chip Memory）。每次有新包裹（pattern）进来，你都得派一辆车（memory access）去仓库登记一下。</li>
<li>但如果是个只值几块钱的小包裹，派车过去一趟的油钱（row buffer miss penalty）可能比包裹本身还贵。聪明的做法是：<strong>只给那些价值超过30块钱的大包裹</strong>（prefetch count &gt; 30）。这样，你的车队资源（memory bandwidth）就能集中在真正能赚钱的业务上，避免被琐碎小事拖垮。</li>
</ul>
<p><strong>关键一招</strong></p>
<ul>
<li>作者没有改变 pattern 的学习和存储逻辑，而是在<strong>决定是否进行片外I/O操作的那个临界点</strong>，插入了一个极其简单的<strong>过滤器</strong>（filtering mechanism）。</li>
<li>具体来说：</li>
<li>在训练阶段，当一个 16KB-region 的 pattern 被最终确定后，系统会立刻计算其<strong>预取计数</strong>（prefetch count），也就是位向量中 '1' 的个数。</li>
<li><strong>只有当这个计数超过预设阈值</strong>（例如30），系统才会允许将这个 pattern <strong>写入</strong>（spill）到片外的 PHT 中。</li>
<li>同样，在预测阶段，即使片上缓存没命中，系统也会先检查片外 Valid Map。但即便 Valid Map 显示存在，如果当初写入时就没达标，这个 pattern 根本就不会存在于片外，自然也就不会触发昂贵的加载请求。</li>
<li>这一招的精妙之处在于，它用一个<strong>几乎零成本的计数判断</strong>，就规避了大量潜在的、高成本的无效片外访问，完美地平衡了<strong>收益</strong>（prefetch gain）与<strong>风险</strong>（row buffer miss penalty）。</li>
</ul>
<p><img alt="" src="../images/7fcf1667bbe6763eba48297e6be4a6523d2772cc0bdf46a4d54a203e974be30c.jpg" /></p>
<p><em>Table 6: Comparison of area overheads</em></p>
<p>如上表所示，RICH 通过这种机制，将片上存储开销从 Bingo 的 <strong>127 KB</strong> 大幅降低到 <strong>47 KB</strong>，同时仅使用 <strong>128 KB</strong> 的片外空间，就实现了超越所有对比方案的性能。这充分证明了该过滤机制的有效性。</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.sections", "navigation.top", "navigation.indexes", "search.suggest", "search.highlight", "content.code.copy"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../../../javascripts/switcher.js"></script>
      
    
  </body>
</html>