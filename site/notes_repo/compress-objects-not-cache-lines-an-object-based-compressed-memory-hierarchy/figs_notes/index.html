
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://example.com/notes_repo/compress-objects-not-cache-lines-an-object-based-compressed-memory-hierarchy/figs_notes/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Compress Objects, Not Cache Lines: An Object-Based Compressed Memory Hierarchy 图表详解 - BlaBlaCut</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#compress-objects-not-cache-lines-an-object-based-compressed-memory-hierarchy" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="BlaBlaCut" class="md-header__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            BlaBlaCut
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Compress Objects, Not Cache Lines: An Object-Based Compressed Memory Hierarchy 图表详解
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到深色模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换到深色模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到浅色模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换到浅色模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="BlaBlaCut" class="md-nav__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    BlaBlaCut
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/Recent/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Recent
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/awesome-data-prefetchers/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Awesome Data Prefetchers
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/micro-2025/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    MICRO 2025
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/dyn-lang-acc/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Dynamic Language Acceleration
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#figure-1-fraction-of-the-heap-consumed-by-objects-and-arrays-for-several-java-benchmarks" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 1. Fraction of the heap consumed by objects and arrays for several Java benchmarks.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-2-objects-and-their-memory-layout-in-btree" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 2. Objects and their memory layout in BTree.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-3-different-compression-techniques-applied-to-btree" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 3. Different compression techniques applied to BTree.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bcbc562f8ea691e62747a38ce7860a07b1679a1eb31128210c344d2c0badb3a3jpg" class="md-nav__link">
    <span class="md-ellipsis">
      
        bcbc562f8ea691e62747a38ce7860a07b1679a1eb31128210c344d2c0badb3a3.jpg
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-5-hotpads-is-a-hierarchical-memory-system-with-multiple-levels-of-pads" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 5. Hotpads is a hierarchical memory system with multiple levels of pads.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-6-pad-organization" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 6. Pad organization.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-4-example-showing-hotpadss-main-features" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 4. Example showing Hotpads’s main features.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#35ce53048314e9be49301bd8ce4b7e701647266fee21e9f7df35fc58587d8c42jpg" class="md-nav__link">
    <span class="md-ellipsis">
      
        35ce53048314e9be49301bd8ce4b7e701647266fee21e9f7df35fc58587d8c42.jpg
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-7-hotpads-pointer-format" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 7. Hotpads pointer format.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-8-example-zippads-hierarchy-with-a-compressed-last-level-pad-and-main-memory" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 8. Example Zippads hierarchy with a compressed last-level pad and main memory.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-9-compressing-newly-moved-objects" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 9. Compressing newly moved objects.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-10-compressing-objects-on-dirty-writebacks" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 10. Compressing objects on dirty writebacks.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-11-zippads-pointer-format-compression-information-is-encoded-in-the-pointer" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 11. Zippads pointer format. Compression information is encoded in the pointer.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-12-zippads-breaks-large-objects-into-subobjects" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 12. Zippads breaks large objects into subobjects.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-13-example-coco-compressed-object" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 13. Example COCO-compressed object.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-14-cdf-of-accesses-to-most-popular-object-ids" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 14. CDF of accesses to most popular object ids.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#table-3-zippadscoco-in-pointer-compression-information-x-denotes-the-bit-does-not-matter-and-cs-denote-the-bits-used-by-hybrid-bdifpc-encoding" class="md-nav__link">
    <span class="md-ellipsis">
      
        Table 3. Zippads+COCO in-pointer compression information. X denotes the bit does not matter, and Cs denote the bits used by hybrid BDI+FPC encoding.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#69e038bd5e3a77df4a6870a2333324b17d3853b29e842bef69f2adaca79c719djpg" class="md-nav__link">
    <span class="md-ellipsis">
      
        69e038bd5e3a77df4a6870a2333324b17d3853b29e842bef69f2adaca79c719d.jpg
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#f5b47feac26970f380675b9a3c900c0dc268bd149622922ce0588016b6967ff7jpg" class="md-nav__link">
    <span class="md-ellipsis">
      
        f5b47feac26970f380675b9a3c900c0dc268bd149622922ce0588016b6967ff7.jpg
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#table-6-workloads-and-inputs-used" class="md-nav__link">
    <span class="md-ellipsis">
      
        Table 6. Workloads and inputs used.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-15-compression-ratio-of-different-schemes" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 15. Compression ratio of different schemes.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-16-normalized-main-memory-traffic-of-different-schemes" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 16. Normalized main memory traffic of different schemes.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-17-performance-of-different-schemes" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 17. Performance of different schemes.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-18-results-for-cc-benchmarks" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 18. Results for C/C++ benchmarks.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-19-rate-of-base-object-cache-misses-in-misses-per-kcycle-log-scale" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 19. Rate of base object cache misses (in misses per Kcycle, log scale).
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-20-rate-of-dirty-writeback-overflows-in-overflows-per-kcycle-log-scale" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 20. Rate of dirty writeback overflows (in overflows per Kcycle, log scale).
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2a28fa03d9819cd940cddd0a0ed9577c75d2fb870eb8427c48e4f03001c6c682jpg" class="md-nav__link">
    <span class="md-ellipsis">
      
        2a28fa03d9819cd940cddd0a0ed9577c75d2fb870eb8427c48e4f03001c6c682.jpg
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="compress-objects-not-cache-lines-an-object-based-compressed-memory-hierarchy">Compress Objects, Not Cache Lines: An Object-Based Compressed Memory Hierarchy 图表详解<a class="headerlink" href="#compress-objects-not-cache-lines-an-object-based-compressed-memory-hierarchy" title="Permanent link">&para;</a></h1>
<h3 id="figure-1-fraction-of-the-heap-consumed-by-objects-and-arrays-for-several-java-benchmarks">Figure 1. Fraction of the heap consumed by objects and arrays for several Java benchmarks.<a class="headerlink" href="#figure-1-fraction-of-the-heap-consumed-by-objects-and-arrays-for-several-java-benchmarks" title="Permanent link">&para;</a></h3>
<p><img alt="8fe3e06e64dccc0c6fef36d78c31a4e726aec2ab53b534e5cb1bece555553ec6.jpg" src="../images/8fe3e06e64dccc0c6fef36d78c31a4e726aec2ab53b534e5cb1bece555553ec6.jpg" /></p>
<ul>
<li>图片展示了八个 Java 基准测试程序（fft, spmv, h2, specjbb, pagerank, coloring, btree, guavacache）中堆内存足迹（heap footprint）按数据类型划分的占比，旨在说明对象（Object）和数组（Array）在不同应用中的内存分布差异。</li>
<li><strong>核心观察</strong>：多数现代 Java 应用（除 fft 和 spmv 外）的堆内存主要由对象构成，而非传统科学计算中常见的数组。</li>
<li>数据以堆叠柱状图形式呈现，每个柱子代表一个基准测试，内部按三种数据类型细分：<ul>
<li><strong>Object</strong>（蓝色实块）：普通对象实例。</li>
<li><strong>Array of References</strong>（橙色斜线块）：引用类型的数组（如 Object[]）。</li>
<li><strong>Array of Primitives</strong>（绿色横线块）：基本类型数组（如 int[], double[]）。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Benchmark</th>
<th>Object (%)</th>
<th>Array of References (%)</th>
<th>Array of Primitives (%)</th>
</tr>
</thead>
<tbody>
<tr>
<td>fft</td>
<td>~0%</td>
<td>~0%</td>
<td><strong>~100%</strong></td>
</tr>
<tr>
<td>spmv</td>
<td>~0%</td>
<td>~0%</td>
<td><strong>~100%</strong></td>
</tr>
<tr>
<td>h2</td>
<td>~40%</td>
<td>~20%</td>
<td>~40%</td>
</tr>
<tr>
<td>specjbb</td>
<td>~50%</td>
<td>~30%</td>
<td>~20%</td>
</tr>
<tr>
<td>pagerank</td>
<td>~60%</td>
<td>~20%</td>
<td>~20%</td>
</tr>
<tr>
<td>coloring</td>
<td>~60%</td>
<td>~20%</td>
<td>~20%</td>
</tr>
<tr>
<td>btree</td>
<td>~70%</td>
<td>~10%</td>
<td>~20%</td>
</tr>
<tr>
<td>guavacache</td>
<td><strong>~80%</strong></td>
<td>~5%</td>
<td>~15%</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>关键结论</strong>：<ul>
<li><strong>fft 和 spmv</strong> 是典型的数组密集型科学计算程序，几乎全部堆内存用于存储基本类型数组。</li>
<li><strong>h2、specjbb、pagerank、coloring</strong> 属于混合型应用，对象占比在 50%-60%，但仍显著高于数组。</li>
<li><strong>btree 和 guavacache</strong> 是高度对象导向的应用，对象占据堆内存的 70% 以上，其中 <strong>guavacache 达到约 80%</strong>，是对象主导最明显的例子。</li>
</ul>
</li>
<li>此图支撑论文核心论点：现有基于 cache line 的压缩技术对对象密集型应用效果不佳，因为它们无法有效利用对象间冗余，且对象布局不规则，难以匹配固定大小的压缩单元。因此，提出 Zippads 和 COCO 等面向对象的压缩方案是必要的。</li>
</ul>
<h3 id="figure-2-objects-and-their-memory-layout-in-btree">Figure 2. Objects and their memory layout in BTree.<a class="headerlink" href="#figure-2-objects-and-their-memory-layout-in-btree" title="Permanent link">&para;</a></h3>
<p><img alt="bdd65e6304dd90ffd6873b4a3ad8bfdb9530560680f911dde6a40c83f7eeab1c.jpg" src="../images/bdd65e6304dd90ffd6873b4a3ad8bfdb9530560680f911dde6a40c83f7eeab1c.jpg" /></p>
<ul>
<li>图片展示了 BTree 应用中三个核心对象类型（Node、Entry[]、Entry）在内存中的布局，这些布局基于 Maxine JVM 的实现。</li>
<li><strong>Node 对象</strong>：<ul>
<li>总大小为 <strong>32 字节</strong>。</li>
<li>包含一个 <strong>Class id (Node)</strong> 标识符和一个 <strong>header</strong> 字段。</li>
<li>包含一个整型字段 <strong>int nChild</strong>，用于记录子节点数量。</li>
<li>包含一个引用字段 <strong>ref children</strong>，指向一个 Entry 数组对象。</li>
</ul>
</li>
<li><strong>Entry[] 对象</strong>：<ul>
<li>总大小为 <strong>56 字节</strong>（以 4 个元素为例）。</li>
<li>包含一个 <strong>Class id (Entry[])</strong> 标识符和一个 <strong>header</strong> 字段。</li>
<li>包含一个表示数组长度的字段 <strong>4 (Array length)</strong>。</li>
<li>包含四个引用字段：<strong>ref Entry[0]</strong> 到 <strong>ref Entry[3]</strong>，分别指向具体的 Entry 对象。</li>
</ul>
</li>
<li><strong>Entry 对象</strong>：<ul>
<li>总大小为 <strong>40 字节</strong>。</li>
<li>包含一个 <strong>Class id (Entry)</strong> 标识符和一个 <strong>header</strong> 字段。</li>
<li>包含三个引用字段：<strong>ref key</strong>、<strong>ref value</strong> 和 <strong>ref next</strong>，分别指向键、值和下一个 Entry 对象。</li>
</ul>
</li>
<li>红色箭头表示对象间的引用关系，例如 Node 引用 Entry[]，Entry[] 引用多个 Entry，Entry 又可能引用其他对象或自身形成链表。</li>
<li>下表总结了各对象的内存布局：</li>
</ul>
<table>
<thead>
<tr>
<th>对象类型</th>
<th>大小 (字节)</th>
<th>主要字段</th>
</tr>
</thead>
<tbody>
<tr>
<td>Node</td>
<td>32</td>
<td>Class id, header, int nChild, ref children</td>
</tr>
<tr>
<td>Entry[]</td>
<td>56</td>
<td>Class id, header, Array length (4), ref Entry[0]~[3]</td>
</tr>
<tr>
<td>Entry</td>
<td>40</td>
<td>Class id, header, ref key, ref value, ref next</td>
</tr>
</tbody>
</table>
<ul>
<li>这种布局体现了 Java 对象在内存中的典型结构，包括类标识、头部信息和实际数据字段，并通过引用连接形成复杂的数据结构。</li>
</ul>
<h3 id="figure-3-different-compression-techniques-applied-to-btree">Figure 3. Different compression techniques applied to BTree.<a class="headerlink" href="#figure-3-different-compression-techniques-applied-to-btree" title="Permanent link">&para;</a></h3>
<p><img alt="e728c1717ce55fe59ef92c8f9221b98257136721f2d7d2dc5103612d97b29a60.jpg" src="../images/e728c1717ce55fe59ef92c8f9221b98257136721f2d7d2dc5103612d97b29a60.jpg" /></p>
<ul>
<li>图片展示了四种不同压缩技术在 BTree 应用中的内存布局对比，旨在说明传统基于缓存行的压缩（如 LCP）与新型对象级压缩（Zippads + COCO）之间的效率差异。</li>
<li><strong>(a) No compression</strong>：未压缩状态。每个对象（Node、Entry[]、Entry[0] 至 Entry[3]）按原始大小连续存储于 4K 页面中，地址从 0x00 开始递增，无空间浪费。</li>
<li><strong>(b) LCP</strong>：采用 Linearly Compressed Pages 压缩方案。每个 64B 缓存行被压缩为固定 32B 块，但因算法限制和性能导向设计，导致大量<strong>未使用空间</strong>（hatched 区域），最终页面需向上取整至 2K，造成显著空间浪费。</li>
<li><strong>(c) Object-based compression</strong>：Zippads 的核心思想——以对象为单位压缩。对象被压缩后紧凑排列，无内部碎片；指针直接指向压缩后的对象地址，无需额外地址翻译层，实现<strong>紧凑布局</strong>与<strong>直接寻址</strong>。</li>
<li><strong>(d) Cross-object compression</strong>：引入 COCO 算法，在对象级压缩基础上进一步利用跨对象冗余。例如，仅存储一个基础对象 Entry[0]'，其余 Entry 对象只存储与之不同的字节（ΔEntry），从而获得更高压缩比。</li>
</ul>
<table>
<thead>
<tr>
<th>压缩方案</th>
<th>压缩单位</th>
<th>是否有内部碎片</th>
<th>是否需要地址翻译</th>
<th>是否利用跨对象冗余</th>
</tr>
</thead>
<tbody>
<tr>
<td>No compression</td>
<td>无</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>LCP</td>
<td>Cache line</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>Object-based (Zippads)</td>
<td>Object</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>Cross-object (COCO)</td>
<td>Object + Delta</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
</tbody>
</table>
<ul>
<li>关键视觉强调：<ul>
<li><strong>红色方框标注“Significant unused space due to performance-oriented layout”</strong>，突出 LCP 因追求低延迟而牺牲空间效率的问题。</li>
<li><strong>蓝色方框标注“Compact layout; pointers to compressed objects directly”</strong>，强调 Zippads 在布局紧凑性和指针直接寻址上的优势。</li>
<li><strong>红色箭头在 (c) 和 (d) 中表示指针重写机制</strong>，体现 Hotpads 架构下指针可被硬件动态更新以指向压缩对象的新位置。</li>
</ul>
</li>
<li>此图直观验证了论文核心论点：<strong>对象是对象型程序的自然压缩单元</strong>，且<strong>跨对象冗余是提升压缩率的关键</strong>。</li>
</ul>
<h3 id="bcbc562f8ea691e62747a38ce7860a07b1679a1eb31128210c344d2c0badb3a3jpg">bcbc562f8ea691e62747a38ce7860a07b1679a1eb31128210c344d2c0badb3a3.jpg<a class="headerlink" href="#bcbc562f8ea691e62747a38ce7860a07b1679a1eb31128210c344d2c0badb3a3jpg" title="Permanent link">&para;</a></h3>
<p><img alt="bcbc562f8ea691e62747a38ce7860a07b1679a1eb31128210c344d2c0badb3a3.jpg" src="../images/bcbc562f8ea691e62747a38ce7860a07b1679a1eb31128210c344d2c0badb3a3.jpg" /></p>
<ul>
<li>该图片为一张数据表格，标题为“Table 1. Compression ratios of different schemes on BTree.”，用于展示在 BTree 微基准测试中四种不同压缩方案的压缩比。</li>
<li>表格包含两行五列。第一行为方案名称及对应图示引用，第二行为对应的压缩比数值。</li>
<li>方案一为“No comp.”（无压缩），作为基准，其压缩比为 <strong>1.00</strong>，对应图 3a 的内存布局。</li>
<li>方案二为“LCP”，即 Linearly Compressed Pages 压缩方案，压缩比为 <strong>1.10</strong>，对应图 3b。该方案因固定块大小和内部碎片导致效率低下。</li>
<li>方案三为“Object-based”，即基于对象的压缩方案，压缩比提升至 <strong>1.56</strong>，对应图 3c。此方案通过直接压缩整个对象并消除地址翻译层，实现了更紧凑的存储。</li>
<li>方案四为“Cross-object”，即跨对象压缩方案（COCO），压缩比进一步提升至 <strong>1.95</strong>，对应图 3d。该方案利用同类型对象间的冗余，仅存储与基对象的差异部分，从而获得最高压缩效率。</li>
<li>数据表明，从传统 LCP 到对象级再到跨对象压缩，压缩比呈阶梯式增长，验证了论文提出的两个核心洞察：<strong>对象是更自然的压缩单元</strong>，且<strong>跨对象存在大量冗余可被利用</strong>。</li>
</ul>
<table>
<thead>
<tr>
<th>方案名称</th>
<th>对应图示</th>
<th>压缩比</th>
</tr>
</thead>
<tbody>
<tr>
<td>No comp.</td>
<td>Fig. 3a</td>
<td>1.00</td>
</tr>
<tr>
<td>LCP</td>
<td>Fig. 3b</td>
<td>1.10</td>
</tr>
<tr>
<td>Object-based</td>
<td>Fig. 3c</td>
<td>1.56</td>
</tr>
<tr>
<td>Cross-object</td>
<td>Fig. 3d</td>
<td>1.95</td>
</tr>
</tbody>
</table>
<h3 id="figure-5-hotpads-is-a-hierarchical-memory-system-with-multiple-levels-of-pads">Figure 5. Hotpads is a hierarchical memory system with multiple levels of pads.<a class="headerlink" href="#figure-5-hotpads-is-a-hierarchical-memory-system-with-multiple-levels-of-pads" title="Permanent link">&para;</a></h3>
<p><img alt="f01a07dcbf839ae1c317dc648d5b90e120cc892cf049c0d865ab048c330c0841.jpg" src="../images/f01a07dcbf839ae1c317dc648d5b90e120cc892cf049c0d865ab048c330c0841.jpg" /></p>
<ul>
<li>图片展示了 <strong>Hotpads</strong> 的层级内存系统架构，包含多个 <strong>Pad</strong> 层级，从核心到主存呈线性递进结构。</li>
<li>系统由四个主要组件构成：<strong>Core</strong>、<strong>L1 Pad</strong>、<strong>L2 Pad</strong>、<strong>L3 Pad</strong> 和 <strong>Main Memory</strong>，各组件之间通过双向箭头连接，表示数据可双向流动。</li>
<li><strong>Core</strong> 位于最左侧，代表处理器核心，直接与 <strong>L1 Pad</strong> 交互，是整个内存访问路径的起点。</li>
<li><strong>L1 Pad</strong>、<strong>L2 Pad</strong>、<strong>L3 Pad</strong> 依次向右排列，颜色均为浅蓝色，表明它们属于同一类硬件单元——<strong>Pad</strong>，用于存储变量大小的对象，支持高效对象迁移和管理。</li>
<li><strong>Main Memory</strong> 位于最右侧，以绿色方框表示，作为最终的后备存储，与 <strong>L3 Pad</strong> 相连，承担冷数据的持久化存储功能。</li>
<li>各 <strong>Pad</strong> 层级之间通过单向或双向箭头连接，体现对象在层级间按热度迁移的机制：热对象驻留于靠近核心的 <strong>Pad</strong>，冷对象逐级移至更深层级或主存。</li>
<li>此架构设计的核心优势在于：<strong>对象粒度的数据移动</strong>、<strong>硬件管理的垃圾回收</strong>、以及<strong>避免传统缓存的关联查找开销</strong>，从而提升内存效率。</li>
<li>图中未显示具体容量或延迟参数，但根据上下文，<strong>Pad</strong> 的大小通常较小，适合快速硬件操作，而 <strong>Main Memory</strong> 则提供大容量存储。</li>
</ul>
<table>
<thead>
<tr>
<th>组件</th>
<th>类型</th>
<th>功能描述</th>
<th>连接方向</th>
</tr>
</thead>
<tbody>
<tr>
<td>Core</td>
<td>处理器核心</td>
<td>发起内存访问，与 L1 Pad 直接交互</td>
<td>双向</td>
</tr>
<tr>
<td>L1 Pad</td>
<td>Scratchpad</td>
<td>存储热对象，支持快速分配与访问</td>
<td>与 Core、L2</td>
</tr>
<tr>
<td>L2 Pad</td>
<td>Scratchpad</td>
<td>中间层，存储较冷对象，支持对象迁移</td>
<td>与 L1、L3</td>
</tr>
<tr>
<td>L3 Pad</td>
<td>Scratchpad</td>
<td>最后一层 Pad，存储冷对象，接近主存</td>
<td>与 L2、Main</td>
</tr>
<tr>
<td>Main Memory</td>
<td>主存</td>
<td>持久化存储所有对象，作为最终后备</td>
<td>与 L3</td>
</tr>
</tbody>
</table>
<ul>
<li>整体结构体现了 <strong>Hotpads</strong> 的设计理念：<strong>隐藏内存布局</strong>、<strong>对象为中心</strong>、<strong>硬件自动管理</strong>，适用于现代面向对象语言的内存需求。</li>
</ul>
<h3 id="figure-6-pad-organization">Figure 6. Pad organization.<a class="headerlink" href="#figure-6-pad-organization" title="Permanent link">&para;</a></h3>
<p><img alt="76d41b0458bd3b194263bf8b5cbd698982ddad34e583cfccc6e7fa117b89db59.jpg" src="../images/76d41b0458bd3b194263bf8b5cbd698982ddad34e583cfccc6e7fa117b89db59.jpg" /></p>
<ul>
<li>图片展示了 <strong>Hotpads</strong> 系统中一个 <strong>pad</strong> 的内部组织结构，是理解 Zippads 压缩机制的基础。</li>
<li>整体结构分为三个主要区域：<strong>Data Array</strong>、<strong>Metadata</strong> 和 <strong>Canonical Tags</strong>，它们在物理上是分离的。</li>
<li><strong>Data Array</strong> 是 pad 的核心存储区，采用 <strong>循环缓冲区（circular buffer）</strong> 设计，包含两个逻辑部分：<ul>
<li><strong>Objects</strong>：已分配的对象数据块，按顺序存放，形成一个连续的已用区域。</li>
<li><strong>Free space</strong>：未使用的空闲空间，位于已分配对象之后，用于新对象的分配。</li>
</ul>
</li>
<li><strong>Metadata</strong> 区域与 Data Array 并行存在，其作用是记录每个存储在 Data Array 中的对象的元信息。图中标注为 “(word/object)”，暗示其粒度可以是字或对象级别，用于支持对象的定位和管理。</li>
<li><strong>Canonical Tags</strong> 是一个独立的标签存储区，用于实现 <strong>解耦式标签查找（decoupled tag store）</strong>。它存储的是对象的“规范地址”（canonical address），即对象在其“规范层级”（canonical level）上的地址，用于在对象被复制到不同层级时进行地址翻译。</li>
<li>这种设计的关键优势在于：<ul>
<li><strong>Bump pointer allocation</strong>：新对象或从下层迁移上来的对象直接追加到已分配区域末尾，分配效率极高。</li>
<li><strong>避免关联查找</strong>：通过指针重写（pointer rewriting）和 Canonical Tags，系统能快速定位对象副本，大幅减少传统缓存所需的昂贵关联查找操作。</li>
<li><strong>支持压缩</strong>：Zippads 利用这种结构，在对象被移动到压缩层级（如 L3 pad 或主存）时，直接在 Data Array 的空闲空间中存储其压缩后的版本，并更新所有指向它的指针，从而避免了额外的地址转换开销。</li>
</ul>
</li>
</ul>
<h3 id="figure-4-example-showing-hotpadss-main-features">Figure 4. Example showing Hotpads’s main features.<a class="headerlink" href="#figure-4-example-showing-hotpadss-main-features" title="Permanent link">&para;</a></h3>
<p><img alt="38a37e2d7f1c4de83780e94df44f3db956893cfa0366b407c1db7dbf647c2429.jpg" src="../images/38a37e2d7f1c4de83780e94df44f3db956893cfa0366b407c1db7dbf647c2429.jpg" /></p>
<ul>
<li>
<p>图片展示了 Hotpads 内存层次结构的核心机制，通过一个单核系统中 ListNode 对象的生命周期示例进行说明。整个流程分为五个阶段，从初始状态到经历对象访问、分配、以及最终的 Collection-Eviction（CE）过程。</p>
</li>
<li>
<p><strong>初始状态 (0)</strong>：</p>
<ul>
<li>系统包含寄存器文件（RegFile）、L1 Pad、L2 Pad 和主存（Main Mem）。</li>
<li>寄存器 r1 指向位于 L2 Pad 的对象 A；A 的 next 字段指向位于主存的对象 B。</li>
<li>对象 A 的<strong>canonical level</strong>为 L2，意味着其“权威”副本存储在 L2，主存中无对应副本。</li>
<li>对象 B 的 canonical level 为主存。</li>
<li>L1 和 L2 Pad 中还存在其他无关对象（橙色块），用于展示 Pad 的空间布局。</li>
</ul>
</li>
<li>
<p><strong>对象访问 (1)</strong>：</p>
<ul>
<li>程序执行 <code>int v = A.value;</code>，触发对对象 A 的访问。</li>
<li>Hotpads 将对象 A 从 L2 Pad 复制到 L1 Pad 的空闲区域末尾。</li>
<li>同时，<strong>指针重写</strong>机制将寄存器 r1 中的指针更新为指向 L1 Pad 中的新副本。</li>
<li>此后，对该对象的任何访问都将直接命中 L1，无需再访问 L2。</li>
</ul>
</li>
<li>
<p><strong>指针解引用 (2)</strong>：</p>
<ul>
<li>程序执行 <code>v = A.next.value;</code>，即解引用 A 的 next 指针以访问对象 B。</li>
<li>Hotpads 将对象 B 从主存复制到 L1 Pad 的空闲区域。</li>
<li>同样，A 内部指向 B 的指针被重写，指向 L1 Pad 中 B 的新副本。</li>
<li>这体现了 Hotpads 的<strong>对象粒度数据移动</strong>特性。</li>
</ul>
</li>
<li>
<p><strong>对象分配 (3)</strong>：</p>
<ul>
<li>程序执行 <code>ListNode C = new ListNode();</code>，创建一个新对象 C。</li>
<li>Hotpads 直接在 L1 Pad 的空闲空间中分配对象 C，无需为其在主存中预留空间。</li>
<li>新对象 C 的 canonical level 即为 L1，它是一个完全驻留在缓存层次中的对象。</li>
</ul>
</li>
<li>
<p><strong>Collection-Eviction (4 &amp; 5)</strong>：</p>
<ul>
<li>当 L1 Pad 空间耗尽时，触发 CE 过程。</li>
<li><strong>阶段 4 (CE 前)</strong>：图中显示 L1 Pad 已满，包含对象 A（已修改）、B、C 和 D。其中 C 是死对象（未被引用），D 是活对象（被 A 引用）。A 的 L1 副本是脏的，L2 副本已过时。</li>
<li><strong>阶段 5 (CE 后)</strong>：<ul>
<li><strong>垃圾回收</strong>：死对象 C 被回收，释放空间。</li>
<li><strong>对象迁移</strong>：活对象 A 和 D 被迁移到 L2 Pad。由于 A 原本来自 L2，其修改后的副本被写回 L2 的原位置。D 则获得一个新的 L2 地址作为其新的 canonical level。</li>
<li><strong>对象保留与移动</strong>：对象 B 因最近被访问而保留在 L1，并被移动到数组起始位置。</li>
<li><strong>指针更新</strong>：所有指向被移动对象的指针（如寄存器 r3 和对象 A 内部的指针）都被更新，指向它们在新位置的地址。</li>
<li><strong>内存整理</strong>：CE 过程会将所有存活对象紧凑地排列在一起，消除碎片，简化空闲空间管理。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>该图清晰地阐释了 Hotpads 的三大核心优势：</p>
<ul>
<li><strong>对象粒度操作</strong>：数据移动和管理以对象为单位，而非固定大小的 cache line。</li>
<li><strong>指针重写</strong>：通过硬件自动更新指针，确保程序始终访问最新副本，避免了复杂的地址翻译表。</li>
<li><strong>硬件加速的 GC/CE</strong>：利用硬件在 Pad 层级实现快速的垃圾回收和对象迁移，显著减少主存流量。</li>
</ul>
</li>
<li>
<p>下表总结了各阶段的关键事件：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: left;">阶段</th>
<th style="text-align: left;">关键事件</th>
<th style="text-align: left;">对象状态变化</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">0</td>
<td style="text-align: left;">初始状态</td>
<td style="text-align: left;">A 在 L2, B 在 Main Mem</td>
</tr>
<tr>
<td style="text-align: left;">1</td>
<td style="text-align: left;">访问 A</td>
<td style="text-align: left;">A 被复制到 L1, r1 指向 L1 副本</td>
</tr>
<tr>
<td style="text-align: left;">2</td>
<td style="text-align: left;">解引用 A.next</td>
<td style="text-align: left;">B 被复制到 L1, A 的 next 指针指向 L1 副本</td>
</tr>
<tr>
<td style="text-align: left;">3</td>
<td style="text-align: left;">分配 C</td>
<td style="text-align: left;">C 在 L1 分配，无主存副本</td>
</tr>
<tr>
<td style="text-align: left;">4</td>
<td style="text-align: left;">L1 满，触发 CE</td>
<td style="text-align: left;">A (dirty), B, C (dead), D (live)</td>
</tr>
<tr>
<td style="text-align: left;">5</td>
<td style="text-align: left;">CE 完成</td>
<td style="text-align: left;">C 被回收；A 写回 L2；D 移至 L2；B 保留在 L1 并移动；所有相关指针更新</td>
</tr>
</tbody>
</table>
<ul>
<li>此机制为 Zippads 提供了基础，使其能够在对象被迁移到压缩层级时，直接将其压缩并更新指针，从而避免了传统压缩架构所需的额外地址转换开销。</li>
</ul>
<h3 id="35ce53048314e9be49301bd8ce4b7e701647266fee21e9f7df35fc58587d8c42jpg">35ce53048314e9be49301bd8ce4b7e701647266fee21e9f7df35fc58587d8c42.jpg<a class="headerlink" href="#35ce53048314e9be49301bd8ce4b7e701647266fee21e9f7df35fc58587d8c42jpg" title="Permanent link">&para;</a></h3>
<p><img alt="35ce53048314e9be49301bd8ce4b7e701647266fee21e9f7df35fc58587d8c42.jpg" src="../images/35ce53048314e9be49301bd8ce4b7e701647266fee21e9f7df35fc58587d8c42.jpg" /></p>
<ul>
<li>该图片展示的是 <strong>Hotpads ISA</strong> 的一部分，具体为支持对象访问和指针操作的指令集。</li>
<li>指令分为三类：<strong>数据加载/存储</strong>、<strong>指针加载/存储</strong> 和 <strong>对象分配</strong>。</li>
<li>所有指令均采用 <strong>base+offset</strong> 寻址模式，其中 <code>rb</code> 为基址寄存器，必须持有对象指针；<code>disp</code> 为偏移量，可为立即数或寄存器。</li>
<li>数据指令（<code>ld</code>, <code>st</code>）用于非指针数据，指针指令（<code>ldptr</code>, <code>stptr</code>）用于访问对象内的指针字段，确保硬件能控制指针内容。</li>
<li>分配指令 <code>alloc</code> 接收两个参数：<code>rs1</code> 指定对象大小，<code>rs2</code> 指定类型 ID；返回新对象地址至目标寄存器 <code>rp</code>。</li>
<li>此设计使 <strong>Hotpads</strong> 能透明管理对象生命周期与指针重写，为 <strong>Zippads</strong> 的压缩机制提供底层支持。</li>
</ul>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Format</th>
<th>Operation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data Load</td>
<td><code>ld rd, disp(rb)</code></td>
<td><code>rd &lt;- Mem[EffAddr]</code></td>
</tr>
<tr>
<td>Data Store</td>
<td><code>st rd, disp(rb)</code></td>
<td><code>Mem[EffAddr] &lt;- rd</code></td>
</tr>
<tr>
<td>Pointer Load</td>
<td><code>ldptr rp, disp(rb)</code></td>
<td><code>rp &lt;- Mem[EffAddr]</code></td>
</tr>
<tr>
<td>Pointer Store</td>
<td><code>stptr rp, disp(rb)</code></td>
<td><code>Mem[EffAddr] &lt;- rp</code></td>
</tr>
<tr>
<td>Allocation</td>
<td><code>alloc rp, rs1, rs2</code></td>
<td><code>NewAddr &lt;- Alloc(rs1); Mem[NewAddr] &lt;- rs2; rp &lt;- NewAddr;</code></td>
</tr>
<tr>
<td></td>
<td><code>(rs1 = size)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>(rs2 = type id)</code></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>关键术语如 <strong>ISA</strong>, <strong>base+offset</strong>, <strong>EffAddr</strong>, <strong>Alloc</strong> 均保留英文原名。</li>
<li>该表是理解 <strong>Hotpads</strong> 如何实现对象级内存管理的基础，也是 <strong>Zippads</strong> 实现无地址翻译压缩的前提。</li>
</ul>
<h3 id="figure-7-hotpads-pointer-format">Figure 7. Hotpads pointer format.<a class="headerlink" href="#figure-7-hotpads-pointer-format" title="Permanent link">&para;</a></h3>
<p><img alt="4e5d669dce8379eb2f4d91d9687aef0a0b6fb3fd4e38e081ea3932fbd53f27a5.jpg" src="../images/4e5d669dce8379eb2f4d91d9687aef0a0b6fb3fd4e38e081ea3932fbd53f27a5.jpg" /></p>
<ul>
<li>图片展示了 <strong>Hotpads</strong> 系统中指针的格式，该格式是微架构层面的设计，对软件层透明。</li>
<li>指针总长度为 64 位，分为两个主要字段：<strong>Size</strong> 和 <strong>Address</strong>。</li>
<li><strong>Size</strong> 字段占据高 14 位（位 63 至 50），用于存储对象的大小（以字为单位）。此设计简化了对象读取操作：硬件只需从起始地址读取指定数量的字即可完整获取对象内容。</li>
<li><strong>Address</strong> 字段占据低 48 位（位 47 至 0），用于存储对象在内存中的起始地址。该地址始终指向对象的第一个字（word-aligned）。</li>
<li>该指针格式允许硬件直接控制和操作指针内容，这是 <strong>Zippads</strong> 能够在压缩时重写指针、直接指向压缩对象的关键前提。</li>
<li>下表总结了该指针格式的位域分配：</li>
</ul>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>位范围</th>
<th>位数</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Size</td>
<td>63-50</td>
<td>14</td>
<td>存储对象大小（单位：字）</td>
</tr>
<tr>
<td>Address</td>
<td>47-0</td>
<td>48</td>
<td>存储对象起始地址</td>
</tr>
</tbody>
</table>
<ul>
<li>此格式为后续 <strong>Zippads</strong> 的扩展奠定了基础，例如在指针中嵌入压缩元数据（如压缩算法类型、压缩后大小等），而无需修改指令集架构（ISA）。</li>
</ul>
<h3 id="figure-8-example-zippads-hierarchy-with-a-compressed-last-level-pad-and-main-memory">Figure 8. Example Zippads hierarchy with a compressed last-level pad and main memory.<a class="headerlink" href="#figure-8-example-zippads-hierarchy-with-a-compressed-last-level-pad-and-main-memory" title="Permanent link">&para;</a></h3>
<p><img alt="8f92beefb065583cbba85410317968837cae46f00dcae0f93dcb1de1c683bf39.jpg" src="../images/8f92beefb065583cbba85410317968837cae46f00dcae0f93dcb1de1c683bf39.jpg" /></p>
<ul>
<li>图片展示了 <strong>Zippads</strong> 内存层次结构的一个实例，其核心设计是将压缩操作集中在 <strong>最后一级 Pad（L3 Pad）</strong> 和 <strong>主存（Main Memory）</strong>，而 <strong>L1 Pad</strong> 和 <strong>L2 Pad</strong> 保持未压缩状态。</li>
<li>整个系统分为两个主要区域：左侧为 <strong>Uncompressed</strong> 区域，包含 <strong>Core</strong>、<strong>L1 Pad</strong> 和 <strong>L2 Pad</strong>；右侧为 <strong>Compressed</strong> 区域，包含 <strong>L3 Pad</strong> 和 <strong>Main Memory</strong>。</li>
<li>在 <strong>Uncompressed</strong> 区域内，数据在 <strong>Core</strong>、<strong>L1 Pad</strong> 和 <strong>L2 Pad</strong> 之间直接传输，无需压缩或解压操作，保证了低延迟访问。</li>
<li>当数据从 <strong>L2 Pad</strong> 向 <strong>L3 Pad</strong> 移动时，会经过一个 <strong>Compress</strong> 模块进行压缩处理，确保进入压缩区域的数据是压缩格式。</li>
<li>反之，当数据从 <strong>L3 Pad</strong> 返回到 <strong>L2 Pad</strong> 时，会经过一个 <strong>Decompress</strong> 模块进行解压，以恢复原始数据格式供上层使用。</li>
<li><strong>L3 Pad</strong> 与 <strong>Main Memory</strong> 之间的数据传输也保持压缩状态，进一步减少带宽需求和存储占用。</li>
<li>这种分层设计使得 <strong>Zippads</strong> 能够在保持高性能的同时，有效利用压缩技术提升内存效率，尤其适用于对象密集型应用。</li>
</ul>
<h3 id="figure-9-compressing-newly-moved-objects">Figure 9. Compressing newly moved objects.<a class="headerlink" href="#figure-9-compressing-newly-moved-objects" title="Permanent link">&para;</a></h3>
<p><img alt="272ea60c2ad851ac811800532914227cbc1cf9ea9d2c4a00de829868524fe24c.jpg" src="../images/272ea60c2ad851ac811800532914227cbc1cf9ea9d2c4a00de829868524fe24c.jpg" /></p>
<ul>
<li>图片展示了 Zippads 系统中 <strong>Case 1: Newly moved objects</strong> 的压缩流程，即对象首次从非压缩层级（如 L2 pad）迁移到压缩层级（如 L3 pad）时的处理方式。</li>
<li>流程起始于 <strong>L2 pad</strong> 中的一个 <strong>uncompressed object</strong>，该对象在被访问后触发迁移机制，进入压缩路径。</li>
<li>经过 <strong>Compress</strong> 模块处理后，对象被压缩并写入 <strong>L3 pad</strong> 的数据区域，此时对象状态变为 <strong>compressed</strong>。</li>
<li>在 L3 pad 中，新压缩对象被放置于 <strong>Free space</strong> 起始位置，采用 <strong>bump-pointer allocation</strong> 策略，确保对象之间无空隙，最大化空间利用率。</li>
<li>压缩完成后，该对象的 <strong>canonical address</strong> 更新为 L3 pad 中的新地址，所有指向该对象的指针（包括寄存器和 pad 内部指针）均被重写，以直接引用压缩后的对象，避免额外地址翻译开销。</li>
<li>此过程体现了 Zippads 的核心设计原则：<strong>压缩对象而非 cache line</strong>，并利用 Hotpads 的对象迁移机制实现透明压缩。</li>
</ul>
<table>
<thead>
<tr>
<th>阶段</th>
<th>源位置</th>
<th>目标位置</th>
<th>对象状态</th>
<th>关键操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>迁移前</td>
<td>L2 pad</td>
<td>—</td>
<td>uncompressed</td>
<td>触发迁移条件（如未被频繁访问）</td>
</tr>
<tr>
<td>压缩中</td>
<td>—</td>
<td>Compress模块</td>
<td>intermediate</td>
<td>执行压缩算法（如 COCO 或 BDI+FPC）</td>
</tr>
<tr>
<td>迁移后</td>
<td>—</td>
<td>L3 pad (Free space)</td>
<td>compressed</td>
<td>bump-pointer 分配 + 指针重写</td>
</tr>
</tbody>
</table>
<ul>
<li>该图强调了 Zippads 如何通过对象粒度压缩与硬件指针重写，消除传统压缩内存系统所需的 <strong>address translation layer</strong>，从而降低延迟与元数据开销。</li>
</ul>
<h3 id="figure-10-compressing-objects-on-dirty-writebacks">Figure 10. Compressing objects on dirty writebacks.<a class="headerlink" href="#figure-10-compressing-objects-on-dirty-writebacks" title="Permanent link">&para;</a></h3>
<p><img alt="ba976f517325f825831d5c8a4585eeaef5e316635003d1338cfcd35a928e53fd.jpg" src="../images/ba976f517325f825831d5c8a4585eeaef5e316635003d1338cfcd35a928e53fd.jpg" /></p>
<ul>
<li>图片展示了 Zippads 在处理 <strong>dirty writeback</strong> 时的压缩对象存储策略，分为两种情况：新压缩大小小于等于旧大小，以及新压缩大小大于旧大小。</li>
<li><strong>Case 2: Dirty writeback</strong> 流程起点为一个未压缩的更新对象（Updated object (uncompressed)），经过压缩后生成一个压缩对象（Compress → Updated object (compressed)）。</li>
<li>当新压缩对象大小 <strong>≤</strong> 旧压缩对象大小时：<ul>
<li>新对象直接覆盖原位置。</li>
<li>若新大小更小，则留下 <strong>Unused space</strong>（未使用空间），该空间被保留，不回收。</li>
</ul>
</li>
<li>当新压缩对象大小 <strong>&gt;</strong> 旧压缩对象大小时：<ul>
<li>原位置无法容纳新对象，触发 <strong>overflow</strong>。</li>
<li>系统在可用空间中分配新位置存放压缩对象。</li>
<li>原位置被转换为 <strong>Forwarding thunk</strong>，其中存储指向新位置的指针。</li>
<li>后续访问原地址时，会通过 forwarding thunk 重定向到新位置。</li>
</ul>
</li>
<li>该机制确保了指针一致性，避免因对象移动导致访问失效。</li>
<li>虽然 overflow 和 unused space 会造成临时存储效率下降，但 Zippads 通过 <strong>periodic compaction</strong>（周期性整理）在 Collection-Eviction（CE）过程中消除这些碎片。</li>
<li>下表总结了两种情况下的存储行为：</li>
</ul>
<table>
<thead>
<tr>
<th>条件</th>
<th>存储位置</th>
<th>是否产生碎片</th>
<th>解决方案</th>
</tr>
</thead>
<tbody>
<tr>
<td>new size ≤ old size</td>
<td>原位置</td>
<td>是（若更小则留 unused space）</td>
<td>CE 期间 compact 消除</td>
</tr>
<tr>
<td>new size &gt; old size</td>
<td>新分配位置</td>
<td>是（原位置变 forwarding thunk）</td>
<td>CE 期间 compact 消除</td>
</tr>
</tbody>
</table>
<ul>
<li>此设计权衡了写回延迟与存储效率，依赖硬件自动管理指针重写和碎片回收，无需软件干预。</li>
</ul>
<h3 id="figure-11-zippads-pointer-format-compression-information-is-encoded-in-the-pointer">Figure 11. Zippads pointer format. Compression information is encoded in the pointer.<a class="headerlink" href="#figure-11-zippads-pointer-format-compression-information-is-encoded-in-the-pointer" title="Permanent link">&para;</a></h3>
<p><img alt="4fe784bb23414488022335e306dd60fbf8d8658bf4467c9516532f4d4c391320.jpg" src="../images/4fe784bb23414488022335e306dd60fbf8d8658bf4467c9516532f4d4c391320.jpg" /></p>
<ul>
<li>
<p>图片展示了 <strong>Zippads</strong> 系统中指针的格式设计，其核心思想是将压缩元数据直接编码在指针内部，而非依赖缓存标签或额外的地址翻译表。</p>
</li>
<li>
<p>该指针为 64 位宽，结构从高位到低位划分为三个主要字段：</p>
<ul>
<li><strong>Compressed size (压缩大小)</strong>：占据高 15 位（位 63 至 49），用于存储对象被压缩后的实际大小（以字为单位）。此信息对硬件至关重要，因为它决定了在访问时需要从内存中读取多少数据。</li>
<li><strong>Compression encoding bits (压缩编码位)</strong>：占据中间 X 位（位 48 至 49-X），用于指示当前对象所使用的具体压缩算法及其相关参数。例如，当使用 BDI 算法时，这几位可能用于选择不同的编码模式。</li>
<li><strong>Address (地址)</strong>：占据剩余的低 (48-X) 位，用于存储对象在内存中的起始地址。由于压缩信息和大小信息占据了部分位宽，因此可用的地址空间略有缩减。</li>
</ul>
</li>
<li>
<p>这种设计的关键优势在于其高效性与透明性：</p>
<ul>
<li><strong>避免地址转换开销</strong>：所有内存访问都始于一个指针。通过将压缩信息内嵌于指针，硬件在获取指针后即可立即知道如何解压数据，无需进行额外的地址查找或翻译步骤，从而避免了传统压缩内存架构中常见的“第二级翻译”开销。</li>
<li><strong>支持异构压缩</strong>：不同的对象可以使用不同的压缩算法（如 COCO 或 BDI+FPC），指针中的编码位允许系统动态识别并应用正确的解压逻辑。</li>
<li><strong>保持 ISA 透明</strong>：虽然指针格式发生了变化，但这种变化是微架构层面的，对上层软件和指令集架构（ISA）是透明的，应用程序无需修改即可运行。</li>
</ul>
</li>
<li>
<p>下表总结了 Zippads 指针格式的字段分配：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: left;">字段名称</th>
<th style="text-align: left;">位宽</th>
<th style="text-align: left;">位置 (bit)</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Compressed size</td>
<td style="text-align: left;">15 bits</td>
<td style="text-align: left;">63-49</td>
<td style="text-align: left;">存储压缩后对象的大小（以字为单位），指导硬件读取正确数量的数据。</td>
</tr>
<tr>
<td style="text-align: left;">Compression encoding bits</td>
<td style="text-align: left;">X bits</td>
<td style="text-align: left;">48-(49-X)</td>
<td style="text-align: left;">存储算法标识和参数，用于选择正确的解压算法。</td>
</tr>
<tr>
<td style="text-align: left;">Address</td>
<td style="text-align: left;">(48-X) bits</td>
<td style="text-align: left;">(49-X)-0</td>
<td style="text-align: left;">存储对象在内存中的起始地址，地址空间因压缩元数据而略有缩减。</td>
</tr>
</tbody>
</table>
<ul>
<li>该设计是 <strong>Zippads</strong> 能够实现高效、紧凑的对象压缩存储的基础，它巧妙地利用了对象导向程序中“通过指针访问”的固有特性，将压缩管理的复杂性封装在指针本身，从而实现了高性能和高压缩率的统一。</li>
</ul>
<h3 id="figure-12-zippads-breaks-large-objects-into-subobjects">Figure 12. Zippads breaks large objects into subobjects.<a class="headerlink" href="#figure-12-zippads-breaks-large-objects-into-subobjects" title="Permanent link">&para;</a></h3>
<p><img alt="746182b37942c3612c6be6964b2fee50109c568eff8169a9e37a87520c5d7614.jpg" src="../images/746182b37942c3612c6be6964b2fee50109c568eff8169a9e37a87520c5d7614.jpg" /></p>
<ul>
<li>
<p>图片展示了 <strong>Zippads</strong> 如何处理大型对象（&gt;128B）的压缩与访问机制，核心策略是将其拆分为多个 <strong>64B subobjects</strong>，以避免全对象解压带来的高延迟。</p>
</li>
<li>
<p>该图通过三阶段流程图说明了从对象分配到子对象按需加载的过程：</p>
<ul>
<li><strong>阶段①：分配索引数组</strong><ul>
<li>程序调用 <code>alloc rp, 256, intA</code> 分配一个 256B 对象。</li>
<li>Zippads 不立即分配完整空间，而是创建一个包含 4 个元素的 <strong>Index array</strong>（每个指向一个 64B subobject）。</li>
<li>所有指针初始为 <strong>Null</strong>，表示对应 subobject 尚未分配。</li>
</ul>
</li>
<li><strong>阶段②：首次访问触发分配</strong><ul>
<li>程序执行 <code>ld rd, 72(rp)</code>，访问偏移 72 字节处的数据。</li>
<li>72 字节属于第二个 subobject（64–127 字节范围），因此 Zippads 动态分配该 subobject。</li>
<li>更新 Index array 中对应条目，使其指向新分配的 subobject。</li>
</ul>
</li>
<li><strong>阶段③ &amp; ④：后续访问与写回</strong><ul>
<li>程序执行 <code>addi rd, 1</code> 和 <code>st rd, 72(rp)</code>，修改并写回数据。</li>
<li>Zippads 通过 Index array 定位目标 subobject，完成读写操作。</li>
<li>每次访问仅涉及单个 subobject，无需解压整个大对象。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>关键设计要点：</p>
<ul>
<li><strong>allocate-on-access</strong>：subobject 在首次被访问时才分配，减少内存浪费。</li>
<li><strong>Index array 透明化</strong>：对软件不可见，由硬件自动管理。</li>
<li><strong>压缩粒度细化</strong>：每个 subobject 可独立压缩，提升灵活性和效率。</li>
<li><strong>指针更新机制</strong>：Index array 中的指针随 subobject 分配/移动而更新，确保正确寻址。</li>
</ul>
</li>
<li>
<p>性能与开销权衡：</p>
<table>
<thead>
<tr>
<th>优势</th>
<th>开销</th>
</tr>
</thead>
<tbody>
<tr>
<td>避免大对象全量解压，降低访问延迟</td>
<td>增加少量元数据（Index array）占用空间</td>
</tr>
<tr>
<td>提升压缩率，因小块更易压缩</td>
<td>需额外一次指针查找（通过 Index array）</td>
</tr>
<tr>
<td>支持稀疏访问模式，节省带宽</td>
<td>对连续访问场景可能引入轻微间接寻址开销</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>该机制特别适用于 <strong>Java、C/C++</strong> 等语言中常见的大型数组或结构体，尤其在访问局部性较强的应用中表现优异。</p>
</li>
</ul>
<h3 id="figure-13-example-coco-compressed-object">Figure 13. Example COCO-compressed object.<a class="headerlink" href="#figure-13-example-coco-compressed-object" title="Permanent link">&para;</a></h3>
<p><img alt="7199ca0abce3881253e530119b292aa1db859ae978561cd45146200105760527.jpg" src="../images/7199ca0abce3881253e530119b292aa1db859ae978561cd45146200105760527.jpg" /></p>
<ul>
<li>图片展示了 <strong>COCO (Cross-Object COmpression)</strong> 算法的一个压缩实例，对比了原始对象、基对象与压缩后对象的内存布局。</li>
<li>原始对象大小为 <strong>32B</strong>，包含四个字段：<code>4527</code>（无差异）、<code>0</code>（无差异）、<code>0xaabb</code>（2字节差异）、<code>0x0000ffffaabbbaabb</code>（4字节差异）。</li>
<li>基对象同样为 <strong>32B</strong>，其内容与原始对象前两个字段一致，后两个字段不同，用于差分压缩。</li>
<li>压缩对象仅占用 <strong>16B</strong>，由三部分组成：<ul>
<li><strong>Base id (4B)</strong>：标识所引用的基对象，此处为 <code>4527</code>。</li>
<li><strong>Bitmap (4B)</strong>：按字节标记差异位，共32位（对应32字节），其中第18–19位和第24–27位为1，表示对应位置存在差异。</li>
<li><strong>Delta bytes (8B)</strong>：仅存储实际差异数据，即 <code>0xccdd</code> 和 <code>0xccddccdd</code>，其余空间标记为 <strong>Unused</strong>。</li>
</ul>
</li>
<li>压缩过程通过比较原始对象与基对象，仅保留差异部分，从而实现空间节省。</li>
<li>压缩比计算如下：</li>
</ul>
<table>
<thead>
<tr>
<th>对象类型</th>
<th>大小 (B)</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>原始对象</td>
<td>32</td>
<td>未压缩</td>
</tr>
<tr>
<td>基对象</td>
<td>32</td>
<td>作为参照</td>
</tr>
<tr>
<td>压缩对象</td>
<td>16</td>
<td>包含ID、Bitmap、Delta</td>
</tr>
<tr>
<td><strong>压缩率</strong></td>
<td><strong>2×</strong></td>
<td>32B → 16B</td>
</tr>
</tbody>
</table>
<ul>
<li>该图直观体现了 <strong>COCO 的核心思想</strong>：利用对象间相似性，通过差分编码减少冗余存储。</li>
</ul>
<h3 id="figure-14-cdf-of-accesses-to-most-popular-object-ids">Figure 14. CDF of accesses to most popular object ids.<a class="headerlink" href="#figure-14-cdf-of-accesses-to-most-popular-object-ids" title="Permanent link">&para;</a></h3>
<p><img alt="460c193def15b6ede128f7e8f92b1c562eae99929a12f560eb7e289076f8e98e.jpg" src="../images/460c193def15b6ede128f7e8f92b1c562eae99929a12f560eb7e289076f8e98e.jpg" /></p>
<ul>
<li>图片展示了四个 Java 应用程序（btree、specjbb、h2、guavacache）对最流行对象类型 ID 的访问累积分布函数（CDF），横轴为“Top K popular type id”，纵轴为“CDF of total accesses”。</li>
<li><strong>核心观察</strong>：所有应用的访问都高度集中在少数对象类型上，即对象类型访问具有显著的<strong>长尾效应</strong>和<strong>高度倾斜性</strong>。</li>
<li>从图中曲线可见：<ul>
<li><strong>btree</strong>（蓝色实线）：访问集中度最高，前 5 个类型 ID 占据了约 80% 的总访问量；前 10 个类型 ID 覆盖超过 90%。</li>
<li><strong>specjbb</strong>（橙色虚线）：次高集中度，前 10 个类型 ID 约占 75%，前 20 个覆盖约 90%。</li>
<li><strong>h2</strong>（绿色点线）：集中度中等，前 10 个类型 ID 约占 65%，前 30 个覆盖约 90%。</li>
<li><strong>guavacache</strong>（红色点划线）：集中度最低，但前 20 个类型 ID 仍覆盖约 80%，前 40 个接近 95%。</li>
</ul>
</li>
<li>此数据支撑了论文第 5.4 节关于 COCO 压缩算法设计的关键假设：由于访问高度集中于少量对象类型，一个<strong>小型的 base object cache</strong>（如 8KB）即可高效缓存最频繁访问的 base objects，从而避免每次解压时都去主存取 base object，大幅降低延迟和带宽开销。</li>
<li>下表总结各应用在不同 Top-K 类型 ID 下的访问覆盖率：</li>
</ul>
<table>
<thead>
<tr>
<th>应用名</th>
<th>Top 5 访问覆盖率</th>
<th>Top 10 访问覆盖率</th>
<th>Top 20 访问覆盖率</th>
</tr>
</thead>
<tbody>
<tr>
<td>btree</td>
<td>~80%</td>
<td>&gt;90%</td>
<td>&gt;95%</td>
</tr>
<tr>
<td>specjbb</td>
<td>~65%</td>
<td>~75%</td>
<td>~90%</td>
</tr>
<tr>
<td>h2</td>
<td>~55%</td>
<td>~65%</td>
<td>~85%</td>
</tr>
<tr>
<td>guavacache</td>
<td>~45%</td>
<td>~65%</td>
<td>~80%</td>
</tr>
</tbody>
</table>
<ul>
<li>该图是论证 COCO 算法实用性和低开销的重要依据，表明其依赖的“base object 缓存”机制在真实工作负载下是可行且高效的。</li>
</ul>
<h3 id="table-3-zippadscoco-in-pointer-compression-information-x-denotes-the-bit-does-not-matter-and-cs-denote-the-bits-used-by-hybrid-bdifpc-encoding">Table 3. Zippads+COCO in-pointer compression information. X denotes the bit does not matter, and Cs denote the bits used by hybrid BDI+FPC encoding.<a class="headerlink" href="#table-3-zippadscoco-in-pointer-compression-information-x-denotes-the-bit-does-not-matter-and-cs-denote-the-bits-used-by-hybrid-bdifpc-encoding" title="Permanent link">&para;</a></h3>
<p><img alt="e85db4e1872fcf433a8daf220cfae789a724f8d1a9ab24d9c60335790b4e8466.jpg" src="../images/e85db4e1872fcf433a8daf220cfae789a724f8d1a9ab24d9c60335790b4e8466.jpg" /></p>
<ul>
<li>图片内容为 <strong>Table 3</strong>，标题为 “Zippads+COCO in-pointer compression information”，用于说明 Zippads 系统中指针内嵌的压缩元数据编码格式。</li>
<li>表格包含四列，分别对应四种数据类型：<strong>Uncomp. Object</strong>（未压缩对象）、<strong>Uncomp. Array</strong>（未压缩数组）、<strong>Comp. Object</strong>（压缩对象）、<strong>Comp. Array</strong>（压缩数组）。</li>
<li>每列下方标注了对应的 <strong>4位二进制编码</strong>，用于在指针中标识数据类型及压缩算法：<ul>
<li><strong>Uncomp. Object</strong>: <code>000X</code> —— 前三位为 000，第四位 X 表示“无关位”，用于标识未压缩对象。</li>
<li><strong>Uncomp. Array</strong>: <code>001X</code> —— 前三位为 001，第四位 X 无关，用于标识未压缩数组。</li>
<li><strong>Comp. Object</strong>: <code>01XX</code> —— 前两位为 01，后两位 XX 无关，用于标识使用 COCO 压缩的对象。</li>
<li><strong>Comp. Array</strong>: <code>1CCC</code> —— 第一位为 1，后三位 CCC 用于表示 <strong>hybrid BDI+FPC</strong> 压缩算法的具体编码选择。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>编码格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>Uncomp. Object</td>
<td>000X</td>
</tr>
<tr>
<td>Uncomp. Array</td>
<td>001X</td>
</tr>
<tr>
<td>Comp. Object</td>
<td>01XX</td>
</tr>
<tr>
<td>Comp. Array</td>
<td>1CCC</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>X</strong> 表示该位在当前上下文中“不重要”或“可忽略”，不影响类型判断。</li>
<li><strong>C</strong> 表示该位用于 <strong>BDI+FPC</strong> 压缩算法的选择，具体含义由压缩器解释。</li>
<li>此编码机制使 Zippads 能在访问时快速识别数据类型和压缩方案，无需额外查表，提升效率。</li>
<li>该设计支持 <strong>混合压缩策略</strong>：对象用 COCO，数组用 BDI+FPC，兼顾不同数据结构的压缩特性。</li>
<li>指针内嵌元数据是 Zippads 的核心优化之一，避免了传统压缩系统所需的地址翻译开销。</li>
</ul>
<h3 id="69e038bd5e3a77df4a6870a2333324b17d3853b29e842bef69f2adaca79c719djpg">69e038bd5e3a77df4a6870a2333324b17d3853b29e842bef69f2adaca79c719d.jpg<a class="headerlink" href="#69e038bd5e3a77df4a6870a2333324b17d3853b29e842bef69f2adaca79c719djpg" title="Permanent link">&para;</a></h3>
<p><img alt="69e038bd5e3a77df4a6870a2333324b17d3853b29e842bef69f2adaca79c719d.jpg" src="../images/69e038bd5e3a77df4a6870a2333324b17d3853b29e842bef69f2adaca79c719d.jpg" /></p>
<ul>
<li>该图片展示的是 <strong>Zippads+COCO</strong> 系统中用于区分数组与对象的新增指令 <code>alloc_array</code> 的格式与操作说明。</li>
<li>指令名称为 <strong><code>alloc_array</code></strong>，其功能是分配数组空间，并在生成的指针中设置“数组位”（array bit），以供后续压缩算法识别数据类型。</li>
<li>该指令的操作数格式为 <code>alloc_array rp, rs1, rs2</code>，其中：<ul>
<li><code>rp</code> 是目标寄存器，用于存放新分配的数组指针；</li>
<li><code>rs1</code> 存放数组大小（size）；</li>
<li><code>rs2</code> 存放类型标识符（type id）。</li>
</ul>
</li>
<li>操作描述指出，<code>alloc_array</code> 的行为与原有 <code>alloc</code> 指令相同，但会额外在指针 <code>rp</code> 中设置“数组位”，从而让系统知道该指针指向的是数组而非普通对象。</li>
<li>此设计允许 <strong>Zippads</strong> 在运行时根据数据类型选择不同的压缩算法：对数组使用 <strong>BDI+FPC</strong>，对对象则使用 <strong>COCO</strong>。</li>
<li>通过扩展 ISA 实现类型感知分配，是 Zippads 能够实现混合压缩策略的关键机制之一。</li>
</ul>
<table>
<thead>
<tr>
<th>字段</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>Instruction</td>
<td><code>alloc_array</code></td>
</tr>
<tr>
<td>Format</td>
<td><code>alloc_array rp, rs1, rs2</code></td>
</tr>
<tr>
<td>rs1</td>
<td>size (数组大小)</td>
</tr>
<tr>
<td>rs2</td>
<td>type id (类型标识符)</td>
</tr>
<tr>
<td>Operation</td>
<td>同 <code>alloc</code>，但在 <code>rp</code> 中设置 array bit</td>
</tr>
</tbody>
</table>
<h3 id="f5b47feac26970f380675b9a3c900c0dc268bd149622922ce0588016b6967ff7jpg">f5b47feac26970f380675b9a3c900c0dc268bd149622922ce0588016b6967ff7.jpg<a class="headerlink" href="#f5b47feac26970f380675b9a3c900c0dc268bd149622922ce0588016b6967ff7jpg" title="Permanent link">&para;</a></h3>
<p><img alt="f5b47feac26970f380675b9a3c900c0dc268bd149622922ce0588016b6967ff7.jpg" src="../images/f5b47feac26970f380675b9a3c900c0dc268bd149622922ce0588016b6967ff7.jpg" /></p>
<ul>
<li>该图片为一张配置对比表，详细列出了四种不同内存层次结构（Uncompressed、CMH、Hotpads、Zippads）在核心、缓存、算法及内存层面的硬件与软件参数。</li>
<li>表格结构清晰，横向分为四列，分别对应四种系统配置；纵向按组件分类，包括 Core、Caches、Algo、LLC、Mem 等模块。</li>
<li><strong>Core</strong> 配置统一：所有方案均基于 x86-64 ISA，3.6 GHz 主频，Westmere-like OOO 架构，具备 16B 宽取指、2级分支预测器、4路发射、128项 ROB 等特性。</li>
<li><strong>Caches</strong> 层面：<ul>
<li>L1：64 KB，8路组相联，64B 行大小。</li>
<li>L2：512 KB 私有每核，8路组相联。</li>
<li>LLC：4 banks × 2 MB/bank，16路组相联，LRU 替换策略。</li>
<li>Mem：2通道 DDR3-1600。</li>
</ul>
</li>
<li><strong>CMH</strong>（Compressed Memory Hierarchy）采用 HyComp 风格混合压缩算法（BDI + FPC），其中 BDI 延迟为 1 cycle，FPC 为 5 cycle；LLC 使用 VSC 设计（2× tag array）和 CAMP 替换策略；主存使用 LCP 方案并假设完美元数据缓存（32KB）。</li>
<li><strong>Hotpads</strong> 为对象化内存架构：<ul>
<li>L1D：64 KB 数据阵列 + 1K ctag 条目。</li>
<li>L1I：64 KB 缓存，8路组相联，64B 行。</li>
<li>L2：512 KB 数据阵列 + 8K ctag 条目。</li>
<li>LLP：4×2 MB 数据阵列 + 4×32K ctag 条目。</li>
</ul>
</li>
<li><strong>Zippads</strong> 在 Hotpads 基础上引入压缩：<ul>
<li>L3：4×64K ctag 条目 + 8 KB base object cache。</li>
<li>压缩算法：COCO（1-cycle 延迟）用于对象，混合 BDI+FPC 用于数组。</li>
</ul>
</li>
<li>关键术语保留英文原名，如 <strong>VSC</strong>、<strong>CAMP</strong>、<strong>LCP</strong>、<strong>BDI</strong>、<strong>FPC</strong>、<strong>COCO</strong> 等，符合学术规范。</li>
<li>所有配置均基于同一模拟平台 MaxSim，确保评估公平性。</li>
<li>Zippads 的设计重点在于<strong>对象粒度压缩</strong>与<strong>跨对象冗余利用</strong>，通过 COCO 算法实现高压缩比，同时保持低延迟。</li>
<li>表格未包含性能数据，仅提供配置参数，用于后续仿真分析的基础设定。</li>
</ul>
<h3 id="table-6-workloads-and-inputs-used">Table 6. Workloads and inputs used.<a class="headerlink" href="#table-6-workloads-and-inputs-used" title="Permanent link">&para;</a></h3>
<p><img alt="9df3abb93a808e892e2a49644f076f0bbe270ad32ba55b50accf95d9ab61f128.jpg" src="../images/9df3abb93a808e892e2a49644f076f0bbe270ad32ba55b50accf95d9ab61f128.jpg" /></p>
<ul>
<li>该图片为论文中的 <strong>Table 6</strong>，标题为 “Workloads and inputs used”，用于列出实验中所使用的基准测试程序及其输入参数。</li>
<li>表格分为两部分：<strong>Java Benchmark</strong> 和 <strong>C Benchmark</strong>，分别对应不同语言的测试程序。</li>
<li>所有基准测试均针对内存密集型应用，堆大小均超过100MB，以充分测试主存行为。</li>
</ul>
<p>以下是具体工作负载与输入配置：</p>
<table>
<thead>
<tr>
<th>Java Benchmark</th>
<th>Input</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>fft</strong></td>
<td>2²¹ points</td>
</tr>
<tr>
<td><strong>spmv</strong></td>
<td>m = 1M, nonzero = 64M</td>
</tr>
<tr>
<td><strong>h2</strong></td>
<td>default input: 4K transactions</td>
</tr>
<tr>
<td><strong>specjbb</strong></td>
<td>1 warehouse per thread, 50K transactions</td>
</tr>
<tr>
<td><strong>pagerank</strong></td>
<td>amazon-2008 graph</td>
</tr>
<tr>
<td><strong>coloring</strong></td>
<td>amazon-2008 graph</td>
</tr>
<tr>
<td><strong>btree</strong></td>
<td>ycsb-c, 2M key-value pairs, 4M queries</td>
</tr>
<tr>
<td><strong>guavacache</strong></td>
<td>ycsb-c, 4M key-value pairs, 4M queries</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>C Benchmark</th>
<th>Input</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>gcbench</strong></td>
<td>16M nodes, each node is 32B large</td>
</tr>
<tr>
<td><strong>silo</strong></td>
<td>tpcc, 1 warehouse, 8K transactions</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Java 工作负载</strong>涵盖科学计算（fft、spmv）、数据库（h2、specjbb）、图处理（pagerank、coloring）和键值存储（btree、guavacache），覆盖多个领域。</li>
<li><strong>C 工作负载</strong>包括内存分配密集型的二叉树操作（gcbench）和事务型数据库（silo），用于验证 Zippads 在非托管语言中的有效性。</li>
<li>输入规模经过调整，确保能有效触发主存访问，避免因数据集过小导致压缩效果被掩盖。例如，<strong>gcbench</strong> 的节点数扩展至 16M，以产生 512MB 活跃内存足迹。</li>
<li><strong>silo</strong> 使用 TPC-C 基准，配置为单仓库、8K 事务，模拟真实 OLTP 场景。</li>
<li>所有输入均标准化，便于跨架构比较性能与压缩比，符合论文中“运行至完成”和“避免采样偏差”的评估方法。</li>
</ul>
<h3 id="figure-15-compression-ratio-of-different-schemes">Figure 15. Compression ratio of different schemes.<a class="headerlink" href="#figure-15-compression-ratio-of-different-schemes" title="Permanent link">&para;</a></h3>
<p><img alt="0691da417af58c59a7ff60d94501d98bc2f038438e8c0af57df668642dc731c6.jpg" src="../images/0691da417af58c59a7ff60d94501d98bc2f038438e8c0af57df668642dc731c6.jpg" /></p>
<ul>
<li>图表展示了八种不同工作负载（fft, spmv, h2, specjbb, pagerank, coloring, btree, guavacache）在五种内存层次结构下的<strong>压缩比</strong>对比，横轴为工作负载，纵轴为压缩比数值。</li>
<li>五种方案分别为：Uncomp.（未压缩基线）、CMH（压缩内存层次结构）、Hotpads（对象型内存层次）、Zippads-BF（使用BDI+FPC的Zippads变体）、Zippads（结合COCO算法的完整版）。</li>
<li><strong>Zippads 在所有工作负载中均取得最高压缩比</strong>，尤其在对象密集型应用（如guavacache、btree）中优势显著，其压缩比可达2.0以上。</li>
<li>对于数组主导型工作负载（如fft、spmv），CMH与Zippads表现接近，但Zippads仍略优，因它能更高效压缩非堆数据（如代码和JVM状态）。</li>
<li>Zippads-BF在对象型工作负载中表现优于CMH，证明<strong>对象级压缩布局本身即可提升压缩效率</strong>，无需依赖COCO算法。</li>
<li>在guavacache上，Zippads压缩比达<strong>2.24×</strong>，远超CMH的1.12×，体现跨对象冗余利用的巨大潜力。</li>
<li>下表总结各工作负载下Zippads相对CMH的压缩比提升倍数：</li>
</ul>
<table>
<thead>
<tr>
<th>工作负载</th>
<th>Zippads 压缩比</th>
<th>CMH 压缩比</th>
<th>Zippads / CMH</th>
</tr>
</thead>
<tbody>
<tr>
<td>fft</td>
<td>1.97</td>
<td>1.67</td>
<td>1.18×</td>
</tr>
<tr>
<td>spmv</td>
<td>1.79</td>
<td>1.53</td>
<td>1.17×</td>
</tr>
<tr>
<td>h2</td>
<td>1.82</td>
<td>1.27</td>
<td>1.43×</td>
</tr>
<tr>
<td>specjbb</td>
<td>1.78</td>
<td>1.24</td>
<td>1.44×</td>
</tr>
<tr>
<td>pagerank</td>
<td>1.82</td>
<td>1.12</td>
<td>1.63×</td>
</tr>
<tr>
<td>coloring</td>
<td>1.82</td>
<td>1.12</td>
<td>1.63×</td>
</tr>
<tr>
<td>btree</td>
<td>1.95</td>
<td>1.10</td>
<td>1.77×</td>
</tr>
<tr>
<td>guavacache</td>
<td>2.24</td>
<td>1.12</td>
<td><strong>2.00×</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>平均而言，Zippads压缩比达<strong>2.01×</strong>，较CMH的1.24×提升<strong>1.63×</strong>，验证了“压缩对象而非缓存行”的核心设计思想的有效性。</li>
</ul>
<h3 id="figure-16-normalized-main-memory-traffic-of-different-schemes">Figure 16. Normalized main memory traffic of different schemes.<a class="headerlink" href="#figure-16-normalized-main-memory-traffic-of-different-schemes" title="Permanent link">&para;</a></h3>
<p><img alt="e0dca03cf347fa65f5a0e5e211bedfd4667ffad2023570fff2890e0162972155.jpg" src="../images/e0dca03cf347fa65f5a0e5e211bedfd4667ffad2023570fff2890e0162972155.jpg" /></p>
<ul>
<li>
<p>图片展示了不同内存系统方案在多个工作负载下的<strong>归一化主存流量</strong>（Normalized Main Memory Traffic），基准为未压缩系统（Uncomp.）。</p>
</li>
<li>
<p>横轴为八个 Java 工作负载：fft、spmv、h2、specjbb、pagerank、coloring、btree、guavacache，以及一个平均值（gmean）。</p>
</li>
<li>
<p>纵轴表示主存流量（单位：B），数值越低代表流量越少，性能越好。</p>
</li>
<li>
<p>图例包含六种方案：</p>
<ul>
<li><strong>Uncomp.</strong>：未压缩基线</li>
<li><strong>Scrub.</strong>：启用缓存擦除的未压缩系统</li>
<li><strong>Hotpads</strong>：基于对象的未压缩内存层次结构</li>
<li><strong>CMH</strong>：状态先进的压缩内存层次结构（LLC + 主存压缩）</li>
<li><strong>CMH+S</strong>：CMH + 缓存擦除</li>
<li><strong>Zippads</strong>：本文提出的对象级压缩层次结构</li>
</ul>
</li>
<li>
<p>各方案在不同工作负载下的表现如下表所示：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Workload</th>
<th>Uncomp.</th>
<th>Scrub.</th>
<th>Hotpads</th>
<th>CMH</th>
<th>CMH+S</th>
<th>Zippads</th>
</tr>
</thead>
<tbody>
<tr>
<td>fft</td>
<td>1.0</td>
<td>~0.95</td>
<td>~0.9</td>
<td>~0.85</td>
<td>~0.8</td>
<td>~0.75</td>
</tr>
<tr>
<td>spmv</td>
<td>1.0</td>
<td>~0.95</td>
<td>~0.9</td>
<td>~0.75</td>
<td>~0.7</td>
<td>~0.65</td>
</tr>
<tr>
<td>h2</td>
<td>1.0</td>
<td>~0.4</td>
<td>~0.3</td>
<td>~0.6</td>
<td>~0.45</td>
<td>~0.35</td>
</tr>
<tr>
<td>specjbb</td>
<td>1.0</td>
<td>~0.4</td>
<td>~0.3</td>
<td>~0.7</td>
<td>~0.5</td>
<td>~0.4</td>
</tr>
<tr>
<td>pagerank</td>
<td>1.0</td>
<td>~0.95</td>
<td>~0.8</td>
<td>~0.7</td>
<td>~0.65</td>
<td>~0.6</td>
</tr>
<tr>
<td>coloring</td>
<td>1.0</td>
<td>~0.95</td>
<td>~0.8</td>
<td>~0.7</td>
<td>~0.65</td>
<td>~0.6</td>
</tr>
<tr>
<td>btree</td>
<td>1.0</td>
<td>~0.95</td>
<td>~0.8</td>
<td>~0.7</td>
<td>~0.65</td>
<td>~0.55</td>
</tr>
<tr>
<td>guavacache</td>
<td>1.0</td>
<td>~0.95</td>
<td>~0.3</td>
<td>~0.9</td>
<td>~0.8</td>
<td>~0.4</td>
</tr>
<tr>
<td><strong>gmean</strong></td>
<td>1.0</td>
<td><strong>0.85</strong></td>
<td><strong>0.5</strong></td>
<td><strong>0.7</strong></td>
<td><strong>0.6</strong></td>
<td><strong>0.5</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><strong>关键观察</strong>：</p>
<ul>
<li><strong>Zippads 在所有工作负载中均显著降低主存流量</strong>，尤其在对象密集型应用如 h2、specjbb 和 guavacache 中表现突出。</li>
<li><strong>Hotpads 本身已大幅减少流量</strong>（平均降至 0.5×），因其对象粒度管理与硬件垃圾回收机制。</li>
<li><strong>Zippads 在 Hotpads 基础上进一步压缩</strong>，平均流量比 Hotpads 降低 22%，比 CMH+S 降低 56%。</li>
<li><strong>CMH 对数组密集型应用（如 spmv）有效</strong>，但对对象密集型应用（如 guavacache）效果有限。</li>
<li><strong>Scrubbing 对数据库类负载（h2, specjbb）帮助最大</strong>，但对科学计算类负载（fft, spmv）影响甚微。</li>
</ul>
</li>
<li>
<p><strong>结论</strong>：</p>
<ul>
<li><strong>Zippads 实现了最高的主存流量削减</strong>，验证了“按对象而非缓存行压缩”的有效性。</li>
<li><strong>对象级压缩 + 对象感知内存管理</strong> 是提升现代面向对象程序性能的关键路径。</li>
</ul>
</li>
</ul>
<h3 id="figure-17-performance-of-different-schemes">Figure 17. Performance of different schemes.<a class="headerlink" href="#figure-17-performance-of-different-schemes" title="Permanent link">&para;</a></h3>
<p><img alt="e95fd49ce8a52f9b09d49fd1e689bd8a0f64202ce0c032f7e9d8c791bd9f2f82.jpg" src="../images/e95fd49ce8a52f9b09d49fd1e689bd8a0f64202ce0c032f7e9d8c791bd9f2f82.jpg" /></p>
<ul>
<li>图片展示了不同内存层次结构方案在多个工作负载下的性能表现，以<strong>Speedup</strong>（加速比）为纵坐标，横坐标为不同的基准测试程序。</li>
<li>图例中包含六种方案：<strong>Uncomp.</strong>（未压缩）、<strong>Scrub.</strong>（带缓存清理的未压缩）、<strong>Hotpads</strong>、<strong>CMH</strong>（压缩内存层次结构）、<strong>CMH+S</strong>（带缓存清理的压缩内存层次结构）、<strong>Zippads</strong>。</li>
<li><strong>Zippads</strong> 在绝大多数工作负载中表现出最高的加速比，尤其在 <strong>guavacache</strong> 和 <strong>gmean</strong>（几何平均值）上分别达到 <strong>1.8x</strong> 和 <strong>1.9x</strong> 的加速。</li>
<li><strong>Hotpads</strong> 作为 Zippads 的基础架构，在对象密集型应用（如 h2、specjbb、btree、guavacache）中显著优于传统压缩方案。</li>
<li><strong>CMH</strong> 在数组密集型应用（如 fft、spmv）中表现较好，但在对象密集型应用中提升有限。</li>
<li><strong>Scrub.</strong> 和 <strong>CMH+S</strong> 主要在数据库类工作负载（如 h2、specjbb）中带来额外性能增益，表明缓存清理机制对分配密集型应用有效。</li>
<li>下表总结了各方案在关键工作负载上的加速比：</li>
</ul>
<table>
<thead>
<tr>
<th>工作负载</th>
<th>Uncomp.</th>
<th>Scrub.</th>
<th>Hotpads</th>
<th>CMH</th>
<th>CMH+S</th>
<th>Zippads</th>
</tr>
</thead>
<tbody>
<tr>
<td>fft</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.12</td>
<td>1.12</td>
<td>1.15</td>
</tr>
<tr>
<td>spmv</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.12</td>
<td>1.12</td>
<td>1.15</td>
</tr>
<tr>
<td>h2</td>
<td>1.0</td>
<td>1.1</td>
<td>1.3</td>
<td>1.1</td>
<td>1.2</td>
<td>1.4</td>
</tr>
<tr>
<td>specjbb</td>
<td>1.0</td>
<td>1.1</td>
<td>1.3</td>
<td>1.1</td>
<td>1.2</td>
<td>1.4</td>
</tr>
<tr>
<td>pagerank</td>
<td>1.0</td>
<td>1.0</td>
<td>1.2</td>
<td>1.1</td>
<td>1.1</td>
<td>1.3</td>
</tr>
<tr>
<td>coloring</td>
<td>1.0</td>
<td>1.0</td>
<td>1.2</td>
<td>1.1</td>
<td>1.1</td>
<td>1.3</td>
</tr>
<tr>
<td>btree</td>
<td>1.0</td>
<td>1.0</td>
<td>1.3</td>
<td>1.1</td>
<td>1.2</td>
<td>1.4</td>
</tr>
<tr>
<td>guavacache</td>
<td>1.0</td>
<td>1.0</td>
<td>1.4</td>
<td>1.1</td>
<td>1.1</td>
<td><strong>1.8</strong></td>
</tr>
<tr>
<td>gmean</td>
<td>1.0</td>
<td>1.06</td>
<td>1.24</td>
<td>1.05</td>
<td>1.11</td>
<td><strong>1.9</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>总体来看，<strong>Zippads</strong> 通过对象级压缩和跨对象冗余利用，在保持低开销的同时实现了最高性能提升，验证了其设计的有效性。</li>
</ul>
<h3 id="figure-18-results-for-cc-benchmarks">Figure 18. Results for C/C++ benchmarks.<a class="headerlink" href="#figure-18-results-for-cc-benchmarks" title="Permanent link">&para;</a></h3>
<p><img alt="e337fefad063deec410427d2de9303b4a42f113609b64b8098dfc58f843f3586.jpg" src="../images/e337fefad063deec410427d2de9303b4a42f113609b64b8098dfc58f843f3586.jpg" /></p>
<ul>
<li>
<p>图片展示了在两个 C/C++ 基准测试（<strong>gcbench</strong> 和 <strong>silo</strong>）上，五种内存系统方案的性能对比：<strong>Uncomp.</strong>（未压缩）、<strong>CMH</strong>（压缩内存层次结构）、<strong>Hotpads</strong>、<strong>Zippads-BF</strong> 和 <strong>Zippads</strong>。</p>
</li>
<li>
<p>三个子图分别衡量了<strong>压缩比</strong>、<strong>内存流量</strong>和<strong>性能加速比</strong>，所有数据均以 Uncomp. 为基准进行归一化。</p>
</li>
<li>
<p><strong>压缩比分析</strong>：</p>
<ul>
<li>在 gcbench 上，<strong>CMH</strong> 压缩比接近 1.0，几乎无压缩效果；<strong>Hotpads</strong> 略高于 1.0；<strong>Zippads-BF</strong> 达到 1.61；<strong>Zippads</strong> 最高，达 <strong>2.01</strong>。</li>
<li>在 silo 上，<strong>CMH</strong> 压缩比仍接近 1.0；<strong>Hotpads</strong> 约 1.1；<strong>Zippads-BF</strong> 为 1.23；<strong>Zippads</strong> 提升至 <strong>1.70</strong>。</li>
<li>表明 Zippads 在对象密集型 C/C++ 程序中显著优于传统压缩方案。</li>
</ul>
</li>
<li>
<p><strong>内存流量分析</strong>：</p>
<ul>
<li>gcbench 中，<strong>CMH</strong> 将内存流量降至约 0.53（即减少 47%），源于对零初始化页面的良好压缩；<strong>Hotpads</strong> 降至 0.43；<strong>Zippads-BF</strong> 降至 0.15；<strong>Zippads</strong> 降至 <strong>0.05</strong>（即减少 95%）。</li>
<li>silo 中，<strong>CMH</strong> 流量降至 0.8；<strong>Hotpads</strong> 降至 0.6；<strong>Zippads-BF</strong> 降至 0.3；<strong>Zippads</strong> 降至 <strong>0.2</strong>。</li>
<li>显示 Zippads 不仅压缩数据，还大幅降低主存带宽压力。</li>
</ul>
</li>
<li>
<p><strong>性能加速比分析</strong>：</p>
<ul>
<li>gcbench 中，<strong>CMH</strong> 加速 1.2x；<strong>Hotpads</strong> 和 <strong>Zippads</strong> 均达 <strong>2.7x</strong>；<strong>Zippads-BF</strong> 也接近 2.7x。</li>
<li>silo 中，<strong>CMH</strong> 仅加速 1.04x；<strong>Hotpads</strong> 为 1.06x；<strong>Zippads-BF</strong> 为 1.06x；<strong>Zippads</strong> 为 <strong>1.10x</strong>。</li>
<li>性能提升主要来自 Hotpads 的对象管理机制，Zippads 在此基础上叠加压缩优势。</li>
</ul>
</li>
<li>
<p>数据汇总如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Benchmark</th>
<th>Scheme</th>
<th>Compression Ratio</th>
<th>Memory Traffic (norm.)</th>
<th>Speedup</th>
</tr>
</thead>
<tbody>
<tr>
<td>gcbench</td>
<td>Uncomp.</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td></td>
<td>CMH</td>
<td>~1.0</td>
<td>0.53</td>
<td>1.2x</td>
</tr>
<tr>
<td></td>
<td>Hotpads</td>
<td>~1.1</td>
<td>0.43</td>
<td>2.7x</td>
</tr>
<tr>
<td></td>
<td>Zippads-BF</td>
<td>1.61</td>
<td>0.15</td>
<td>2.7x</td>
</tr>
<tr>
<td></td>
<td>Zippads</td>
<td><strong>2.01</strong></td>
<td><strong>0.05</strong></td>
<td><strong>2.7x</strong></td>
</tr>
<tr>
<td>silo</td>
<td>Uncomp.</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td></td>
<td>CMH</td>
<td>~1.0</td>
<td>0.8</td>
<td>1.04x</td>
</tr>
<tr>
<td></td>
<td>Hotpads</td>
<td>~1.1</td>
<td>0.6</td>
<td>1.06x</td>
</tr>
<tr>
<td></td>
<td>Zippads-BF</td>
<td>1.23</td>
<td>0.3</td>
<td>1.06x</td>
</tr>
<tr>
<td></td>
<td>Zippads</td>
<td><strong>1.70</strong></td>
<td><strong>0.2</strong></td>
<td><strong>1.10x</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>结论：<strong>Zippads</strong> 在 C/C++ 对象密集型程序中展现出与 Java 类似的优势——通过对象级压缩和 COCO 算法，实现<strong>高压缩比</strong>、<strong>低内存流量</strong>和<strong>显著性能提升</strong>，验证其跨语言适用性。</li>
</ul>
<h3 id="figure-19-rate-of-base-object-cache-misses-in-misses-per-kcycle-log-scale">Figure 19. Rate of base object cache misses (in misses per Kcycle, log scale).<a class="headerlink" href="#figure-19-rate-of-base-object-cache-misses-in-misses-per-kcycle-log-scale" title="Permanent link">&para;</a></h3>
<p><img alt="2fcddf14c63f7fd268b028d3f8421248db29cd78a53de527f3ebe60d5aa722d4.jpg" src="../images/2fcddf14c63f7fd268b028d3f8421248db29cd78a53de527f3ebe60d5aa722d4.jpg" /></p>
<ul>
<li>图表标题为 <strong>Figure 19</strong>，展示的是 <strong>COCO base object cache misses rate</strong>，单位为 <strong>misses per Kcycle</strong>，采用对数坐标轴。</li>
<li>横轴列出八个 Java 工作负载：<strong>fft, spmv, h2, specjbb, pagerank, coloring, btree, guavacache</strong>。</li>
<li>纵轴为对数刻度，范围从 <strong>10⁻⁶ 到 10⁰</strong>，用于清晰呈现不同工作负载间 miss rate 的巨大差异。</li>
<li>图中包含两组柱状图，分别代表 <strong>8KB</strong> 和 <strong>16KB</strong> 两种容量的 base object cache 的 miss rate。</li>
<li>大多数工作负载的 miss rate 极低，集中在 <strong>10⁻⁴ 到 10⁻⁶</strong> 区间，表明 <strong>base object cache 效果显著</strong>。</li>
<li><strong>h2</strong> 和 <strong>specjbb</strong> 两个数据库类工作负载 miss rate 较高，约为 <strong>10⁻²</strong>，但仍低于 0.01 MPKC（每千周期一次），对性能影响可忽略。</li>
<li><strong>guavacache</strong> 在 8KB cache 下 miss rate 略高，约 <strong>10⁻³</strong>，但 16KB cache 下明显改善。</li>
<li>所有工作负载在 16KB cache 下的 miss rate 均未显著优于 8KB，说明 <strong>8KB cache 已足够高效</strong>，增加容量收益有限。</li>
<li>结论：<strong>COCO 的 base object cache 设计合理，8KB 容量即可满足绝大多数场景需求，miss penalty 极小</strong>。</li>
</ul>
<table>
<thead>
<tr>
<th>Workload</th>
<th>8KB Miss Rate (MPKC)</th>
<th>16KB Miss Rate (MPKC)</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>fft</td>
<td>~10⁻⁵</td>
<td>~10⁻⁵</td>
<td>极低，几乎无 miss</td>
</tr>
<tr>
<td>spmv</td>
<td>~10⁻⁴</td>
<td>~10⁻⁴</td>
<td>科学计算，稳定</td>
</tr>
<tr>
<td>h2</td>
<td>~10⁻²</td>
<td>~10⁻²</td>
<td>数据库，miss 率最高之一</td>
</tr>
<tr>
<td>specjbb</td>
<td>~10⁻²</td>
<td>~10⁻²</td>
<td>数据库，与 h2 类似</td>
</tr>
<tr>
<td>pagerank</td>
<td>~10⁻⁵</td>
<td>~10⁻⁵</td>
<td>图处理，极低</td>
</tr>
<tr>
<td>coloring</td>
<td>~10⁻⁵</td>
<td>~10⁻⁵</td>
<td>图处理，极低</td>
</tr>
<tr>
<td>btree</td>
<td>~10⁻⁵</td>
<td>~10⁻⁵</td>
<td>示例应用，极低</td>
</tr>
<tr>
<td>guavacache</td>
<td>~10⁻³</td>
<td>~10⁻⁴</td>
<td>对 cache 容量敏感，16KB 改善明显</td>
</tr>
</tbody>
</table>
<ul>
<li>总体而言，<strong>COCO 的 base object cache miss rate 极低，对系统性能影响小于 0.1%</strong>，验证了其硬件实现的可行性与高效性。</li>
</ul>
<h3 id="figure-20-rate-of-dirty-writeback-overflows-in-overflows-per-kcycle-log-scale">Figure 20. Rate of dirty writeback overflows (in overflows per Kcycle, log scale).<a class="headerlink" href="#figure-20-rate-of-dirty-writeback-overflows-in-overflows-per-kcycle-log-scale" title="Permanent link">&para;</a></h3>
<p><img alt="3e5e6cc42ed9140ec5043b9e58fe7afdabeb2aee1e38c45922ae142a5738a289.jpg" src="../images/3e5e6cc42ed9140ec5043b9e58fe7afdabeb2aee1e38c45922ae142a5738a289.jpg" /></p>
<ul>
<li>图表标题为 <strong>Figure 20</strong>，展示的是 <strong>dirty writeback overflows</strong> 的发生频率，单位为 <strong>overflows per Kcycle</strong>，采用对数坐标（log scale）。</li>
<li>所有测试工作负载的 overflow 频率均极低，绝大多数低于 <strong>10⁻³ overflows/Kcycle</strong>，表明 Zippads 在处理脏写回时的溢出情况非常罕见。</li>
<li><strong>guavacache</strong> 是 overflow 发生最频繁的工作负载，约为 <strong>0.4 overflows/Kcycle</strong>，但仍属于低频事件，未构成系统瓶颈。</li>
<li>其余工作负载如 <strong>fft、spmv、h2、specjbb、pagerank、coloring、btree</strong> 均远低于 0.01 overflows/Kcycle，部分甚至接近 <strong>10⁻⁵</strong> 或更低。</li>
<li>数据表明 Zippads 的压缩对象布局与写回机制设计有效，<strong>overflow 仅在极端情况下发生</strong>，且可通过周期性 compaction 清理，不影响整体性能。</li>
</ul>
<table>
<thead>
<tr>
<th>工作负载</th>
<th>Overflow 频率 (per Kcycle)</th>
</tr>
</thead>
<tbody>
<tr>
<td>fft</td>
<td>~10⁻⁵</td>
</tr>
<tr>
<td>spmv</td>
<td>~10⁻²</td>
</tr>
<tr>
<td>h2</td>
<td>~10⁻³</td>
</tr>
<tr>
<td>specjbb</td>
<td>~10⁻²</td>
</tr>
<tr>
<td>pagerank</td>
<td>~10⁻⁴</td>
</tr>
<tr>
<td>coloring</td>
<td>~10⁻⁴</td>
</tr>
<tr>
<td>btree</td>
<td>~10⁻⁵</td>
</tr>
<tr>
<td>guavacache</td>
<td><strong>~0.4</strong></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>结论</strong>：Zippads 的 overflow 机制在实际运行中几乎不触发，硬件开销可忽略，验证了其在对象压缩场景下的稳定性与高效性。</li>
</ul>
<h3 id="2a28fa03d9819cd940cddd0a0ed9577c75d2fb870eb8427c48e4f03001c6c682jpg">2a28fa03d9819cd940cddd0a0ed9577c75d2fb870eb8427c48e4f03001c6c682.jpg<a class="headerlink" href="#2a28fa03d9819cd940cddd0a0ed9577c75d2fb870eb8427c48e4f03001c6c682jpg" title="Permanent link">&para;</a></h3>
<p><img alt="2a28fa03d9819cd940cddd0a0ed9577c75d2fb870eb8427c48e4f03001c6c682.jpg" src="../images/2a28fa03d9819cd940cddd0a0ed9577c75d2fb870eb8427c48e4f03001c6c682.jpg" /></p>
<ul>
<li>图片内容为一张表格，标题为“Table 7. On-chip storage (KB) per last-level cache/pad bank.”，用于对比不同内存架构方案在最后一级缓存或pad上的片上存储开销。</li>
<li>表格包含五列：<strong>Tag</strong>（标签存储）、<strong>Data</strong>（数据存储）、<strong>Extra</strong>（额外开销）、<strong>Total (KB)</strong>（总存储量，单位KB）和 <strong>Increased by (%)</strong>（相对于基线的增加百分比）。</li>
<li>数据行共四组，分别对应四种系统配置：<ul>
<li><strong>Baseline</strong>：传统未压缩三级缓存架构，无额外开销，总存储2208 KB，作为基准（0%增加）。</li>
<li><strong>Hotpads</strong>：基于对象的非压缩内存层次结构，因引入元数据和c-tag数组，总存储增至2352 KB，<strong>增加6.5%</strong>。</li>
<li><strong>CMH</strong>（Compressed Memory Hierarchy）：状态最先进压缩缓存+压缩主存架构，因双倍标签、编码位及32KB元数据缓存，总存储达2488 KB，<strong>增加12.7%</strong>。</li>
<li><strong>Zippads</strong>：本文提出的对象压缩架构，结合双倍c-tag与8KB基础对象缓存，总存储为2568 KB，<strong>较Hotpads增加9.2%，较CMH仅增加3.2%</strong>。</li>
</ul>
</li>
<li>关键结论：<ul>
<li>Zippads的硬件开销控制良好，<strong>仅比CMH多3.2%</strong>，远低于其带来的1.63×平均压缩率提升。</li>
<li>所有压缩方案的额外开销主要来自标签扩展（如双倍tag），若仅需压缩主存，可移除该部分以进一步降低开销。</li>
<li>表格数据支持论文主张：Zippads在实现高压缩效率的同时，维持了与现有压缩缓存相当的硬件成本。</li>
</ul>
</li>
</ul>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.sections", "navigation.top", "navigation.indexes", "search.suggest", "search.highlight", "content.code.copy"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../../../javascripts/switcher.js"></script>
      
        <script src="../../../javascripts/smart_back.js"></script>
      
    
  </body>
</html>