
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://example.com/notes_repo/ocolos-online-code-layout-optimizations/ELI5_notes/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>OCOLOS: Online COde Layout OptimizationS 通俗讲解 - BlaBlaCut</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#ocolos-online-code-layout-optimizations" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="BlaBlaCut" class="md-header__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            BlaBlaCut
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              OCOLOS: Online COde Layout OptimizationS 通俗讲解
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到深色模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换到深色模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到浅色模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换到浅色模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="BlaBlaCut" class="md-nav__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    BlaBlaCut
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/Recent/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Recent
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/awesome-data-prefetchers/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Awesome Data Prefetchers
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/micro-2025/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    MICRO 2025
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#0" class="md-nav__link">
    <span class="md-ellipsis">
      
        0. 整体创新点通俗解读
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1-online-code-layout-optimization-eli5" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. 在线代码布局优化 (Online Code Layout Optimization) (ELI5)
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-safe-online-code-replacement-eli5" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. 安全的在线代码替换机制 (Safe Online Code Replacement) (ELI5)
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-function-pointer-creation-interception-eli5" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. 函数指针创建拦截 (Function Pointer Creation Interception) (ELI5)
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-batch-accelerator-mode-bam-eli5" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. 批处理加速模式 (Batch Accelerator Mode, BAM) (ELI5)
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="ocolos-online-code-layout-optimizations">OCOLOS: Online COde Layout OptimizationS 通俗讲解<a class="headerlink" href="#ocolos-online-code-layout-optimizations" title="Permanent link">&para;</a></h1>
<h3 id="0">0. 整体创新点通俗解读<a class="headerlink" href="#0" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击 (The "Why")</strong></p>
<p>传统 Profile-Guided Optimization <strong>(PGO)</strong> 是个好东西，但它有个致命的“时间差”问题。想象一下：</p>
<ul>
<li>你花了一周时间，在旧版本的 MySQL 上跑了一个典型的负载，收集了<strong>profile</strong>。</li>
<li>然后你用这个 profile 去优化新版本的 MySQL。</li>
<li>但在这期间，代码已经变了！新功能、新补丁让旧 profile 的很多信息变得<strong>无法映射</strong>甚至<strong>完全错误</strong>。</li>
<li>结果就是，你精心优化的二进制文件，可能因为用了过时的 profile，性能反而不如不优化，或者错失了大量优化机会。</li>
</ul>
<p>这就像拿着去年的地图去开今年的车——路都修好了，你的地图还显示是泥巴路，导航自然不准。尤其是在<strong>数据中⼼</strong>这种代码<strong>高频迭代</strong>的环境里，这个问题尤为突出。更别提 PGO 还需要<strong>重新编译/链接</strong>整个应用，对于大型服务来说，部署成本极高。</p>
<p><strong>通俗比方 (The Analogy)</strong></p>
<p>OCOLOS 的思路，就像是给一辆正在高速行驶的汽车<strong>换引擎</strong>，而不是把车开回车库大修。</p>
<ul>
<li><strong>传统 PGO</strong>：相当于把车开回4S店（停机），拆掉旧引擎（旧二进制），根据上次开车的数据（旧 profile）设计一个新引擎（新二进制），再装回去。问题是，你这次开车的路况（输入）和上次完全不同，新引擎可能根本不适合。</li>
<li><strong>OCOLOS</strong>：它直接在车上装了一个“<strong>热插拔引擎舱</strong>”。它一边开着车（程序运行），一边偷偷记录当前的驾驶习惯（在线 profiling）。等新引擎（通过 BOLT 优化好的代码）造好后，它会找个安全时机（短暂暂停），把新引擎塞进引擎舱，并巧妙地把油管、电路（代码指针）都接到新引擎上，然后继续飞驰。这样，引擎永远是最适合当前路况的。</li>
</ul>
<p><strong>关键一招 (The "How")</strong></p>
<p>OCOLOS 的核心创新在于，它没有试图去“修改”正在运行的代码，而是采用了“<strong>保留+重定向</strong>”的策略，完美解决了在线代码替换中最棘手的<strong>代码指针失效</strong>问题。</p>
<ul>
<li><strong>保留旧代码 (C0)</strong>：OCOLOS <strong>永远不会</strong>覆盖或删除原始的代码段（C0）。这保证了任何指向 C0 的指针（无论是栈上的返回地址、vtable 里的函数指针，还是程序员自己存的函数指针）都依然有效，程序不会崩溃。</li>
<li><strong>注入新代码 (C1)</strong>：它将 BOLT 优化后的新代码（C1）加载到进程地址空间的一个<strong>新位置</strong>。</li>
<li><strong>智能重定向</strong>：OCOLOS 只修改那些<strong>可控且值得改</strong>的入口点，将执行流引导至更快的 C1 代码。具体来说：<ul>
<li>它会修改 C0 中的<strong>直接调用指令</strong>，让它们跳转到 C1 中对应的函数。</li>
<li>它会更新 <strong>vtable</strong> 中的函数指针，指向 C1。</li>
<li>对于<strong>连续优化</strong>（从 C1 到 C2），它甚至能处理栈上正在执行的函数，通过复制一份兼容的代码来安全地更新返回地址。</li>
</ul>
</li>
<li><strong>规避不可控指针</strong>：对于那些散落在堆、栈、寄存器里，无法追踪的函数指针，OCOLOS 采用了一个聪明的编译期插桩：强制所有新创建的函数指针都指向<strong>原始的 C0 地址</strong>。这样，即使这些指针被到处传递，当它们被调用时，也会先进入 C0，而 C0 里的直接调用已经被重定向到 C1 了，最终还是会执行到优化后的代码。</li>
</ul>
<p><img alt="" src="../images/fd52d3171b6ecafee1002694cdfe8161b17e9b7b5f07d80fe78de9fddce59a7c.jpg" /></p>
<p><em>Figure 4a: Main steps OCOLOS takes to optimize a target process</em></p>
<p>通过这套组合拳，OCOLOS 实现了对<strong>未修改的、复杂的 C/C++ 应用</strong>（如 MySQL, MongoDB）进行<strong>在线</strong>、<strong>安全</strong>的代码布局优化。它把 PGO 从一个<strong>离线、静态、有滞后性</strong>的工具，变成了一个<strong>在线、动态、始终与当前负载匹配</strong>的活系统。</p>
<p>最终效果非常显著，论文展示了对 MySQL 最高 <strong>1.41×</strong>、对 Verilator 高达 <strong>2.20×</strong> 的加速比，而且这一切都不需要改动一行应用代码。</p>
<p><img alt="" src="../images/733557cfd45975ce35d8ed22bfc93c255ed09d1706d6d1f19fa5423766bca9c4.jpg" /></p>
<p><em>Fig. 5: Performance of OCOLOS (light blue bars) compared to BOLT using an oracle profile of the input being run (dark blue bars), Clang PGO using the same oracle profile (purple bars) and BOLT using an average-case profiling input aggregated from all inputs (pink bars). All bars are normalized to original non-PGO binaries (white bars).</em></p>
<h3 id="1-online-code-layout-optimization-eli5">1. 在线代码布局优化 (Online Code Layout Optimization) (ELI5)<a class="headerlink" href="#1-online-code-layout-optimization-eli5" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击</strong></p>
<ul>
<li>传统的 <strong>Profile-Guided Optimization (PGO)</strong> 是个“马后炮”。它需要先跑一遍程序收集 <strong>profile</strong>（剖析数据），然后用这些数据去重新编译或重写二进制文件，最后再用这个新二进制文件去跑真正的任务。</li>
<li>这套流程在现代软件开发中会遇到两个致命问题：<ul>
<li><strong>输入漂移 (Input Drift)</strong>：你 profiling 的时候用的是 A 场景的数据，但上线后跑的是 B 场景。用 A 的数据去优化 B 的代码，轻则没效果，重则性能更差。</li>
<li><strong>代码漂移 (Code Drift)</strong>：大型项目（比如 MySQL）可能每小时都在更新。昨天 profiling 的数据，今天代码一变，就完全对不上号了，只能丢弃，导致宝贵的优化机会白白浪费。</li>
</ul>
</li>
</ul>
<p><strong>通俗比方</strong></p>
<ul>
<li>想象你在开车去一个陌生城市。传统的 PGO 就像是出发前，你根据一份<strong>昨天的纸质地图</strong>规划好了最优路线。但现实是，路上可能有<strong>突发的交通事故</strong>（输入变化）或者<strong>一夜之间修了新路</strong>（代码更新），你的旧地图立刻就失效了。</li>
<li><strong>OCOLOS</strong> 做的事情，相当于给你的车装了一个<strong>实时联网的高德地图</strong>。它一边开车（程序运行），一边通过 GPS（硬件性能计数器）感知当前路况（代码热点），并<strong>动态地、在线地</strong>为你重新规划一条最快的路线（重排代码布局），确保你永远走在最高效的路径上。</li>
</ul>
<p><strong>关键一招</strong></p>
<ul>
<li>OCOLOS 的核心洞察是：与其费劲地把旧 profile “映射”到新代码上，不如直接在<strong>正在跑的进程里</strong>做优化。它的巧妙之处在于如何安全地“换引擎”而不让车熄火。</li>
<li>具体来说，它没有采用“原地修改”的危险操作，而是遵循了一个稳健的设计原则：<strong>保留原始代码 C0 的地址不变</strong>。<ul>
<li>它先把优化后的新代码 <strong>C1</strong> 注入到进程的地址空间里。</li>
<li>然后，它只去精准地修改那些<strong>最容易追踪和更新的代码指针</strong>，比如：<ul>
<li><strong>v-table</strong> 里的虚函数指针</li>
<li><strong>直接调用 (direct call)</strong> 的指令目标</li>
</ul>
</li>
<li>对于那些难以追踪的指针（比如被 cast 成整数、存到堆栈深处的函数指针），它选择不去碰它们。因为一旦执行流进入 C0，很快就会遇到一个被修补过的直接调用或虚函数调用，从而被“引流”回高性能的 C1 代码。</li>
</ul>
</li>
<li>为了支持<strong>持续优化</strong>（比如应对程序的不同运行阶段），OCOLOS 还引入了一个精巧的机制来处理 <strong>return address</strong> 和 <strong>function pointer</strong>：<ul>
<li>对于栈上的 <strong>return address</strong>，如果它指向即将被替换的旧代码 Ci，OCOLOS 会将对应的函数在新代码区域 Ci+1 中做一个<strong>精确副本 (bi,i+1)</strong>，并修正 return address 指向这个副本，保证函数能正确返回。</li>
<li>对于 <strong>function pointer</strong>，它通过一个轻量级的 <strong>LLVM compiler pass</strong>，在编译时就插入一个钩子 (<code>wrapFuncPtrCreation</code>)。这个钩子确保所有新创建的函数指针都指向<strong>原始代码 C0 的地址</strong>，而不是任何优化版本 Ci 的地址。这样一来，在后续的代码替换中，就完全不用操心这些指针的兼容性问题了，因为它们永远指向一个稳定的锚点。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/fd52d3171b6ecafee1002694cdfe8161b17e9b7b5f07d80fe78de9fddce59a7c.jpg" /></p>
<p><em>Figure 4a: Main steps OCOLOS takes to optimize a target process</em></p>
<p><img alt="" src="../images/8e4009da7cb85456e504591a7cb55b364aebc5c3d4c6534f6c0e172f2fb96366.jpg" /></p>
<p><em>Figure 4b: Starting state of the address space (left) and state after code replacement (right)</em></p>
<p>这种设计让它既能获得接近离线 <strong>BOLT oracle</strong> 的性能收益（见下表），又完美规避了 profile 过期和代码映射的难题，而且对应用程序本身<strong>完全透明、无需修改</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Benchmark (Input)</th>
<th style="text-align: center;"><strong>OCOLOS</strong> Speedup</th>
<th style="text-align: center;"><strong>BOLT (Oracle Input)</strong> Speedup</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">MySQL (read only)</td>
<td style="text-align: center;"><strong>1.41x</strong></td>
<td style="text-align: center;">~1.48x</td>
</tr>
<tr>
<td style="text-align: left;">Verilator</td>
<td style="text-align: center;"><strong>2.20x</strong></td>
<td style="text-align: center;">~2.25x</td>
</tr>
<tr>
<td style="text-align: left;">Clang Build (BAM)</td>
<td style="text-align: center;"><strong>1.14x</strong></td>
<td style="text-align: center;">N/A</td>
</tr>
</tbody>
</table>
<p><img alt="" src="../images/733557cfd45975ce35d8ed22bfc93c255ed09d1706d6d1f19fa5423766bca9c4.jpg" /></p>
<p><em>Fig. 5: Performance of OCOLOS (light blue bars) compared to BOLT using an oracle profile of the input being run (dark blue bars), Clang PGO using the same oracle profile (purple bars) and BOLT using an average-case profiling input aggregated from all inputs (pink bars). All bars are normalized to original non-PGO binaries (white bars).</em></p>
<h3 id="2-safe-online-code-replacement-eli5">2. 安全的在线代码替换机制 (Safe Online Code Replacement) (ELI5)<a class="headerlink" href="#2-safe-online-code-replacement-eli5" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击 (The "Why")</strong></p>
<ul>
<li>传统的 <strong>Profile-Guided Optimization (PGO)</strong> 是个“事后诸葛亮”。它需要先跑一遍程序收集 profile，再用这个 profile 去重新编译或重写二进制文件。问题来了：<ul>
<li>如果你的程序输入变了（比如数据库从读多变成写多），昨天的 profile 今天就可能成了“毒药”，优化反而变劣化。</li>
<li>更麻烦的是，如果你的代码本身在持续更新（比如每小时一个新版本），旧 profile 根本没法准确地映射到新代码上，大部分数据只能丢弃，非常浪费。</li>
</ul>
</li>
<li>所以，理想情况是能<strong>边跑边优化</strong>，profile 永远是最新的。但这引出了一个致命问题：<strong>如何在程序运行时安全地替换掉正在执行的代码？</strong></li>
<li>在 C/C++ 这类 <strong>unmanaged language</strong> 里，代码指针无处不在：函数指针、虚表、栈上的返回地址、甚至被 cast 成整数再算来算去的指针。你根本不可能追踪到所有指向旧代码的指针。一旦你把旧代码覆盖了，任何一个没被更新的指针跳回去，程序就直接崩溃。</li>
</ul>
<p><strong>通俗比方 (The Analogy)</strong></p>
<ul>
<li>想象你在高速公路上开车（程序在运行）。你想把前方一段坑洼的老路（C0）换成一条崭新的、更平顺的快速路（C1）。</li>
<li>传统做法是：封路！让所有车停下来，拆掉老路，建好新路，再放行。这对应于离线 PGO，代价巨大且不灵活。</li>
<li>OCOLOS 的做法很聪明：它<strong>不拆老路</strong>，而是在旁边平行地修一条新路（C1）。然后，它只在几个最关键的<strong>高速公路入口匝道</strong>（比如虚表、直接调用点）上立新的指示牌，引导绝大多数车流（执行流）驶向新路。</li>
<li>那些没看到新指示牌、或者执意要走老路的小路（比如某些隐秘的函数指针），依然可以开，因为老路还在。虽然走老路慢一点，但至少不会翻车（程序不会崩溃）。等车流都习惯走新路后，老路就可以安全地废弃了。</li>
</ul>
<p><img alt="" src="../images/8e4009da7cb85456e504591a7cb55b364aebc5c3d4c6534f6c0e172f2fb96366.jpg" /></p>
<p><em>Figure 4b: Starting state of the address space (left) and state after code replacement (right)</em></p>
<p><strong>关键一招 (The "How")</strong></p>
<ul>
<li>OCOLOS 的核心洞察是：<strong>与其冒着崩溃的风险去追踪和更新所有代码指针，不如保留旧代码作为安全网，并只更新那些最关键、最值得更新的指针。</strong></li>
<li>具体来说，它做了三件事：<ul>
<li><strong>保留原始代码 (C0)</strong>：这是整个方案安全性的基石。所有无法追踪的指针，即使指向 C0，也能正常工作。</li>
<li><strong>注入优化代码 (C1)</strong>：利用 BOLT 等工具生成优化后的代码，并将其加载到进程的新内存区域。</li>
<li><strong>精准引导执行流</strong>：通过 <strong>ptrace</strong> 暂停进程，然后只修改两类关键指针：<ul>
<li><strong>虚表 (v-table) 中的函数指针</strong>：这是面向对象程序中动态分发的核心，更新它们能立刻让大量虚函数调用受益于 C1。</li>
<li><strong>C0 中的直接调用指令</strong>：将这些调用的目标地址从 C0 的函数改为 C1 的对应函数。</li>
</ul>
</li>
</ul>
</li>
<li>这个策略非常务实。它承认了在 unmanaged code 中完全掌控所有指针是不可能的，于是退而求其次，确保<strong>common case</strong>（通过虚表和直接调用的路径）能跑到高性能的 C1 上，而 <strong>rare case</strong>（通过其他方式调用的路径）则回退到功能正确但性能稍差的 C0 上，从而在<strong>安全性和性能之间取得了完美的平衡</strong>。</li>
</ul>
<h3 id="3-function-pointer-creation-interception-eli5">3. 函数指针创建拦截 (Function Pointer Creation Interception) (ELI5)<a class="headerlink" href="#3-function-pointer-creation-interception-eli5" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击 (The "Why")</strong></p>
<p>在 OCOLOS 这类支持 <strong>连续优化 (Continuous Optimization)</strong> 的系统里，代码会经历 C0 → C1 → C2 ... 的多次在线替换。旧版本的代码（比如 C1）在新版本（C2）上线后会被当作“垃圾”回收掉以节省内存。但这里有个致命问题：如果程序在 C1 时代创建了一个指向 C1 中某个函数的 <strong>函数指针 (Function Pointer)</strong>，并把它存到了堆、栈甚至寄存器里，那么当 C1 被回收后，这个指针就变成了一个 <strong>悬空指针 (Dangling Pointer)</strong>。一旦程序后续通过这个指针调用函数，就会直接崩溃。</p>
<ul>
<li>传统的解决方案是尝试在运行时追踪所有函数指针的创建和传播，但这需要 <strong>持续的、高昂的运行时开销</strong>，违背了 OCOLOS “一次性成本”的设计哲学。</li>
<li>另一种方案是在每次代码替换时扫描整个内存去更新这些指针，这不仅 <strong>几乎不可能做到</strong>（指针可能被加密、拆分），而且 <strong>代价巨大</strong>，会严重拖慢替换过程。</li>
</ul>
<p>所以，核心痛点是：如何在允许代码版本不断更迭、旧版本被回收的前提下，<strong>一劳永逸地解决函数指针悬空问题</strong>，且不引入任何持续的性能负担？</p>
<hr />
<p><strong>通俗比方 (The Analogy)</strong></p>
<p>想象你在一个大型物流中心工作，货物（代码）会不断升级换代。旧仓库（C1）里的货物会被清空，腾出地方给新仓库（C2）。</p>
<ul>
<li><strong>传统做法</strong>：每当有人要记录一个货物的位置（创建函数指针），你就给他一张写有具体仓库格子号（C1地址）的纸条。等仓库清空后，所有拿着旧纸条的人都会迷路。</li>
<li><strong>OCOLOS的做法</strong>：你设立了一个<strong>永久不变的中央查询台（C0）</strong>。无论货物搬到哪个新仓库，当你给别人纸条时，上面写的都不是具体的仓库格子号，而是“请去中央查询台找XX货物”。这样，即使背后的仓库（Ci）变了又变，只要中央查询台（C0）还在，并且能正确指引到最新仓库，就不会有人迷路。</li>
</ul>
<p>这个“中央查询台”就是原始代码 C0，它永远不会被移动或回收。</p>
<hr />
<p><strong>关键一招 (The "How")</strong></p>
<p>作者并没有试图去追踪和更新那些已经散落在各处的函数指针，而是巧妙地在源头上做了一个“偷梁换柱”的操作。</p>
<ul>
<li>在编译阶段，OCOLOS 插入了一个轻量级的 <strong>LLVM Compiler Pass</strong>。</li>
<li>这个 Pass 会找到程序中所有 <strong>创建函数指针</strong> 的地方（例如 <code>func_ptr = &amp;my_function;</code>）。</li>
<li>它将这些语句重写，在其后插入一个对 <strong><code>wrapFuncPtrCreation</code></strong> 回调函数的调用。</li>
<li>这个 <code>wrapFuncPtrCreation</code> 函数内部维护了一张 <strong>映射表</strong>，记录了所有优化版本 Ci 中的函数地址到其在原始版本 C0 中对应地址的映射。</li>
<li>因此，无论 <code>&amp;my_function</code> 在当前时刻实际指向的是 C1、C2 还是 C99 中的地址，<code>wrapFuncPtrCreation</code> 都会将其 <strong>拦截并重定向</strong> 到 C0 中那个<strong>永恒不变</strong>的地址。</li>
</ul>
<p><img alt="" src="../images/ff9082d69f504639c893031946832f7604f9fa6ebc45a95dcefb681e07f5171e.jpg" /></p>
<p><em>Figure 4c: Before (left) and after (right) continuous optimization</em></p>
<p>这个设计的精妙之处在于：</p>
<ul>
<li><strong>成本极低</strong>：拦截只发生在函数指针<strong>创建</strong>的瞬间，之后指针可以像普通数据一样自由传递，没有任何额外开销。论文提到 MySQL 每毫秒才创建约 45 个函数指针，开销完全可以忽略。</li>
<li><strong>一劳永逸</strong>：由于所有函数指针最终都指向不会被回收的 C0，因此后续无论进行多少次代码替换和垃圾回收，这些指针都始终有效。</li>
<li><strong>保持兼容性</strong>：C0 中的函数虽然未被优化，但它只是一个“跳板”，内部会立刻跳转到当前最新的优化版本 Ci+1 去执行，保证了性能。</li>
</ul>
<h3 id="4-batch-accelerator-mode-bam-eli5">4. 批处理加速模式 (Batch Accelerator Mode, BAM) (ELI5)<a class="headerlink" href="#4-batch-accelerator-mode-bam-eli5" title="Permanent link">&para;</a></h3>
<p><strong>痛点直击</strong></p>
<ul>
<li>传统的 <strong>Profile-Guided Optimization (PGO)</strong> 工具（如 BOLT）是 <strong>离线 (offline)</strong> 的。它们需要先完整地跑一遍程序来收集 profile，然后用这个 profile 去优化二进制文件，最后再用这个优化后的二进制文件去运行真正的任务。</li>
<li>这个流程对于 <strong>长时运行的服务</strong>（如 MySQL）是可行的，但对于 <strong>短时进程组成的批处理任务</strong>（比如一个包含成千上万个 <code>gcc</code> 调用的软件构建过程）就完全行不通了。因为：<ul>
<li><strong>单次运行时间太短</strong>：每个 <code>gcc</code> 进程可能只活几秒钟，根本来不及在它自己身上完成“剖析 -&gt; 优化 -&gt; 替换”这一整套昂贵的操作。等你优化好了，这个进程早就结束了。</li>
<li><strong>无法受益于自身优化</strong>：即使你为某个 <code>gcc</code> 调用生成了优化版本，它自己也用不上了，只能寄希望于后面的调用能用上。但离线 PGO 需要人为管理 profile 和优化后的二进制文件，这在复杂的构建系统中几乎是不可能的任务。</li>
</ul>
</li>
</ul>
<p><strong>通俗比方</strong></p>
<ul>
<li>想象你要做一锅 <strong>100 个饺子</strong>。传统离线 PGO 就像是：你先拿一个饺子下锅煮，尝一口发现皮有点厚、馅有点少，于是你记下笔记。然后你把锅洗了，根据笔记重新和面、调馅，再包一个新的饺子。这个新饺子确实更好吃了，但你之前煮的那个已经浪费了。</li>
<li><strong>BAM</strong> 的做法则聪明得多：它就像一个 <strong>智能的厨房助手</strong>。他看到你开始包饺子（启动构建），就默默地观察你前几个饺子的做法（剖析早期的 <code>gcc</code> 调用）。在他观察的同时，你还在继续包着普通的饺子。等他看明白了（profile 收集够了），他就立刻在旁边 <strong>快速准备好一批改良版的饺子皮和馅料</strong>（生成 BOLT 优化后的二进制文件）。从下一个饺子开始，你就自动用上了这些更好的材料，后面所有的饺子都变得更好吃，而整个过程对你（构建脚本）来说是完全透明的，你甚至不知道助手的存在。</li>
</ul>
<p><strong>关键一招</strong></p>
<ul>
<li>BAM 的核心洞察是：在一个批处理任务中，<strong>同一个二进制文件会被反复执行多次</strong>。因此，不需要对每个进程都做在线优化，而是可以 <strong>“前人栽树，后人乘凉”</strong>。</li>
<li>为了实现这一点，作者巧妙地利用了 Linux 的 <strong>LD_PRELOAD</strong> 机制，并做了一个关键的逻辑扭转：<ul>
<li><strong>拦截点扭转</strong>：作者没有尝试去替换一个正在运行的短进程的代码（这几乎不可能），而是将优化的切入点放在了 <strong>进程创建之前</strong>。BAM 通过 LD_PRELOAD 注入一个共享库，这个库会 <strong>透明地拦截所有 <code>exec*</code> 系统调用</strong>。</li>
<li><strong>动态重定向</strong>：当 BAM 发现 <code>exec</code> 调用的目标是它要优化的那个二进制文件（比如 <code>clang</code>）时，它会分两步走：<ol>
<li><strong>前期</strong>：让 <code>exec</code> 正常执行，但同时 <strong>悄悄开启硬件性能剖析</strong>（通过 <code>perf</code>），收集这个运行实例的 profile。</li>
<li><strong>后期</strong>：一旦后台的 BOLT 工具利用收集到的 profile 生成了优化版的二进制文件，BAM 就会 <strong>动态修改后续的 <code>exec</code> 调用</strong>，让它直接去执行那个 <strong>优化后的二进制文件</strong>，而不是原始的。</li>
</ol>
</li>
</ul>
</li>
<li>这个设计极其精妙，因为它：<ul>
<li><strong>完全透明</strong>：构建系统（如 <code>make</code>）对此毫无感知，不需要任何代码或脚本修改。</li>
<li><strong>零切换开销</strong>：从原始二进制切换到优化二进制，只是 <code>exec</code> 了一个不同的文件，没有运行时的“停顿世界”（stop-the-world）阶段。</li>
<li><strong>自动适应</strong>：它剖析的就是当前构建任务的真实 workload，生成的优化是高度相关的，避免了离线 PGO 中 profile 过时或不匹配的问题。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/c885f2de83f5f9ff3155e8c04e124cc05db3c250099767a79d4941a89c6258fd.jpg" /></p>
<p><em>Fig. 10: The running time of a Clang build with the original compiler, and compilers optimized by BOLT and BAM.</em></p>
<p>如图所示，在 Clang 构建实验中，BAM 仅需剖析 <strong>少量</strong>（约5个）早期的编译器调用，就能生成一个足够好的优化版本，从而将整个构建时间加速 <strong>1.14倍</strong>。这证明了其“观察少数，惠及多数”的策略非常高效。</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.sections", "navigation.top", "navigation.indexes", "search.suggest", "search.highlight", "content.code.copy"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../../../javascripts/switcher.js"></script>
      
        <script src="../../../javascripts/smart_back.js"></script>
      
    
  </body>
</html>