
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://example.com/notes_repo/atr-out-of-order-register-release-exploiting-atomic-regions/figs_notes/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>ATR: Out-of-Order Register Release Exploiting Atomic Regions 图表详解 - BlaBlaCut</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#atr-out-of-order-register-release-exploiting-atomic-regions" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="BlaBlaCut" class="md-header__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            BlaBlaCut
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              ATR: Out-of-Order Register Release Exploiting Atomic Regions 图表详解
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到深色模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换到深色模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到浅色模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换到浅色模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="BlaBlaCut" class="md-nav__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    BlaBlaCut
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/Recent/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Recent
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/awesome-data-prefetchers/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Awesome Data Prefetchers
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/micro-2025/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    MICRO 2025
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#figure-1-ipc-improves-with-increasing-register-file-size" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 1: IPC improves with increasing register file size
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-2-an-example-of-a-register-value-that-is-speculatively-released-and-laterreused" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 2: An example of a register value that is speculatively released and laterreused.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-3-partial-events-across-the-lifecycle-of-a-register" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 3: Partial events across the lifecycle of a register.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-4-cyclecount-distribution-across-the-register-lifecycle" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 4: Cyclecount distribution across the register lifecycle.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-5-an-example-segment-of-instructions-from-spec2017int-omnetpp" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 5: An example segment of instructions from SPEC2017int omnetpp.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-6-atomic-register-ratio" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 6: Atomic register ratio.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-7-the-proposed-atr-design" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 7: The proposed ATR design.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-8-an-example-of-aggressively-releasing-within-atr" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 8: An example of aggressively releasing within ATR.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-9-renaming-stage-modifcations-for-bulk-setting-of-no-early-release" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 9: Renaming stage modifcations for bulk setting of no-early-release
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-10-ipc-speedup-over-the-baseline-with-64-and-224-physical-registers" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 10: IPC speedup over the baseline with 64 and 224 physical registers.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-11-ipc-speedup-of-the-atomic-scheme-over-the-baseline-with-different-rf-size" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 11: IPC speedup of the atomic scheme over the baseline with different RF Size.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#table-1-processor-configuration-table-2-spec-cpu-2017-benchmarks" class="md-nav__link">
    <span class="md-ellipsis">
      
        Table 1: Processor Configuration Table 2: SPEC CPU 2017 Benchmarks
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ea974a0515084d68793d911affa971644cb9d11b06a3a8a70b6490df2bd93f1bjpg" class="md-nav__link">
    <span class="md-ellipsis">
      
        ea974a0515084d68793d911affa971644cb9d11b06a3a8a70b6490df2bd93f1b.jpg
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-12-consumer-count-distribution" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 12: Consumer count distribution.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-13-performance-effect-of-pipelining-the-register-redefinition-logic" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 13: Performance effect of pipelining the register redefinition logic.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-14-average-cyclecount-between-rename-redefine-and-commit" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 14: Average cyclecount between rename, redefine, and commit.
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#figure-15-overhead-reduction-of-different-schemes" class="md-nav__link">
    <span class="md-ellipsis">
      
        Figure 15: Overhead reduction of different schemes.
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="atr-out-of-order-register-release-exploiting-atomic-regions">ATR: Out-of-Order Register Release Exploiting Atomic Regions 图表详解<a class="headerlink" href="#atr-out-of-order-register-release-exploiting-atomic-regions" title="Permanent link">&para;</a></h1>
<h3 id="figure-1-ipc-improves-with-increasing-register-file-size">Figure 1: IPC improves with increasing register file size<a class="headerlink" href="#figure-1-ipc-improves-with-increasing-register-file-size" title="Permanent link">&para;</a></h3>
<p><img alt="0f5d0884b4401b40ebbfb5364fdde4f267ed6fe62b33871f2cb9daa872db5c57.jpg" src="../images/0f5d0884b4401b40ebbfb5364fdde4f267ed6fe62b33871f2cb9daa872db5c57.jpg" /></p>
<ul>
<li>图表标题为“SPEC2017int”，横轴为“Number of Physical Registers”，范围从64至280，纵轴为“Normalized IPC”，范围从0.0至1.0，<strong>基准值1.0代表无限寄存器配置下的理想性能</strong>。</li>
<li>图中包含多条曲线，分别对应不同SPEC2017int基准测试程序：perlbench、gcc、mcf、omnetpp、xalancbmk、x264、deepsjeng、leela、exchange2、xz。</li>
<li>所有曲线均呈现随物理寄存器数量增加而<strong>IPC逐步提升并趋于饱和</strong>的趋势，表明寄存器资源对性能存在显著约束。</li>
<li>在64寄存器配置下，各程序的归一化IPC普遍较低，例如perlbench约为0.35，gcc约为0.45，<strong>平均仅达理想性能的37.7%</strong>，与正文描述一致。</li>
<li>随着寄存器数增至280，所有程序的IPC均接近1.0，说明在此规模下寄存器压力基本消除。</li>
<li>不同程序对寄存器敏感度存在差异：如x264和leela在低寄存器数时表现较差，增长斜率更陡；而perlbench和gcc则相对平缓。</li>
<li>该图直观验证了论文核心观点：<strong>扩大物理寄存器文件是提升IPC的关键手段，但受限于面积与功耗，需通过高效释放机制（如ATR）缓解压力</strong>。</li>
</ul>
<table>
<thead>
<tr>
<th>程序名</th>
<th>64寄存器IPC（近似）</th>
<th>280寄存器IPC（近似）</th>
</tr>
</thead>
<tbody>
<tr>
<td>perlbench</td>
<td>0.35</td>
<td>0.98</td>
</tr>
<tr>
<td>gcc</td>
<td>0.45</td>
<td>0.99</td>
</tr>
<tr>
<td>mcf</td>
<td>0.50</td>
<td>0.99</td>
</tr>
<tr>
<td>omnetpp</td>
<td>0.55</td>
<td>0.99</td>
</tr>
<tr>
<td>xalancbmk</td>
<td>0.60</td>
<td>0.99</td>
</tr>
<tr>
<td>x264</td>
<td>0.30</td>
<td>0.99</td>
</tr>
<tr>
<td>deepsjeng</td>
<td>0.40</td>
<td>0.99</td>
</tr>
<tr>
<td>leela</td>
<td>0.35</td>
<td>0.99</td>
</tr>
<tr>
<td>exchange2</td>
<td>0.50</td>
<td>0.99</td>
</tr>
<tr>
<td>xz</td>
<td>0.55</td>
<td>0.99</td>
</tr>
</tbody>
</table>
<ul>
<li>曲线间交叉现象表明不同工作负载的寄存器需求模式各异，进一步凸显动态优化技术（如ATR）的必要性。</li>
</ul>
<h3 id="figure-2-an-example-of-a-register-value-that-is-speculatively-released-and-laterreused">Figure 2: An example of a register value that is speculatively released and laterreused.<a class="headerlink" href="#figure-2-an-example-of-a-register-value-that-is-speculatively-released-and-laterreused" title="Permanent link">&para;</a></h3>
<p><img alt="8e39dd5f5458782b1edcec7288568b4d304fdef0ca7f1a7311d4ea16fd149240.jpg" src="../images/8e39dd5f5458782b1edcec7288568b4d304fdef0ca7f1a7311d4ea16fd149240.jpg" /></p>
<ul>
<li>图片展示了一个<strong>寄存器值被投机性释放后又被重用</strong>的典型场景，用于说明传统早期释放机制（Speculative Early Release）的安全隐患。</li>
<li>指令序列按程序顺序从上到下排列，左侧标注“Old”至“Young”，表示指令年龄递增。</li>
<li><strong>I1</strong> 执行 <code>add r1 ← r2, r3</code>，分配物理寄存器 <strong>p1</strong> 给架构寄存器 r1。</li>
<li><strong>I2</strong> 执行 <code>sub r2 ← r1, r3</code>，消费 p1 的值，此时若采用投机性释放策略，可能在 I2 执行后立即释放 p1。</li>
<li><strong>I3</strong> 执行 <code>cmp r2, r4</code>，无直接数据依赖于 p1。</li>
<li><strong>I4</strong> 执行 <code>jne .LABEL</code>，为条件分支指令，其预测结果将决定后续路径。</li>
<li><strong>I5</strong> 位于错误路径（misprediction），执行 <code>add r1 ← r3, r4</code>，重新定义 r1，触发对 p1 的释放（因 r1 被重定义且所有消费者已执行）。</li>
<li><strong>.LABEL:</strong> 标记正确路径的起始点。</li>
<li><strong>I6</strong> 位于正确路径，执行 <code>add r5 ← r1, r3</code>，试图消费 r1 的旧值（即 p1），但此时 p1 已被错误路径中的 I5 释放。</li>
<li>此例揭示了投机性释放的核心问题：<strong>分支误预测后，被释放的寄存器值可能在恢复时被再次需要，导致数据错误</strong>。</li>
<li>为应对该问题，现有方案需引入<strong>影子寄存器文件（shadow register file）</strong> 来备份已释放值，但这增加了硬件复杂度和资源开销。</li>
<li>该图直观支持论文主张：<strong>非投机性释放（如ATR）通过原子提交区域避免此类风险，无需额外备份机制</strong>。</li>
</ul>
<h3 id="figure-3-partial-events-across-the-lifecycle-of-a-register">Figure 3: Partial events across the lifecycle of a register.<a class="headerlink" href="#figure-3-partial-events-across-the-lifecycle-of-a-register" title="Permanent link">&para;</a></h3>
<p><img alt="229435569ef0bc0e64b05979d471b3ef06f3f990629ac7b86bbe29ce486f6e5e.jpg" src="../images/229435569ef0bc0e64b05979d471b3ef06f3f990629ac7b86bbe29ce486f6e5e.jpg" /></p>
<ul>
<li>图片展示了物理寄存器生命周期中的关键事件及其部分时序关系，用于说明寄存器从分配到释放的完整过程。</li>
<li><strong>I1 Renamed</strong>：指令 I1 在重命名阶段为其目标架构寄存器 A 分配一个物理寄存器 P1，标志着寄存器生命周期的起点。</li>
<li><strong>I2 Consumed</strong>：最后一个消费指令 I2 执行完毕，意味着该物理寄存器 P1 的值已被所有消费者读取，进入“无用”状态。</li>
<li><strong>I3 Redefined</strong>：下一个指令 I3 重命名同一架构寄存器 A，将其映射到新的物理寄存器 P2，此时 P1 被重新定义，但尚未安全释放。</li>
<li><strong>I3 Precommitted</strong>：指令 I3 预提交，表示其之前的所有分支和异常指令均已解决，P1 可被标记为“验证无用”，但仍需等待最终提交。</li>
<li><strong>I3 Committed</strong>：指令 I3 提交，此时可安全释放物理寄存器 P1，完成其生命周期。</li>
</ul>
<table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
<th>状态影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>I1 Renamed</td>
<td>指令 I1 重命名目标寄存器，分配 P1</td>
<td>寄存器进入 <strong>In-use</strong> 状态</td>
</tr>
<tr>
<td>I2 Consumed</td>
<td>最后一个消费者 I2 执行完毕</td>
<td>寄存器进入 <strong>Unused</strong> 状态（需 Oracle 信息）</td>
</tr>
<tr>
<td>I3 Redefined</td>
<td>指令 I3 重命名同一架构寄存器</td>
<td>寄存器仍为 <strong>Unused</strong>，但已重新定义</td>
</tr>
<tr>
<td>I3 Precommitted</td>
<td>I3 预提交，所有前置控制流与异常指令已解决</td>
<td>寄存器进入 <strong>Verified-unused</strong> 状态</td>
</tr>
<tr>
<td>I3 Committed</td>
<td>I3 提交，允许释放 P1</td>
<td>寄存器生命周期结束</td>
</tr>
</tbody>
</table>
<ul>
<li>图中箭头表示事件间的部分顺序约束，例如 I1 Renamed 必须先于 I2 Consumed 和 I3 Redefined，而 I3 Precommitted 必须在 I3 Committed 之前。</li>
<li><strong>关键洞察</strong>：寄存器在“Unused”状态期间虽未被使用，但由于分支预测错误可能导致其重新被消费，因此不能立即释放；只有进入“Verified-unused”状态后才可安全释放。</li>
<li>此图是理解 ATR 技术的基础，它通过识别原子提交区域，在不依赖预提交的前提下安全释放寄存器，从而缩短寄存器占用时间。</li>
</ul>
<h3 id="figure-4-cyclecount-distribution-across-the-register-lifecycle">Figure 4: Cyclecount distribution across the register lifecycle.<a class="headerlink" href="#figure-4-cyclecount-distribution-across-the-register-lifecycle" title="Permanent link">&para;</a></h3>
<p><img alt="4efde8d26c33342c7f5f4051b61c8379f982a69404e06ca47ffd1c7ae3796fd8.jpg" src="../images/4efde8d26c33342c7f5f4051b61c8379f982a69404e06ca47ffd1c7ae3796fd8.jpg" /></p>
<ul>
<li>
<p>图片展示了在 SPEC2017int 和 SPEC2017fp 基准测试中，物理寄存器在其生命周期内不同状态所占的周期百分比分布。</p>
</li>
<li>
<p>该图分为上下两个子图，分别对应整数型（SPEC2017int）和浮点型（SPEC2017fp）工作负载。</p>
</li>
<li>
<p>每个柱状图由三部分堆叠组成，代表三种寄存器状态：</p>
<ul>
<li><strong>In-use</strong>（蓝色）：寄存器正在被使用，即从分配到其所有消费者完成读取且已被重定义前的时间段。</li>
<li><strong>Unused</strong>（绿色）：寄存器已不再被任何消费者需要，且已被重定义，但重定义指令尚未预提交（precommitted），此状态依赖于“Oracle”信息，因分支误预测可能导致寄存器重新进入 In-use 状态。</li>
<li><strong>Verified-unused</strong>（红色）：寄存器已被消费、重定义，且重定义指令已预提交，此时可安全释放，无需担心误预测或异常。</li>
</ul>
</li>
<li>
<p>对于 SPEC2017int 工作负载，各状态平均占比为：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>平均占比 (%)</th>
</tr>
</thead>
<tbody>
<tr>
<td>In-use</td>
<td>53.52</td>
</tr>
<tr>
<td>Unused</td>
<td>41.03</td>
</tr>
<tr>
<td>Verified-unused</td>
<td>5.05</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>对于 SPEC2017fp 工作负载，各状态平均占比为：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>平均占比 (%)</th>
</tr>
</thead>
<tbody>
<tr>
<td>In-use</td>
<td>78.27</td>
</tr>
<tr>
<td>Unused</td>
<td>18.91</td>
</tr>
<tr>
<td>Verified-unused</td>
<td>2.813</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>从数据可见，<strong>Unused</strong> 状态占据了相当大的比例，尤其是在整数基准中高达 41.03%，这表明存在巨大的早期释放潜力。</p>
</li>
<li>
<p>然而，传统非投机性早期释放（nonspeculative early release）仅能释放 <strong>Verified-unused</strong> 状态的寄存器，效率极低（仅 5.05% 或 2.813%）。</p>
</li>
<li>
<p>投机性早期释放（speculative early release）虽能释放 <strong>Unused</strong> 状态寄存器，但因不安全（需影子寄存器文件支持），实际应用受限。</p>
</li>
<li>
<p>本文提出的 ATR 技术旨在安全地释放部分 <strong>Unused</strong> 状态寄存器，填补了非投机性与投机性释放之间的性能鸿沟。</p>
</li>
<li>
<p>各基准测试程序间存在显著差异，例如在 SPEC2017int 中，<code>perlbenc</code> 的 In-use 占比最低（约 35%），而 <code>x264</code> 的 In-use 占比最高（约 75%），反映了不同程序对寄存器压力的不同需求。</p>
</li>
</ul>
<h3 id="figure-5-an-example-segment-of-instructions-from-spec2017int-omnetpp">Figure 5: An example segment of instructions from SPEC2017int omnetpp.<a class="headerlink" href="#figure-5-an-example-segment-of-instructions-from-spec2017int-omnetpp" title="Permanent link">&para;</a></h3>
<p><img alt="e441683c9132f70963a949771e4280fdec598c222e20a0e484a22442ce183547.jpg" src="../images/e441683c9132f70963a949771e4280fdec598c222e20a0e484a22442ce183547.jpg" /></p>
<ul>
<li>图片展示了来自 SPEC2017int 基准测试程序 omnetpp 的一段指令序列及其在处理器流水线中的关键阶段时间戳，用于说明 <strong>Atomic Commit Region</strong> 的概念。</li>
<li>表格包含五列：指令编号（I1-I5）、指令操作码、目标寄存器与源寄存器、以及四个流水线阶段的时间点：<strong>Re</strong> (Rename), <strong>Ex</strong> (Execute), <strong>Cm</strong> (Commit), <strong>Pr</strong> (Precommit)。</li>
<li>指令 I1 是 <code>MOVE RAX ← RAX</code>，其 Rename 阶段发生在周期 510，Execute 在 675，Commit 和 Precommit 均在 839。该指令是后续分析的关键起点。</li>
<li>指令 I2 是 <code>TEST + JNZ ZPS ← RAX</code>，这是一个宏融合的条件分支指令。它在周期 510 被重命名，在 841 执行并提交/预提交。由于其分支特性，它阻止了后续指令的预提交。</li>
<li>指令 I3 是 <code>LEA RAX ← RDI</code>，在周期 709 重命名，716 执行和提交，841 预提交。其执行依赖于 I1 的结果。</li>
<li>指令 I4 是 <code>LEA RBX ← RAX</code>，在周期 729 重命名，737 执行和提交，842 预提交。它消费了 I3 的结果。</li>
<li>指令 I5 是 <code>SHR RBX ← RBX, ZPS</code>，在周期 729 重命名，738 执行和提交，842 预提交。它重新定义了寄存器 RBX。</li>
<li>核心观察点在于指令 I4 和 I5。尽管 I2 这个分支指令尚未解决（其 Pr 时间为 841），但在周期 738，当 I5 重命名时，I4 分配的物理寄存器可以被安全释放。这是因为 I4 和 I5 构成了一个原子区域——它们之间没有分支或异常指令。</li>
<li>如果 I2 发生误预测并导致刷新，那么 I4 和 I5 也会一并被刷新，因此提前释放 I4 的寄存器不会导致错误。这正是 ATR 技术的核心洞察：<strong>在原子区域内，即使指令仍处于推测状态，也可以安全地提前释放其分配的寄存器</strong>。</li>
<li>此例清晰地说明了传统非推测性早期释放机制的保守性（必须等待 I2 预提交）与 ATR 技术的激进性（在 I5 重命名时即可释放 I4 的寄存器）之间的区别。</li>
</ul>
<h3 id="figure-6-atomic-register-ratio">Figure 6: Atomic register ratio.<a class="headerlink" href="#figure-6-atomic-register-ratio" title="Permanent link">&para;</a></h3>
<p><img alt="c92c330f57022012a1e210dbf8e1f0c6a9830212a597408a12fa1bd77a887774.jpg" src="../images/c92c330f57022012a1e210dbf8e1f0c6a9830212a597408a12fa1bd77a887774.jpg" /></p>
<ul>
<li>图片展示了 <strong>Figure 6: Atomic register ratio</strong>，用于量化在 SPEC2017int 和 SPEC2017fp 基准测试中，不同类型的指令序列所占物理寄存器分配比例。</li>
<li>图表分为上下两部分，分别对应 <strong>SPEC2017int</strong> 和 <strong>SPEC2017fp</strong> 的数据，纵轴为 Ratio（比例），横轴为各基准测试程序名称。</li>
<li>图例包含三种区域类型：<ul>
<li><strong>nonbranch</strong>：无条件分支的指令序列。</li>
<li><strong>nonexcept</strong>：不含内存指令或异常引发指令的序列。</li>
<li><strong>atomic</strong>：既无分支也无异常引发指令的原子提交区域。</li>
</ul>
</li>
<li>数据表明，在 <strong>SPEC2017int</strong> 中，平均有 <strong>17.04%</strong> 的寄存器分配属于 <strong>atomic</strong> 区域；在 <strong>SPEC2017fp</strong> 中，该比例为 <strong>13.14%</strong>。</li>
<li>各程序表现差异显著：<ul>
<li>在 SPEC2017int 中，<strong>x264</strong> 的 atomic 区域占比最高，接近 0.5；而 <strong>gcc</strong> 几乎为 0。</li>
<li>在 SPEC2017fp 中，<strong>namd</strong> 的 atomic 区域占比最高，超过 0.9；<strong>cactusBSSN</strong> 和 <strong>parest</strong> 则极低。</li>
</ul>
</li>
<li>下表汇总了部分代表性程序的 atomic 区域比例：</li>
</ul>
<table>
<thead>
<tr>
<th>Benchmark</th>
<th>atomic Ratio (SPEC2017int)</th>
<th>atomic Ratio (SPEC2017fp)</th>
</tr>
</thead>
<tbody>
<tr>
<td>x264</td>
<td>~0.5</td>
<td>~0.25</td>
</tr>
<tr>
<td>gcc</td>
<td>~0.0</td>
<td>~0.0</td>
</tr>
<tr>
<td>namd</td>
<td>~0.2</td>
<td>~0.9</td>
</tr>
<tr>
<td>cactusBSSN</td>
<td>—</td>
<td>~0.0</td>
</tr>
<tr>
<td>avg</td>
<td><strong>17.04%</strong></td>
<td><strong>13.14%</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>该图支撑论文核心观点：<strong>atomic commit regions</strong> 在实际程序中广泛存在，为安全的乱序寄存器释放提供了可观的优化空间。</li>
</ul>
<h3 id="figure-7-the-proposed-atr-design">Figure 7: The proposed ATR design.<a class="headerlink" href="#figure-7-the-proposed-atr-design" title="Permanent link">&para;</a></h3>
<p><img alt="98a92276cc4d899233510e66772713b33a5080961fbe12e590567ce986c83c47.jpg" src="../images/98a92276cc4d899233510e66772713b33a5080961fbe12e590567ce986c83c47.jpg" /></p>
<ul>
<li>图片展示了 <strong>ATR (Atomic register Release)</strong> 技术在现代超标量乱序处理器中的整体架构设计，核心目标是实现安全的、非推测性的寄存器提前释放。</li>
<li>整个流水线从左至右依次为 <strong>Renaming</strong>、<strong>Issue</strong>、<strong>Schedule</strong>、<strong>Execution</strong> 和 <strong>Commit</strong> 阶段，其中 <strong>Renaming</strong> 和 <strong>Execution</strong> 阶段被高亮显示，表明它们是 ATR 修改的关键点。</li>
<li><strong>Register File</strong> 模块包含三个主要子组件：<ul>
<li><strong>SRT (Speculative Renaming Table)</strong>：负责将架构寄存器 ID（arch_id）映射到物理寄存器标签（ptag），这是重命名阶段的核心数据结构。</li>
<li><strong>Phys Table</strong>：存储实际的寄存器值，每个条目包含一个 <strong>64/256 bit</strong> 的值字段和一个新增的 <strong>3-bit Consumer Count</strong> 字段。该计数器用于跟踪当前物理寄存器有多少个待消费的指令。</li>
<li><strong>Free List</strong>：管理可用的物理寄存器标签（ptags），供重命名阶段分配使用。</li>
</ul>
</li>
<li><strong>Reorder Buffer (ROB)</strong> 与 <strong>Issue Queue</strong> 协同工作，管理指令的乱序执行和提交顺序。</li>
<li><strong>Functional Units</strong> 执行指令，并在执行完成后通知相关模块。</li>
<li>图中用虚线框和文字标注了 ATR 引入的三项关键修改：<ul>
<li><strong>ATR Identify</strong>：指向 Phys Table 中新增的 <strong>Consumer Count (3 bit)</strong> 字段，这是识别原子区域和触发早期释放的基础。</li>
<li><strong>Consumed Tracking</strong>：表示在指令进入 <strong>Issue</strong> 阶段时，会根据其源操作数对应的 ptag，对 Phys Table 中的 Consumer Count 进行递减操作。</li>
<li><strong>Double-Free Avoidance</strong>：指向 ROB 中每个指令条目新增的 <strong>prev_ptag</strong> 字段。该字段在重命名时记录前一个被覆盖的 ptag。ATR 通过将其设为无效来标记该寄存器已被 ATR 提前释放，从而避免在后续的 Commit 阶段重复释放。</li>
</ul>
</li>
<li>下方图例清晰区分了 <strong>Original Design</strong>（原始设计）和 <strong>ATR Modification</strong>（ATR 修改部分），突出了 ATR 是在现有架构上进行的增量式改进。</li>
<li>核心创新在于利用 <strong>Consumer Count</strong> 和 <strong>prev_ptag</strong> 的组合，在不引入复杂栈、队列或影子寄存器文件的前提下，实现了对原子提交区域的安全、提前寄存器释放。</li>
</ul>
<h3 id="figure-8-an-example-of-aggressively-releasing-within-atr">Figure 8: An example of aggressively releasing within ATR.<a class="headerlink" href="#figure-8-an-example-of-aggressively-releasing-within-atr" title="Permanent link">&para;</a></h3>
<p><img alt="ad471e4b5cfdc96e9d3ffac59eb6356fff01bca5c7600af7ece1cfc5f1e40438.jpg" src="../images/ad471e4b5cfdc96e9d3ffac59eb6356fff01bca5c7600af7ece1cfc5f1e40438.jpg" /></p>
<ul>
<li>
<p>图片展示了一个指令序列示例，用于说明 <strong>ATR (Atomic register Release)</strong> 技术如何在原子提交区域内实现寄存器的激进释放。</p>
</li>
<li>
<p>该序列包含五条指令（I1 到 I5），每条指令后标注了其操作类型或语义：</p>
<ul>
<li>I1: <code>jne .LABEL</code> —— 条件分支指令，标记为 <strong>branch</strong>。</li>
<li>I2: <code>add r1 ← r2, r3</code> —— 加法运算，将结果写入寄存器 r1，标记为 <strong>rename r1</strong>，表示对架构寄存器 r1 进行重命名。</li>
<li>I3: <code>sub r2 ← r1, r4</code> —— 减法运算，读取 r1 的值，标记为 <strong>consume r1</strong>，表示消费 r1。</li>
<li>I4: <code>mul r3 ← r1, r5</code> —— 乘法运算，再次读取 r1 的值，标记为 <strong>consume r1</strong>。</li>
<li>I5: <code>mul r1 ← r4, r5</code> —— 乘法运算，重新定义 r1，标记为 <strong>redefine r1</strong>。</li>
</ul>
</li>
<li>
<p>指令 I2、I3、I4、I5 构成一个 <strong>原子提交区域 (atomic commit region)</strong>，因为它们之间没有条件分支或异常引发指令。</p>
</li>
<li>
<p>在此区域内，物理寄存器分配给 I2 的 r1 可以在 I5 重定义 r1 且 I3 和 I4 都已执行（即所有消费者完成）后被安全释放，即使更早的 I1 分支尚未解决。</p>
</li>
<li>
<p>关键洞察：<strong>即使 I1 分支预测错误并导致刷新，I2-I5 也会作为一个整体被刷新，因此提前释放 I2 分配的物理寄存器是安全的</strong>，不会导致后续指令访问无效寄存器。</p>
</li>
<li>
<p>此机制允许 <strong>out-of-order register release</strong>，即无需等待重定义指令预提交即可释放寄存器，从而减少寄存器文件压力。</p>
</li>
<li>
<p>该示例突显了 ATR 的核心优势：在保证精确异常处理的前提下，安全地提前释放仍处于推测状态的寄存器。</p>
</li>
</ul>
<h3 id="figure-9-renaming-stage-modifcations-for-bulk-setting-of-no-early-release">Figure 9: Renaming stage modifcations for bulk setting of no-early-release<a class="headerlink" href="#figure-9-renaming-stage-modifcations-for-bulk-setting-of-no-early-release" title="Permanent link">&para;</a></h3>
<p><img alt="bd3a9c82d0389a3f7274ef3fcce71d4dbf0eaa4025aab7051ebece3f613070b5.jpg" src="../images/bd3a9c82d0389a3f7274ef3fcce71d4dbf0eaa4025aab7051ebece3f613070b5.jpg" /></p>
<ul>
<li>图片展示了 <strong>ATR</strong> 技术在寄存器重命名阶段为实现 <strong>批量设置 no-early-release</strong> 所做的硬件修改，核心目标是在检测到分支或异常指令时，快速标记当前所有活跃的物理寄存器（ptag）为不可提前释放。</li>
<li>该设计围绕 <strong>SRT (Speculative Renaming Table)</strong> 展开，SRT 存储了架构寄存器（arch_id）到物理寄存器（ptag）的映射。图中 SRT 显示了从索引 0 到 15 的条目，代表一个典型的 x86 架构中可能被访问的寄存器集合。</li>
<li><strong>Per-way decoder</strong> 模块负责根据当前周期内重命名的 N 条指令，生成对应的控制信号，以读取 SRT 中相关的 ptag。</li>
<li>关键路径包括：<ul>
<li>从 SRT 读取所有当前有效的 <strong>旧 ptag</strong>（即被架构寄存器当前映射的物理寄存器）。</li>
<li>同时，从当前周期重命名的 N 条指令中获取 <strong>新 ptag</strong>。</li>
<li>这些读取操作通过多路复用器（MUX）汇聚，并输入到 <strong>ATR Cycle 1</strong> 和 <strong>ATR Cycle 2</strong> 的逻辑云中进行处理。</li>
</ul>
</li>
<li><strong>ATR Cycle 1</strong> 和 <strong>ATR Cycle 2</strong> 代表了为满足时序要求而引入的流水线级。它们共同执行“批量标记”逻辑，判断哪些 ptag 需要被设置为 <strong>no-early-release</strong> 状态。</li>
<li>最终输出是两组信号：<ul>
<li><strong>Bulk marking</strong>：一组并行信号，用于将选定的 ptag 标记为不可提前释放。</li>
<li><strong>SRT pipelined</strong>：经过流水线延迟后的 SRT 数据，用于后续的寄存器重定义判断。</li>
</ul>
</li>
<li>整个设计的关键在于其 <strong>并行化</strong> 和 <strong>流水线化</strong>。为了在单个周期内处理多达 23 个 ptag（例如在 8-wide x86 设计中），需要并行计算所有标记信号。同时，为了缓解组合逻辑延迟，引入了两级流水线，这要求对“重定义”信号进行相应的延迟补偿，以保证数据一致性。</li>
<li>下表总结了该模块的主要功能和设计考量：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: left;">组件</th>
<th style="text-align: left;">功能</th>
<th style="text-align: left;">设计考量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>SRT</strong></td>
<td style="text-align: left;">提供架构寄存器到物理寄存器的实时映射</td>
<td style="text-align: left;">是批量标记操作的数据源</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Per-way decoder</strong></td>
<td style="text-align: left;">解码当前周期重命名的指令，定位相关寄存器</td>
<td style="text-align: left;">支持多指令并行处理</td>
</tr>
<tr>
<td style="text-align: left;"><strong>ATR Logic Clouds (Cycle 1 &amp; 2)</strong></td>
<td style="text-align: left;">执行批量标记算法，判断是否需设为 no-early-release</td>
<td style="text-align: left;">采用流水线设计以满足时序</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Bulk marking</strong></td>
<td style="text-align: left;">输出最终的标记信号</td>
<td style="text-align: left;">并行驱动多个 ptag 的状态位</td>
</tr>
<tr>
<td style="text-align: left;"><strong>SRT pipelined</strong></td>
<td style="text-align: left;">延迟后的 SRT 数据</td>
<td style="text-align: left;">与标记逻辑同步，确保重定义判断准确</td>
</tr>
</tbody>
</table>
<ul>
<li>此设计的核心优势在于其 <strong>高效性</strong> 和 <strong>安全性</strong>。它能够在不增加复杂恢复机制的前提下，安全地阻止在非原子区域内的寄存器被过早释放，从而为 ATR 技术提供了关键的硬件支持。</li>
</ul>
<h3 id="figure-10-ipc-speedup-over-the-baseline-with-64-and-224-physical-registers">Figure 10: IPC speedup over the baseline with 64 and 224 physical registers.<a class="headerlink" href="#figure-10-ipc-speedup-over-the-baseline-with-64-and-224-physical-registers" title="Permanent link">&para;</a></h3>
<p><img alt="2439dfdf2c69d8207501392a63946fe828c651e6de3c8879a2cb309d98f52ffb.jpg" src="../images/2439dfdf2c69d8207501392a63946fe828c651e6de3c8879a2cb309d98f52ffb.jpg" /></p>
<ul>
<li>图片展示了在 <strong>64</strong> 和 <strong>224</strong> 个物理寄存器配置下，三种寄存器重命名方案相对于基线（baseline）的 IPC 加速比（Speedup %），涵盖 <strong>SPEC2017int</strong> 和 <strong>SPEC2017fp</strong> 两大类基准测试。</li>
<li>四个子图分别对应：<ul>
<li>SPEC2017int @ 64</li>
<li>SPEC2017fp @ 64</li>
<li>SPEC2017int @ 224</li>
<li>SPEC2017fp @ 224</li>
</ul>
</li>
<li>每个子图中包含三组柱状图，代表三种技术：<ul>
<li><strong>atomic</strong>：蓝色，代表本文提出的 ATR 技术。</li>
<li><strong>nonspec-ER</strong>：橙色，代表非投机性早期释放（Non-Speculative Early Release）。</li>
<li><strong>combined</strong>：绿色，代表 ATR 与 nonspec-ER 的组合方案。</li>
</ul>
</li>
<li>在 <strong>64 寄存器配置</strong>下：<ul>
<li><strong>atomic</strong> 方案在整数和浮点程序上均带来显著加速，平均分别为 <strong>5.70%</strong> 和 <strong>4.69%</strong>。</li>
<li><strong>nonspec-ER</strong> 表现更优，平均加速达 <strong>13.91%</strong>（int）和 <strong>14.43%</strong>（fp），因其覆盖范围更广。</li>
<li><strong>combined</strong> 方案进一步提升性能，在 int 和 fp 上分别额外获得 <strong>3.23%</strong> 和 <strong>3.27%</strong> 的加速，证明两种机制可协同增效。</li>
</ul>
</li>
<li>在 <strong>224 寄存器配置</strong>下：<ul>
<li>寄存器压力减小，所有方案加速幅度下降。</li>
<li><strong>atomic</strong> 平均加速为 <strong>1.48%</strong>（int）和 <strong>1.11%</strong>（fp）。</li>
<li><strong>nonspec-ER</strong> 仍优于 atomic，但差距缩小。</li>
<li><strong>combined</strong> 依然领先，平均比 nonspec-ER 多出约 <strong>0.4%</strong> 的加速。</li>
</ul>
</li>
<li>关键观察：<ul>
<li>寄存器越少，ATR 效果越明显，因资源竞争更激烈。</li>
<li>ATR 与 nonspec-ER 互补：ATR 适用于原子区域，nonspec-ER 适用于非原子但已预提交的指令。</li>
<li>组合方案始终最优，验证了技术正交性。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>配置</th>
<th>工作负载</th>
<th>atomic (avg)</th>
<th>nonspec-ER (avg)</th>
<th>combined (avg)</th>
</tr>
</thead>
<tbody>
<tr>
<td>64</td>
<td>SPEC2017int</td>
<td>5.70%</td>
<td>13.91%</td>
<td>17.14%</td>
</tr>
<tr>
<td>64</td>
<td>SPEC2017fp</td>
<td>4.69%</td>
<td>14.43%</td>
<td>17.70%</td>
</tr>
<tr>
<td>224</td>
<td>SPEC2017int</td>
<td>1.48%</td>
<td>1.11%</td>
<td>1.48%</td>
</tr>
<tr>
<td>224</td>
<td>SPEC2017fp</td>
<td>1.11%</td>
<td>0.65%</td>
<td>1.11%</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注：表中“combined (avg)”为相对于 baseline 的总加速，非增量值。实际增量为 combined 减去 nonspec-ER。例如在 64 寄存器 int 上，combined 相对于 nonspec-ER 增加了 3.23%。</p>
</blockquote>
<h3 id="figure-11-ipc-speedup-of-the-atomic-scheme-over-the-baseline-with-different-rf-size">Figure 11: IPC speedup of the atomic scheme over the baseline with different RF Size.<a class="headerlink" href="#figure-11-ipc-speedup-of-the-atomic-scheme-over-the-baseline-with-different-rf-size" title="Permanent link">&para;</a></h3>
<p><img alt="654b19143cfd7fc4cef28235ad0641d184e1ffc3b75dc9bb87cb0ebd9971bfd1.jpg" src="../images/654b19143cfd7fc4cef28235ad0641d184e1ffc3b75dc9bb87cb0ebd9971bfd1.jpg" /></p>
<ul>
<li>图片展示了 <strong>ATR</strong> 技术在不同物理寄存器文件（RF）大小下相对于基线的 IPC 速度提升，分为 <strong>SPEC2017int</strong> 和 <strong>SPEC2017fp</strong> 两组。</li>
<li>每个基准测试的柱状图按寄存器文件大小分组，从 <strong>64</strong> 到 <strong>280</strong> 入口，颜色渐变表示尺寸递增。</li>
<li><strong>SPEC2017int</strong> 部分：<ul>
<li>多数程序在小 RF（如 64、96）时获得显著加速，例如 <strong>x264</strong> 在 64 入口时速度提升超过 <strong>20%</strong>。</li>
<li>随着 RF 增大，加速效果普遍下降，如 <strong>x264</strong> 在 280 入口时加速降至约 <strong>5%</strong>。</li>
<li>平均加速随 RF 增加而降低，64 入口平均约 <strong>5.7%</strong>，280 入口降至约 <strong>0.93%</strong>。</li>
</ul>
</li>
<li><strong>SPEC2017fp</strong> 部分：<ul>
<li>加速趋势与整数类似，但整体幅度略低。</li>
<li><strong>parest</strong> 和 <strong>fotonik3d</strong> 在小 RF 下表现突出，前者在 64 入口时加速接近 <strong>10%</strong>。</li>
<li>平均加速从 64 入口的 <strong>4.69%</strong> 降至 280 入口的 <strong>0.53%</strong>。</li>
</ul>
</li>
<li>总体观察：<strong>寄存器压力越大（RF 越小），ATR 的收益越显著</strong>；当 RF 足够大（如 280），寄存器不再是瓶颈，加速效果趋于平缓。</li>
<li>数据汇总如下：</li>
</ul>
<table>
<thead>
<tr>
<th>RF Size</th>
<th>SPEC2017int Avg Speedup (%)</th>
<th>SPEC2017fp Avg Speedup (%)</th>
</tr>
</thead>
<tbody>
<tr>
<td>64</td>
<td>5.70</td>
<td>4.69</td>
</tr>
<tr>
<td>96</td>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>128</td>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>160</td>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>192</td>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>224</td>
<td>1.48</td>
<td>1.11</td>
</tr>
<tr>
<td>280</td>
<td>0.93</td>
<td>0.53</td>
</tr>
</tbody>
</table>
<ul>
<li>图中 “avg” 表示所有程序的平均加速值，显示 ATR 在资源受限场景下具有明显优势。</li>
</ul>
<h3 id="table-1-processor-configuration-table-2-spec-cpu-2017-benchmarks">Table 1: Processor Configuration Table 2: SPEC CPU 2017 Benchmarks<a class="headerlink" href="#table-1-processor-configuration-table-2-spec-cpu-2017-benchmarks" title="Permanent link">&para;</a></h3>
<p><img alt="44951512bff276564e99decbf9f02635e2e92aedc983a74552b2f0227fc9f582.jpg" src="../images/44951512bff276564e99decbf9f02635e2e92aedc983a74552b2f0227fc9f582.jpg" /></p>
<ul>
<li><strong>核心配置</strong>：该处理器模型基于 <strong>Golden Cove</strong> 架构，主频设定为 <strong>3.0 GHz</strong>，前端与退休宽度均为 <strong>6-wide fetch/decode</strong> 与 <strong>8-wide retirement</strong>，功能单元包含 <strong>5 ALU、3 Load、2 Store</strong>。</li>
<li><strong>分支预测器</strong>：采用 <strong>TAGE-SC-L + BPU enhancements</strong>，分支目标缓冲区（BTB）容量为 <strong>12K entries</strong>，间接分支目标缓冲区为 <strong>3K entries</strong>。</li>
<li><strong>重排序缓冲区（ROB）</strong>：大小为 <strong>512 entries</strong>，保留站（Reservation Station）为 <strong>160 entries</strong>，数据预取器支持 <strong>Stream, Spatial</strong> 策略。</li>
<li><strong>指令预取器</strong>：使用 <strong>FDIP with deeper prefetch window</strong>，加载缓冲区为 <strong>96 entries</strong>，存储缓冲区为 <strong>64 entries</strong>。</li>
<li><strong>前端取指目标</strong>：每周期支持 <strong>2 FT targets</strong>，FT块大小为 <strong>64 B</strong>。</li>
<li><strong>缓存与内存系统</strong>：<ul>
<li>L1 指令缓存：<strong>32 KiB, 8-way</strong></li>
<li>L1 数据缓存：<strong>48 KiB, 12-way</strong></li>
<li>L2 统一缓存：<strong>1.25 MiB, 10-way</strong></li>
<li>LLC 统一缓存：<strong>Shared 3 MiB/core, 12-way</strong></li>
<li>L1 D-cache 延迟：<strong>3 cycles</strong></li>
<li>L1 I-cache 延迟：<strong>3 cycles</strong></li>
<li>L2 延迟：<strong>14 cycles</strong></li>
<li>LLC 延迟：<strong>40 cycles</strong></li>
<li>内存类型：<strong>DDR4-3200 (2 channels)</strong></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU</td>
<td>Golden Cove</td>
</tr>
<tr>
<td>All-core turbo frequency</td>
<td>3.0 GHz</td>
</tr>
<tr>
<td>Frontend width and retirement</td>
<td>6-wide fetch/decode, 8-wide retirement</td>
</tr>
<tr>
<td>Functional Units</td>
<td>5 ALU, 3 Load, 2 Store</td>
</tr>
<tr>
<td>Branch Predictor</td>
<td>TAGE-SC-L + BPU enhancements</td>
</tr>
<tr>
<td>Branch Target Buffer (BTB)</td>
<td>12K entries</td>
</tr>
<tr>
<td>Indirect Branch Target Buffer</td>
<td>3K entries</td>
</tr>
<tr>
<td>ROB</td>
<td>512 entries</td>
</tr>
<tr>
<td>Reservation Station</td>
<td>160 entries</td>
</tr>
<tr>
<td>Data Prefetcher</td>
<td>Stream, Spatial</td>
</tr>
<tr>
<td>Instruction Prefetcher</td>
<td>FDIP with deeper prefetch window</td>
</tr>
<tr>
<td>Load Buffer</td>
<td>96 entries</td>
</tr>
<tr>
<td>Store Buffer</td>
<td>64 entries</td>
</tr>
<tr>
<td>Frontend Fetch targets (FT) per cycle</td>
<td>2</td>
</tr>
<tr>
<td>FT block size</td>
<td>64 B</td>
</tr>
<tr>
<td>L1 instruction cache</td>
<td>32 KiB, 8-way</td>
</tr>
<tr>
<td>L1 data cache</td>
<td>48 KiB, 12-way</td>
</tr>
<tr>
<td>L2 unified cache</td>
<td>1.25 MiB, 10-way</td>
</tr>
<tr>
<td>LLC unified cache</td>
<td>Shared 3 MiB/core, 12-way</td>
</tr>
<tr>
<td>L1 D-cache latency</td>
<td>3 cycles</td>
</tr>
<tr>
<td>L1 I-cache latency</td>
<td>3 cycles</td>
</tr>
<tr>
<td>L2 latency</td>
<td>14 cycles</td>
</tr>
<tr>
<td>LLC latency</td>
<td>40 cycles</td>
</tr>
<tr>
<td>Memory</td>
<td>DDR4-3200 (2 channels)</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>模拟环境</strong>：该配置用于 <strong>Scarab</strong> 微架构模拟器，以匹配现代 Intel Golden Cove 处理器的性能特征，支持对 <strong>SPEC2017int</strong> 和 <strong>SPEC2017fp</strong> 基准测试套件进行评估。</li>
<li><strong>设计目标</strong>：通过精确建模前端、执行单元、缓存层次和内存子系统，确保模拟结果能反映真实硬件行为，从而有效评估 <strong>ATR</strong> 技术在不同寄存器文件大小下的性能增益。</li>
</ul>
<h3 id="ea974a0515084d68793d911affa971644cb9d11b06a3a8a70b6490df2bd93f1bjpg">ea974a0515084d68793d911affa971644cb9d11b06a3a8a70b6490df2bd93f1b.jpg<a class="headerlink" href="#ea974a0515084d68793d911affa971644cb9d11b06a3a8a70b6490df2bd93f1bjpg" title="Permanent link">&para;</a></h3>
<p><img alt="ea974a0515084d68793d911affa971644cb9d11b06a3a8a70b6490df2bd93f1b.jpg" src="../images/ea974a0515084d68793d911affa971644cb9d11b06a3a8a70b6490df2bd93f1b.jpg" /></p>
<ul>
<li>该图片为一张表格，清晰列出了用于实验评估的 <strong>SPEC CPU 2017</strong> 基准测试套件中的具体程序。</li>
<li>表格内容分为两大类：<strong>Integer benchmarks (SPEC2017int)</strong> 和 <strong>Floating-point benchmarks (SPEC2017fp)</strong>。</li>
<li><strong>Integer benchmarks (SPEC2017int)</strong> 包含以下 9 个程序：<ul>
<li>500.perlbenc_h_r</li>
<li>502.gcc_r</li>
<li>505.mcf_r</li>
<li>520.omnetpp_r</li>
<li>523.xalancbmk_r</li>
<li>525.x264_r</li>
<li>531.deepsjeng_r</li>
<li>541.leela_r</li>
<li>548.exchange2_r</li>
<li>557.xz_r</li>
</ul>
</li>
<li><strong>Floating-point benchmarks (SPEC2017fp)</strong> 包含以下 13 个程序：<ul>
<li>503.bwaves_r</li>
<li>507.cactuBSSN_r</li>
<li>508.namd_r</li>
<li>510.parest_r</li>
<li>511.povray_r</li>
<li>519.lbm_r</li>
<li>521.wrf_r</li>
<li>526.blender_r</li>
<li>527.cam4_r</li>
<li>538.imagick_r</li>
<li>544.nab_r</li>
<li>549.fotonik3d_r</li>
<li>554.roms_r</li>
</ul>
</li>
<li>此表格是论文第 5.1 节 “Experimental Methodology” 中所提及工作负载（Workloads）的具体清单，用于在 <strong>Scarab</strong> 模拟器上进行性能评估。</li>
</ul>
<h3 id="figure-12-consumer-count-distribution">Figure 12: Consumer count distribution.<a class="headerlink" href="#figure-12-consumer-count-distribution" title="Permanent link">&para;</a></h3>
<p><img alt="f33fec17dd3b8aa6b5b1bb75b2414f0dcec66e8d5dc2f40d1ffc4beef73b32a3.jpg" src="../images/f33fec17dd3b8aa6b5b1bb75b2414f0dcec66e8d5dc2f40d1ffc4beef73b32a3.jpg" /></p>
<ul>
<li>图片展示了 <strong>Figure 12: Consumer count distribution</strong>，用于分析 ATR 技术中每个原子区域（atomic region）内物理寄存器的平均消费者数量分布。</li>
<li>数据按 <strong>SPEC2017int</strong> 和 <strong>SPEC2017fp</strong> 两大类基准测试分别呈现，横轴为具体工作负载名称，纵轴为百分比（%），表示不同消费者数量区间所占比例。</li>
<li>消费者数量分为六个区间：<strong>1、2、3、4、5、6+</strong>，分别用不同颜色块表示，图例位于图表下方。</li>
<li><strong>SPEC2017int</strong> 结果显示：<ul>
<li>多数工作负载（如 perlbench、gcc、mcf、omnetpp、xalancbmk、x264、leela、exchange2、xz）中，<strong>1个消费者</strong> 占主导地位（蓝色块占比最大）。</li>
<li><strong>deepsjeng</strong> 是例外，其 <strong>2个消费者</strong>（绿色块）占比显著高于其他，接近 30%，表明该程序中寄存器重用模式更复杂。</li>
<li>所有工作负载中，<strong>6+ 消费者</strong>（红色块）占比极低或为零，说明绝大多数原子区域内的寄存器消费行为集中在少数指令上。</li>
</ul>
</li>
<li><strong>SPEC2017fp</strong> 结果显示：<ul>
<li><strong>bwaves、cactuBSSN、parest、povray、lbm、wrf、blender、cam4、imagick、nab、fotonik3d、roms</strong> 等多数工作负载同样以 <strong>1个消费者</strong> 为主。</li>
<li><strong>namd</strong> 表现特殊，其 <strong>3个消费者</strong>（深蓝色块）和 <strong>4个消费者</strong>（深绿色块）合计占比超过 20%，是所有工作负载中消费者数量最多的，表明其数据流更密集。</li>
<li>同样，<strong>6+ 消费者</strong> 在所有浮点工作负载中均未出现或可忽略。</li>
</ul>
</li>
<li>综合来看，<strong>绝大多数原子区域仅包含 1~2 个消费者</strong>，这支持了 ATR 使用 <strong>3-bit 计数器</strong>（支持最多 6 个消费者，其中 1 位保留为 no-early-release）的设计是充分且高效的。</li>
<li>下表总结关键数据：</li>
</ul>
<table>
<thead>
<tr>
<th>工作负载</th>
<th>主要消费者数量</th>
<th>特殊表现</th>
</tr>
</thead>
<tbody>
<tr>
<td>deepsjeng</td>
<td>1</td>
<td>2个消费者占比约30%</td>
</tr>
<tr>
<td>namd</td>
<td>1</td>
<td>3/4个消费者合计超20%</td>
</tr>
<tr>
<td>其余大部分</td>
<td>1</td>
<td>6+消费者基本为0</td>
</tr>
</tbody>
</table>
<ul>
<li>此分布验证了 ATR 的硬件开销（3-bit counter）在实际应用中是轻量级且有效的，无需更大计数器即可覆盖绝大多数场景。</li>
</ul>
<h3 id="figure-13-performance-effect-of-pipelining-the-register-redefinition-logic">Figure 13: Performance effect of pipelining the register redefinition logic.<a class="headerlink" href="#figure-13-performance-effect-of-pipelining-the-register-redefinition-logic" title="Permanent link">&para;</a></h3>
<p><img alt="5422e968f8bd1f0a71194441a10a9a579bd7ef007b1700fd594d260fa7c62e11.jpg" src="../images/5422e968f8bd1f0a71194441a10a9a579bd7ef007b1700fd594d260fa7c62e11.jpg" /></p>
<ul>
<li>图片展示了在 <strong>64-entry register file</strong> 配置下，对 <strong>SPEC2017int</strong> 和 <strong>SPEC2017fp</strong> 基准测试套件中各程序的 IPC Speedup (%) 结果，用于评估 ATR 技术中寄存器重定义逻辑流水线化（pipelining）对性能的影响。</li>
<li>该图分为上下两个子图，分别对应整数和浮点工作负载。每个子图中的柱状图代表不同延迟配置下的性能提升百分比。</li>
<li>所有柱状图均按基准程序名称排列，从左至右依次为：perlbenc、gcc、mcf、omnetpp、xalancbmk、x264、deepsjeng、leela、exchange2、xz、avg（平均值）；以及 bwaves、cactuBSSN、namd、parest、povray、lbm、wrf、blender、cam4、imagick、nab、fotonik3d、roms、avg。</li>
<li>图例说明了六种不同的实验配置：<ul>
<li><strong>atomic(0-cycle-delay)</strong>：原子区域释放，无延迟</li>
<li><strong>atomic(1-cycle-delay)</strong>：原子区域释放，1周期延迟</li>
<li><strong>atomic(2-cycle-delay)</strong>：原子区域释放，2周期延迟</li>
<li><strong>combined(0-cycle-delay)</strong>：原子 + 非投机性早期释放，无延迟</li>
<li><strong>combined(1-cycle-delay)</strong>：原子 + 非投机性早期释放，1周期延迟</li>
<li><strong>combined(2-cycle-delay)</strong>：原子 + 非投机性早期释放，2周期延迟</li>
</ul>
</li>
<li>从数据趋势看，<strong>延迟对性能影响极小</strong>。无论是 atomic 还是 combined 方案，在引入 1 或 2 周期延迟后，IPC 提升幅度几乎没有变化，多数程序的差异在 ±1% 以内。</li>
<li>例如，在 SPEC2017int 的 x264 程序中，atomic(0) 达到约 20%，而 atomic(2) 仍保持在 20% 左右；在 SPEC2017fp 的 povray 中，combined(0) 约为 42%，combined(2) 仍接近 42%。</li>
<li>平均值（avg）显示，对于 SPEC2017int，atomic 方案在 0/1/2 延迟下分别为 ~5.7% / ~5.7% / ~5.7%；combined 方案为 ~8.9% / ~8.9% / ~8.9%。对于 SPEC2017fp，atomic 为 ~4.7% / ~4.7% / ~4.7%，combined 为 ~7.9% / ~7.9% / ~7.9%。</li>
<li>表格总结关键平均值：</li>
</ul>
<table>
<thead>
<tr>
<th>配置</th>
<th>SPEC2017int avg IPC Speedup (%)</th>
<th>SPEC2017fp avg IPC Speedup (%)</th>
</tr>
</thead>
<tbody>
<tr>
<td>atomic(0-cycle-delay)</td>
<td>5.7</td>
<td>4.7</td>
</tr>
<tr>
<td>atomic(1-cycle-delay)</td>
<td>5.7</td>
<td>4.7</td>
</tr>
<tr>
<td>atomic(2-cycle-delay)</td>
<td>5.7</td>
<td>4.7</td>
</tr>
<tr>
<td>combined(0-cycle-delay)</td>
<td>8.9</td>
<td>7.9</td>
</tr>
<tr>
<td>combined(1-cycle-delay)</td>
<td>8.9</td>
<td>7.9</td>
</tr>
<tr>
<td>combined(2-cycle-delay)</td>
<td>8.9</td>
<td>7.9</td>
</tr>
</tbody>
</table>
<ul>
<li>结论：<strong>ATR 的寄存器重定义逻辑即使引入 1~2 周期流水线延迟，也不会显著影响性能</strong>，这验证了其设计在时序上的鲁棒性，允许硬件实现中通过增加流水级来满足高频需求而不牺牲效能。</li>
</ul>
<h3 id="figure-14-average-cyclecount-between-rename-redefine-and-commit">Figure 14: Average cyclecount between rename, redefine, and commit.<a class="headerlink" href="#figure-14-average-cyclecount-between-rename-redefine-and-commit" title="Permanent link">&para;</a></h3>
<p><img alt="dcc41abee643a846e303ecf0df213cb9b98a801747d602c22934e23b2067f59d.jpg" src="../images/dcc41abee643a846e303ecf0df213cb9b98a801747d602c22934e23b2067f59d.jpg" /></p>
<ul>
<li>图片展示了在 <strong>atomic commit regions</strong> 内，物理寄存器生命周期中三个关键事件之间的平均周期数：<strong>I1 Renamed</strong>（首次重命名）、<strong>I2 Consumed</strong>（最后一次消费）、<strong>I3 Redefined</strong>（被重新定义）和 <strong>I3 Committed</strong>（重新定义指令提交）。</li>
<li>图表分为上下两部分，分别对应 <strong>SPEC2017int</strong> 和 <strong>SPEC2017fp</strong> 基准测试集。</li>
<li>每个基准测试的柱状图包含三组数据：<ul>
<li><strong>黄色柱</strong>：I3 Redefined - I1 Renamed，表示从寄存器首次分配到被重新定义的时间跨度。</li>
<li><strong>粉色柱</strong>：I2 Consumed - I1 Renamed，表示从寄存器首次分配到其值被最后一次消费的时间跨度。</li>
<li><strong>绿色柱</strong>：I3 Committed - I1 Renamed，表示从寄存器首次分配到重新定义指令最终提交的时间跨度。</li>
</ul>
</li>
<li>数据表明，在绝大多数工作负载中，<strong>I2 Consumed</strong> 发生在 <strong>I3 Redefined</strong> 之后，这支持了 ATR 的设计前提：只要寄存器被重新定义且所有消费者已执行，即可安全释放，无需等待提交。</li>
<li>在 <strong>SPEC2017int</strong> 中，例如 <code>x264</code> 和 <code>deepspjeng</code>，<strong>I3 Committed</strong> 的周期数显著高于前两者，说明传统方法（等待提交）会持有寄存器过久。</li>
<li>在 <strong>SPEC2017fp</strong> 中，如 <code>bwaves</code> 和 <code>cactuBSSN</code>，<strong>I3 Committed</strong> 的延迟尤为明显，进一步凸显 ATR 提前释放寄存器的潜力。</li>
<li>平均值（avg）显示，无论整型还是浮点型基准，<strong>I3 Committed - I1 Renamed</strong> 的周期数远大于 <strong>I3 Redefined - I1 Renamed</strong> 和 <strong>I2 Consumed - I1 Renamed</strong>，证明 ATR 能有效缩短寄存器占用时间。</li>
</ul>
<table>
<thead>
<tr>
<th>Benchmark Group</th>
<th>Event Pair</th>
<th>Average Cycle Count (Approx.)</th>
</tr>
</thead>
<tbody>
<tr>
<td>SPEC2017int</td>
<td>I3 Redefined - I1 Renamed</td>
<td>~50</td>
</tr>
<tr>
<td></td>
<td>I2 Consumed - I1 Renamed</td>
<td>~80</td>
</tr>
<tr>
<td></td>
<td>I3 Committed - I1 Renamed</td>
<td>~150</td>
</tr>
<tr>
<td>SPEC2017fp</td>
<td>I3 Redefined - I1 Renamed</td>
<td>~100</td>
</tr>
<tr>
<td></td>
<td>I2 Consumed - I1 Renamed</td>
<td>~150</td>
</tr>
<tr>
<td></td>
<td>I3 Committed - I1 Renamed</td>
<td>~300</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>关键结论</strong>：ATR 利用原子区域特性，在 <strong>I3 Redefined</strong> 且 <strong>I2 Consumed</strong> 后即可释放寄存器，相比传统方法（等待 <strong>I3 Committed</strong>），可大幅减少寄存器占用周期，从而缓解寄存器文件压力。</li>
</ul>
<h3 id="figure-15-overhead-reduction-of-different-schemes">Figure 15: Overhead reduction of different schemes.<a class="headerlink" href="#figure-15-overhead-reduction-of-different-schemes" title="Permanent link">&para;</a></h3>
<p><img alt="b942e1e1ca4b6808dee674c0b8be47075d8a7bbd525206ad1e2a918c16219c9d.jpg" src="../images/b942e1e1ca4b6808dee674c0b8be47075d8a7bbd525206ad1e2a918c16219c9d.jpg" /></p>
<ul>
<li>图片展示了三种不同寄存器重命名方案在<strong>Register Count（寄存器数量）</strong>、**Runtime Power（运行功耗）<strong>和</strong>Core Area（核心面积）**三个维度上的开销降低效果，对应论文中的Figure 15。</li>
<li>三种方案分别为：<strong>atomic</strong>（ATR原子区域释放）、<strong>nonspec</strong>（非投机性早期释放）、<strong>combined</strong>（两者结合）。</li>
<li>所有数据均以百分比形式呈现，表示相对于基线（280寄存器配置）的降低幅度。</li>
</ul>
<table>
<thead>
<tr>
<th>维度</th>
<th>atomic</th>
<th>nonspec</th>
<th>combined</th>
</tr>
</thead>
<tbody>
<tr>
<td>Register Count</td>
<td><strong>27.1%</strong></td>
<td>24.3%</td>
<td><strong>30.0%</strong></td>
</tr>
<tr>
<td>Runtime Power</td>
<td><strong>5.5%</strong></td>
<td>5.0%</td>
<td><strong>5.5%</strong></td>
</tr>
<tr>
<td>Core Area</td>
<td><strong>2.7%</strong></td>
<td>2.6%</td>
<td><strong>2.9%</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>在<strong>寄存器数量</strong>方面，<strong>combined</strong>方案表现最优，达到**30.0%**的降低，显著优于单独使用atomic或nonspec方案。</li>
<li>在<strong>运行功耗</strong>方面，<strong>atomic</strong>与<strong>combined</strong>方案均实现**5.5%**的降低，优于nonspec方案的5.0%。</li>
<li>在<strong>核心面积</strong>方面，<strong>combined</strong>方案同样领先，达到**2.9%**的降低，略高于atomic的2.7%和nonspec的2.6%。</li>
<li>数据表明，<strong>ATR技术不仅独立有效，且与非投机性早期释放机制协同工作时能带来最大综合收益</strong>，尤其在减少物理寄存器需求上效果突出。</li>
</ul>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.sections", "navigation.top", "navigation.indexes", "search.suggest", "search.highlight", "content.code.copy"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../../../javascripts/switcher.js"></script>
      
        <script src="../../../javascripts/smart_back.js"></script>
      
    
  </body>
</html>