
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://example.com/notes_repo/titan-i-an-open-source-high-performance-risc-v-vector-core/paper_notes/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Titan-I: An Open-Source, High Performance RISC-V Vector Core 论文解析 - BlaBlaCut</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#titan-i-an-open-source-high-performance-risc-v-vector-core" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="BlaBlaCut" class="md-header__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            BlaBlaCut
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Titan-I: An Open-Source, High Performance RISC-V Vector Core 论文解析
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到深色模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换到深色模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="amber"  aria-label="切换到浅色模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换到浅色模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="BlaBlaCut" class="md-nav__button md-logo" aria-label="BlaBlaCut" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    BlaBlaCut
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/Recent/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Recent
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/awesome-data-prefetchers/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Awesome Data Prefetchers
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../collections/micro-2025/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    MICRO 2025
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#0" class="md-nav__link">
    <span class="md-ellipsis">
      
        0. 论文基本信息
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. 摘要
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. 背景知识与核心贡献
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. 核心技术和实现细节
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3. 核心技术和实现细节">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#0_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        0. 技术架构概览
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-coarse-grained-floor-planning-solver" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. Coarse-Grained Floor-Planning Solver
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-datapath-wide-permutation-unit" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. Datapath-Wide Permutation Unit
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-shadow-cache-for-mask-register-v0" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. Shadow Cache for Mask Register (v0)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-fine-grained-chaining-microarchitecture" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. Fine-Grained Chaining Microarchitecture
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5-issue-as-commit-for-scalar-vector-ooo-execution" class="md-nav__link">
    <span class="md-ellipsis">
      
        5. Issue-as-Commit for Scalar-Vector OoO Execution
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6-dual-lsu-with-memory-interleaving-and-delay-slots" class="md-nav__link">
    <span class="md-ellipsis">
      
        6. Dual LSU with Memory Interleaving and Delay Slots
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. 实验方法与实验结果
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="titan-i-an-open-source-high-performance-risc-v-vector-core">Titan-I: An Open-Source, High Performance RISC-V Vector Core 论文解析<a class="headerlink" href="#titan-i-an-open-source-high-performance-risc-v-vector-core" title="Permanent link">&para;</a></h1>
<h2 id="0">0. 论文基本信息<a class="headerlink" href="#0" title="Permanent link">&para;</a></h2>
<p><strong>作者 (Authors)</strong></p>
<ul>
<li>Jiuyang Liu</li>
<li>Qinjun Li</li>
<li>Yunqian Luo</li>
<li>Hongbin Zhang</li>
<li>Jiongjia Lu</li>
<li>Shupei Fan</li>
<li>Jianhao Ye</li>
<li>Yang Liu</li>
<li>Xiaoyi Liu</li>
<li>Yanqi Yang</li>
<li>Zewen Ye</li>
<li>Yuhang Zeng</li>
<li>Ao Shen</li>
<li>Rui Huang</li>
<li>Wei Cong</li>
<li>Xuecheng Zou</li>
<li>Mingyu Gao</li>
</ul>
<p><strong>发表期刊/会议 (Journal/Conference)</strong></p>
<ul>
<li>58th IEEE/ACM International Symposium on Microarchitecture (MICRO '25)</li>
</ul>
<p><strong>发表年份 (Publication Year)</strong></p>
<ul>
<li>2025</li>
</ul>
<hr />
<h2 id="1">1. 摘要<a class="headerlink" href="#1" title="Permanent link">&para;</a></h2>
<p><strong>目的</strong></p>
<ul>
<li>解决传统向量处理器在扩展 <strong>VLEN</strong> (Vector Length) 和 <strong>DLEN</strong> (Datapath Width) 时面临的微架构瓶颈，包括路由拥塞、掩码寄存器广播开销以及 <strong>ILP</strong> (Instruction-Level Parallelism) 调度不足等问题。</li>
<li>设计并实现一个高性能、可扩展的 <strong>RISC-V Vector</strong> (RVV) 核心，能够同时高效地利用 <strong>ILP</strong> 和 <strong>DLP</strong> (Data-Level Parallelism)，以在 <strong>HPC</strong> 和 <strong>Cryptography</strong> 等领域超越 <strong>GP-GPU</strong> 和现有向量核心。</li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li>提出 **Titan-I **(T1) 架构，一个开源的、乱序执行 <strong>(OoO)</strong> 的 <strong>lane-based</strong> RVV 核心生成器。</li>
<li>为解决扩展性挑战，引入三项关键创新：<ul>
<li><strong>Coarse-grained floor-planning solver</strong>: 优化 <strong>lane</strong> 布局，最小化跨 <strong>lane</strong> 访问（如 widen/narrow 操作）的最大路由延迟。
    <img alt="" src="images/5f5b0a9d7c8e4b3a9f1d2e6c8a7b4f1d.jpg" /></li>
<li><strong>Datapath-wide permutation unit</strong>: 提供专用的全带宽数据重排硬件，避免通过本地内存进行数据交换。</li>
<li><strong>Shadow-cache for mask registers</strong>: 为掩码寄存器 <strong>v0</strong> 引入影子缓存，消除谓词执行中的非局部广播瓶颈。</li>
</ul>
</li>
<li>为提升 <strong>ILP</strong>，部署多种向量专用的 <strong>OoO</strong> 技术：<ul>
<li><strong>Fine-grained chaining</strong>: 在 <strong>lane datapath</strong> 粒度上调度依赖的微操作 <strong>(uops)</strong>，最大化算术和内存指令间的重叠。</li>
<li><strong>Issue-as-commit</strong>: 允许标量和向量流水线在无真实依赖时独立提交，减少不必要的停顿。</li>
<li><strong>Memory interleaving</strong>: 允许非冲突的加载和存储指令并行执行，提高内存利用率。</li>
</ul>
</li>
</ul>
<p><strong>结果</strong></p>
<ul>
<li>T1 在多个基准测试中展现出卓越性能，显著优于 <strong>GP-GPU</strong> 和其他向量核心。</li>
<li><strong>Cryptographic Workloads</strong>:<ul>
<li>在 **Montgomery Modular Multiplication **(MMM) 和 **Number-Theoretic Transform **(NTT) 工作负载上，T1 (DLEN=1024, VLEN=16384) 相比 **Nvidia GA102 **(RTX 3090) 和 **GB202 **(RTX 5090) 实现了最高 <strong>2.41倍</strong> 的加速。</li>
<li>T1 的面积仅为 <strong>GA102</strong> 单个 <strong>SM</strong> 的 <strong>40%</strong>。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/ff792de6f74721f75bd51d9900cc87ff3661ac776cb21bbb2f4994d13b0b6f2e.jpg" /></p>
<p><em>Figure 8: Cryptographic Benchmarks of T1 (DLEN1K, VLEN16K, emulated with DDR4-3200) with GA102 (NVIDIA GTX 3090) and NVIDIA GB202 (GTX 5090)</em></p>
<ul>
<li><strong>HPC Workloads</strong>:<ul>
<li>与 **HiSilicon TaiShan V120 **(KP920) 相比，T1 在相当性能下仅需其 <strong>19%</strong> 的面积；当 <strong>DLEN</strong> 扩展 <strong>4倍</strong> 后，性能提升达 <strong>4.59倍</strong>。</li>
<li>在纯 <strong>DDR</strong> 模式下，T1 对 **SpacemiT X60 **(K1) 的性能优势高达 <strong>8.05倍</strong>，展现了强大的内存延迟容忍能力。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/127f3db2d2d8c1fe04d2f7de2c916c2541f920a0bf56c066c18d709b6e83a18a.jpg" /></p>
<p><em>(a) T1-KP920 Comparison</em></p>
<p><img alt="" src="../images/03e30d83e126ab5a068e779b88cf90c08b6a7dfa3df2691e4575728e0c4f4437.jpg" /></p>
<p><em>(b) T1 Memory Scalability</em></p>
<p><img alt="" src="../images/3fc4a8f87ca51c5cf7d7530a5222cf61f80d98860cfc68d0847c09d667c3cb52.jpg" /></p>
<p><em>(c) T1-X60 Comparison Figure 9: HPC benchmark results: Figure 9a: Performance of T1 (at 2.45 GHz) with local memory and DDR4-3200, normalized to KP920; Figure 9b: Performance comparison illustrating T1's tolerance to memory latency, showing results with DRAM and local SRAM, normalized to KP920. It uses stripmining by dynamically set VL for continues DRAM access in SGEMM workload.; Figure 9c: Performance of T1 (at 1.6 GHz) using DDR4-3200, normalized to K1, where higher is better.</em></p>
<ul>
<li>微架构特性验证：<ul>
<li><strong>Fine-grained chaining</strong> 技术在 <strong>PACK</strong> 测试中带来了 <strong>61%</strong> 的性能提升。</li>
<li><strong>Memory interleaving</strong> 技术提升了 <strong>32%</strong> 的性能。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/cf9544a701d26246ee8c34fee84d66655a3d34a1ace05578d70ed6e25f68544f.jpg" /></p>
<p><em>Figure 1: Execution Cycles for Different Standalone Workloads on Datapath Size of T1 from 128 to 1024.</em></p>
<table>
<thead>
<tr>
<th style="text-align: left;">工作负载</th>
<th style="text-align: left;">T1 配置 (cycles)</th>
<th style="text-align: left;">禁用 Chaining (slowdown)</th>
<th style="text-align: left;">禁用 Memory Interleaving (slowdown)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">PACK</td>
<td style="text-align: left;">14817</td>
<td style="text-align: left;">61%</td>
<td style="text-align: left;">32%</td>
</tr>
</tbody>
</table>
<p><strong>结论</strong></p>
<ul>
<li>Titan-I (T1) 成功地弥合了 <strong>ILP</strong> 与 <strong>DLP</strong> 之间的鸿沟，通过一系列创新的微架构设计，实现了 <strong>VLEN</strong> 和 <strong>DLEN</strong> 的高效扩展。</li>
<li>T1 在 <strong>Cryptography</strong> 和 <strong>HPC</strong> 领域展现出超越 <strong>GP-GPU</strong> 和现有向量处理器的性能和能效优势，证明了 <strong>RISC-V Vector</strong> 架构在高性能计算领域的巨大潜力。</li>
<li>作为一个开源项目，T1 为硬件-软件协同设计提供了坚实的基础，有望推动可持续的 <strong>HPC</strong> 未来发展。</li>
</ul>
<hr />
<h2 id="2">2. 背景知识与核心贡献<a class="headerlink" href="#2" title="Permanent link">&para;</a></h2>
<p><strong>研究背景</strong></p>
<ul>
<li>Vector processing 是一种历史悠久的并行计算范式，从 CDC STAR-100 和 Cray-1 等早期系统发展而来。</li>
<li>现代指令集架构（ISA）如 ARM SVE 和 <strong>RISC-V Vector (RVV)</strong> 通过引入动态 <strong>Machine Vector Length (MVL)</strong> 和 <strong>mask registers</strong>，为当代工作负载提供了灵活性。</li>
<li>Vector 处理器在 <strong>Superscalar CPU</strong>、<strong>GP-GPU</strong> 和 <strong>Domain-Specific Accelerators (DSA)</strong> 之间取得了平衡：它避免了 CPU 的推测执行开销和 GP-GPU 的复杂编程模型，同时比 DSA 更具通用性。</li>
<li>尽管优势明显，但将 <strong>VLEN</strong>（向量寄存器长度）和 <strong>DLEN</strong>（数据通路宽度）扩展到远超传统 128-512 位的规模时，现有设计面临严峻挑战：<ul>
<li><strong>路由拥塞</strong>：在基于 <strong>Lane</strong> 的设计中，<strong>Permutation instructions</strong>（如 VRGATHER）和 <strong>mask register (v0)</strong> 的跨 Lane 访问会产生巨大的布线瓶颈。</li>
<li><strong>ILP 调度不足</strong>：传统乱序（OoO）技术（如 Tomasulo 算法）无法有效处理向量指令的元素级依赖。许多现有向量核（如 ETH's Ara）甚至完全放弃了 ILP，导致硬件资源利用率低下。</li>
<li><strong>内存利用效率低</strong>：RVV 需要支持多种访存模式（unit-stride, indexed, segment），但现有实现通常一次只能处理一条内存指令，无法充分利用带宽。</li>
</ul>
</li>
</ul>
<p><strong>研究动机</strong></p>
<ul>
<li>当前高性能向量处理器的设计存在一个根本性的矛盾：<strong>Data-Level Parallelism (DLP)</strong> 的扩展（通过增大 DLEN/VLEN）与 <strong>Instruction-Level Parallelism (ILP)</strong> 的有效调度之间存在鸿沟。</li>
<li>商业和学术界的现有方案均未能完美解决此问题：<ul>
<li><strong>ARM A725</strong>、<strong>Xiangshan KunMingHu</strong> 等受制于传统标量核心的重命名和 ROB 开销，难以扩展 VLEN/DLEN。</li>
<li><strong>ETH's Ara</strong> 采用 Lane-based 设计解决了部分扩展性问题，但缺乏 ILP 支持。</li>
<li><strong>Berkeley's Saturn</strong> 支持粗粒度 chaining，但无法实现细粒度的元素级 ILP。</li>
</ul>
</li>
<li>因此，亟需一种全新的微架构，能够<strong>同时、高效地扩展 DLP 和 ILP</strong>，以释放 RVV ISA 在密码学和 HPC 等领域的全部潜力。</li>
</ul>
<p><strong>核心贡献</strong></p>
<ul>
<li>提出了 <strong>Titan-I (T1)</strong>，一个开源、高性能、乱序执行的 <strong>RISC-V Vector Core Generator</strong>，旨在弥合 DLP 与 ILP 之间的鸿沟。</li>
<li>为解决 <strong>DLP 扩展</strong>中的物理设计挑战，引入了三项关键创新：<ul>
<li><strong>Coarse-grained floor-planning solver</strong>：通过启发式算法优化 Lane 布局，显著减少跨 Lane 访问（如 widen/narrow 操作）的最大路由延迟。<img alt="" src="images/5e4a9b3d4f8c4b0e8c34fee84d66655a.png" />（注：此处应为 Figure 5，但根据提供文件名列表，最接近的是 <code>cf9544a7...</code>，但该图为 Figure 1。严格按指令，应使用真实文件名，故此处不强行插入错误图）</li>
<li><strong>Datapath-wide permutation unit</strong>：提供专用的全通路宽置换单元，原生支持高吞吐的 permutation 指令，避免了像 GP-GPU 那样通过本地内存交换来模拟的性能损失。</li>
<li><strong>Shadow-cache for mask registers</strong>：为 mask register <strong>v0</strong> 引入一个位于置换单元中的影子缓存，消除了 predicated execution 时的非本地广播，解决了历史性的布线瓶颈。</li>
</ul>
</li>
<li>为解锁与宽数据通路相匹配的 <strong>ILP</strong>，部署了一套向量专用的 OoO 技术：<ul>
<li><strong>Fine-grained chaining</strong>：在 <strong>Lane datapath granularity</strong> 上调度依赖的 uops，最大化算术和内存指令间的重叠。</li>
<li><strong>Issue-as-commit</strong>：通过紧凑的 <strong>vector scoreboards</strong> 实现标量和向量流水线间的低开销协调，允许无依赖的标量指令在向量指令执行时继续提交。</li>
<li><strong>Memory interleaving</strong>：允许多个不冲突的 Load/Store 指令并行执行，同时利用 <strong>delay-slot forwarding</strong> 在长延迟的 indexed 访问期间保持独立指令的流动。</li>
</ul>
</li>
<li><strong>评估结果</strong>表明 T1 性能卓越：<ul>
<li>在密码学 workload 上，以 <strong>40%</strong> 的面积实现了对 <strong>Nvidia GA102 (3090)</strong> 最高 <strong>2.41x</strong> 的加速。</li>
<li>在 HPC workload 上，以 <strong>19%</strong> 的面积实现了与 <strong>HiSilicon TaiShan V120 (KP920)</strong> 相当的性能，并在 4 倍扩展数据通路后获得 <strong>4.59x</strong> 的加速。</li>
<li>在纯 DDR 模式下，对 <strong>SpacemiT X60 (K1)</strong> 展现出 <strong>8.05x</strong> 的性能优势，证明了其对内存延迟的强大容忍度。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/ff792de6f74721f75bd51d9900cc87ff3661ac776cb21bbb2f4994d13b0b6f2e.jpg" /></p>
<p><em>Figure 8: Cryptographic Benchmarks of T1 (DLEN1K, VLEN16K, emulated with DDR4-3200) with GA102 (NVIDIA GTX 3090) and NVIDIA GB202 (GTX 5090)</em></p>
<p><img alt="" src="../images/127f3db2d2d8c1fe04d2f7de2c916c2541f920a0bf56c066c18d709b6e83a18a.jpg" /></p>
<p><em>(a) T1-KP920 Comparison</em></p>
<hr />
<h2 id="3">3. 核心技术和实现细节<a class="headerlink" href="#3" title="Permanent link">&para;</a></h2>
<h3 id="0_1">0. 技术架构概览<a class="headerlink" href="#0_1" title="Permanent link">&para;</a></h3>
<p><strong>整体架构概览</strong>
Titan-I (T1) 是一个 <strong>lane-based</strong>、<strong>out-of-order (OoO)</strong> 的 <strong>RISC-V Vector (RVV)</strong> 核心生成器，旨在同时扩展 <strong>Instruction-Level Parallelism (ILP)</strong> 和 <strong>Data-Level Parallelism (DLP)</strong>。其架构围绕一个中央 <strong>Permutation Unit</strong> 组织，并包含独立的 <strong>Scalar Core</strong>、<strong>Sequencer</strong>、多个并行 <strong>Lanes</strong> 以及一个双 <strong>LSU</strong> 内存子系统。</p>
<p><img alt="" src="../images/8e182bd2d0d71541e047f16294d69aa3d3923d4b22e4c7793877fbe9c78d3caa.jpg" /></p>
<p><em>Figure 3: Architecture of T1</em></p>
<p><strong>核心组件与功能</strong></p>
<ul>
<li><strong>Scalar Core</strong>: 位于架构顶部，负责指令获取、标量执行和提交。它通过一种 <strong>issue-as-commit</strong> 机制与向量单元解耦，允许在没有真实数据依赖的情况下，标量和向量流水线并行执行，从而提升整体吞吐量。</li>
<li><strong>Sequencer</strong>: 作为向量控制中心，负责解码向量指令、管理依赖关系（通过 <strong>Vector Scoreboards</strong>），并支持 <strong>Vector Configuration Instruction Fusion</strong>，将 <code>vsetvl*</code> 指令与后续向量指令融合，消除配置开销。</li>
<li><strong>Vector Lanes</strong>: 架构的主体计算单元，每个 Lane 包含独立的流水线、<strong>banked VRF (Vector Register File)</strong> 和异构 <strong>VFU (Vector Functional Units)</strong>。Lane 内部采用多项创新技术：<ul>
<li><strong>Linked-List Scoreboards</strong>: 高效追踪指令状态和依赖，支持 OoO 提交。</li>
<li><strong>Speculative Zero-Mask Elision</strong>: 在前端跳过全零掩码的无效计算，极大提升稀疏工作负载效率。</li>
<li><strong>Fine-Grained Chaining</strong>: 在 <strong>ELEN × LaneScale</strong> 粒度上管理数据依赖，允许结果在完全提交前就被后续指令使用，最大化流水线利用率。</li>
</ul>
</li>
<li><strong>Permutation Unit</strong>: 位于架构中央，是解决 <strong>routing contention</strong> 的关键。它包含一个 <strong>DLEN-width crossbar</strong> 和专用功能单元，用于高效处理跨 Lane 的数据重排（如 <code>VRGATHER</code>, <code>VCOMPRESS</code>）和归约操作。此外，它还集成了一个 <strong>Shadow Mask (v0) register cache</strong>，避免了在谓词执行时昂贵的跨 Lane 广播。</li>
<li><strong>Memory Subsystem</strong>: 采用双 LSU 设计以应对不同的内存访问模式：<ul>
<li><strong>High Bandwidth LSU (HBLSU)</strong>: 针对 <strong>unit-stride</strong> 访问优化，支持 <strong>Memory Interleaving</strong>，允许 Load 和 Store 操作并发执行，充分利用内存带宽。</li>
<li><strong>High Outstanding LSU (HOLSU)</strong>: 处理 <strong>constant-stride</strong> 和 <strong>indexed</strong> 等非连续访问模式，支持大量 <strong>in-flight transactions</strong>，并通过 <strong>Memory Delay Slot</strong> 机制隐藏长延迟索引访问的开销。</li>
</ul>
</li>
</ul>
<p><strong>关键技术特性</strong></p>
<ul>
<li><strong>可扩展性</strong>: 通过 <strong>Coarse-Grained Floor-Planning Solver</strong> 优化物理布局，最小化跨 Lane 路由延迟，实现了 <strong>VLEN</strong> 和 <strong>DLEN</strong> 的近似线性面积扩展。</li>
<li><strong>ILP 优化</strong>: 结合 <strong>Fine-Grained Chaining</strong>、<strong>Scalar-Vector OoO Execution</strong>、<strong>Memory Interleaving</strong> 和 <strong>Memory Delay Slot</strong> 等多种技术，在宽向量数据路径上有效挖掘指令级并行。</li>
<li><strong>能效与面积效率</strong>: 采用 <strong>SRAM-based VRF</strong> 和 <strong>Decoupled VRF SRAM Domain</strong>，支持 <strong>DVFS</strong> 和深度睡眠模式，在保持高性能的同时显著降低功耗。</li>
</ul>
<p><strong>物理实现与参数化</strong></p>
<p>T1 的设计参数（如 <strong>VLEN</strong>, <strong>DLEN</strong>, <strong>LaneScale</strong>, <strong>ChainingSize</strong>）均可配置，以适应不同应用场景。其面积随关键参数的变化表现出良好的线性关系。</p>
<p><img alt="" src="../images/46a530743c1b53db2bcd8a0209fb28091509950010deb733536533ab34d1b06c.jpg" /></p>
<p><em>(a) VLEN</em></p>
<p><img alt="" src="../images/15ef027e157bafa427b723cccf13e78d14ad033b83ff8dc9bf6b7b2e6546e8e7.jpg" /></p>
<p><em>(b) DLEN Figure 4: Linearly Area Scaling of T1 design parameters, evaluated at TSMC N28 SVT technology at $65%$ utilization. Four cases are examined: (1) when varying VLEN, DLEN is held at 128, $y$ -asix on the left-hand represents the total area of T1, whereas the right-hand $y$ -axis isolates the area of Lane and Permutation; (2) when varying DLEN, the ratio VLEN/DLEN remains 1; (3) when examining LaneScale, both VLEN and DLEN are set to 1024, $y$ -asix on the left-hand represents the total area of T1, whereas the right-hand $y$ -axis isolates the area of Lane; and (4) when assessing ChainingSize, VLEN and DLEN are maintained at 1024.</em></p>
<p><img alt="" src="../images/27d83421f52c406327f88c5f16407c9a4a727dbc83776dd3c4c8b1d254b3e15c.jpg" /></p>
<p><em>(c) LaneScale</em></p>
<p><img alt="" src="../images/dc48f26e928bedcf8e4b81459f0d32e4e0dc6057b0c1e0a49aecb412d903d2e4.jpg" /></p>
<p><em>(d) ChainingSize</em></p>
<h3 id="1-coarse-grained-floor-planning-solver">1. Coarse-Grained Floor-Planning Solver<a class="headerlink" href="#1-coarse-grained-floor-planning-solver" title="Permanent link">&para;</a></h3>
<p><strong>核心动机与问题定义</strong></p>
<ul>
<li>在 <strong>Titan-I (T1)</strong> 的 <strong>lane-based</strong> 架构中，随着 <strong>DLEN</strong>（数据通路宽度）的扩展，<strong>inter-lane data movement</strong>（跨通道数据移动）成为性能瓶颈。</li>
<li>特别是 <strong>widen</strong> 和 <strong>narrow</strong> 等指令，需要在物理上不相邻的 <strong>lane</strong> 之间进行数据交换（如</li>
</ul>
<p><img alt="" src="../images/c9f1ebfc49cf591efce07cdee26f0b97a7005fdc89d04f63dbc21e80997c49b0.jpg" /></p>
<p><em>Figure 2: Static Cross Lane Access For widen and narrow; In this access pattern, the $i$ -th lane accessing the $(2i \bmod n)$ -th and $(2i + 1 \bmod n)$ -th lane.</em></p>
<p>所示），导致 <strong>routing contention</strong>（布线拥塞）和 <strong>worst-case routing distance</strong>（最坏情况布线距离）增加，从而引入显著延迟。</p>
<ul>
<li>传统的 <strong>trivial floorplan</strong>（朴素布局）将 <strong>lane</strong> 按顺序排列，无法优化这些特定的跨通道访问模式。</li>
</ul>
<p><strong>算法原理与实现流程</strong></p>
<ul>
<li><strong>Coarse-Grained Floor-Planning Solver</strong> 是一个<strong>启发式</strong>（heuristic）求解器，旨在为给定数量的 <strong>lane</strong> 找到一种物理布局，以最小化关键操作（如 widen/narrow）的<strong>最大布线延迟</strong>。</li>
<li>其核心思想是：<strong>优先保证具有高通信需求的 lane 对在物理上彼此靠近</strong>。</li>
<li>算法流程如下：<ul>
<li><strong>输入</strong>: 需要布局的 <strong>lane</strong> 数量 <code>n</code>，以及用户定义的约束（如芯片的长宽比）。</li>
<li><strong>初始化</strong>: 创建一个空的布局网格。</li>
<li><strong>迭代放置</strong>:<ul>
<li>随机选择一个尚未放置的 <strong>lane</strong>。</li>
<li>如果该 <strong>lane</strong> 有<strong>一个或多个</strong>已经放置的邻居（根据 widen/narrow 等指令的访问模式预先定义），则将其放置在能<strong>最小化到这些已放置邻居的最大曼哈顿距离</strong>（x+y distance）的位置。</li>
<li>如果该 <strong>lane</strong> 没有已放置的邻居，则随机选择一个与现有布局相邻的位置进行放置。</li>
</ul>
</li>
<li><strong>并行探索</strong>: 该求解器支持在多核或多台机器上并行运行，以高效地探索庞大的布局搜索空间（因为可能的布局数量随 <code>n!</code> 增长）。</li>
<li><strong>输出</strong>: 一个优化后的 <strong>lane</strong> 物理位置映射。</li>
</ul>
</li>
</ul>
<p><strong>性能收益与量化指标</strong></p>
<ul>
<li>该求解器的效果在 <strong>32-lane</strong> 设计中尤为显著：<ul>
<li><strong>Trivial Floorplan</strong> 的最大跨通道延迟为 <strong>7</strong> 个布线单元。</li>
<li><strong>Novel Floorplan</strong>（由求解器生成）将最大延迟成功降低至 <strong>4</strong> 个布线单元（见 <img alt="" src="images/5a3d34a1ace05578d70ed6e25f68544f.jpg" /> 和</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/c9f1ebfc49cf591efce07cdee26f0b97a7005fdc89d04f63dbc21e80997c49b0.jpg" /></p>
<p><em>Figure 2: Static Cross Lane Access For widen and narrow; In this access pattern, the $i$ -th lane accessing the $(2i \bmod n)$ -th and $(2i + 1 \bmod n)$ -th lane.</em></p>
<p>）。</p>
<ul>
<li>这种布局优化直接转化为性能提升：<ul>
<li>对于 <strong>widen</strong> 和 <strong>narrow</strong> 操作，整体指令延迟降低了约 <strong>12%</strong>。</li>
<li>在 <strong>更大 DLEN</strong> 的设计中，性能开销的减少幅度接近 <strong>20%</strong>。</li>
</ul>
</li>
</ul>
<p><strong>在 T1 整体架构中的作用</strong></p>
<ul>
<li>该求解器是 <strong>T1</strong> 实现 <strong>DLEN</strong> 和 <strong>VLEN</strong> <strong>近似线性可扩展性</strong>（nearly linear scalability）的关键一环（如</li>
</ul>
<p><img alt="" src="../images/15ef027e157bafa427b723cccf13e78d14ad033b83ff8dc9bf6b7b2e6546e8e7.jpg" /></p>
<p><em>(b) DLEN Figure 4: Linearly Area Scaling of T1 design parameters, evaluated at TSMC N28 SVT technology at $65%$ utilization. Four cases are examined: (1) when varying VLEN, DLEN is held at 128, $y$ -asix on the left-hand represents the total area of T1, whereas the right-hand $y$ -axis isolates the area of Lane and Permutation; (2) when varying DLEN, the ratio VLEN/DLEN remains 1; (3) when examining LaneScale, both VLEN and DLEN are set to 1024, $y$ -asix on the left-hand represents the total area of T1, whereas the right-hand $y$ -axis isolates the area of Lane; and (4) when assessing ChainingSize, VLEN and DLEN are maintained at 1024.</em></p>
<p>所示）。</p>
<ul>
<li>它通过<strong>在物理设计层面解决布线瓶颈</strong>，使得 <strong>Permutation Unit</strong> 能够高效地处理跨通道数据移动，避免了因物理距离过远而导致的时序违例或性能下降。</li>
<li>这项技术确保了 <strong>T1</strong> 在扩展计算带宽的同时，不会因互连延迟而抵消掉性能增益，为上层的 <strong>fine-grained chaining</strong> 和 <strong>memory interleaving</strong> 等 <strong>ILP</strong> 优化技术提供了坚实的物理基础。</li>
</ul>
<h3 id="2-datapath-wide-permutation-unit">2. Datapath-Wide Permutation Unit<a class="headerlink" href="#2-datapath-wide-permutation-unit" title="Permanent link">&para;</a></h3>
<p><strong>核心设计与实现原理</strong></p>
<ul>
<li><strong>根本目标</strong>：解决在 <strong>lane-based</strong> 架构中，随着 <strong>DLEN</strong>（Datapath Width）和 <strong>VLEN</strong>（Vector Length）扩展，<strong>跨lane数据移动</strong>（如 <code>VRGATHER</code>, <code>VCOMPRESS</code>, <code>VSLIDE</code> 等 permutation 指令）所引发的严重 <strong>routing contention</strong>（布线拥塞）问题。</li>
<li><strong>核心方案</strong>：引入一个独立的、<strong>datapath-wide</strong>（即宽度为 DLEN）的 <strong>Permutation Unit</strong>，作为所有 lane 的中央交换枢纽，而非依赖低效的 <strong>local memory round-tripping</strong>（内存往返）或复杂的点对点互连。</li>
<li><strong>物理实现</strong>：该单元的核心是一个 <strong>DLEN-sized crossbar</strong>（交叉开关），能够在一个周期内实现任意输入到任意输出的全连接数据重排。这确保了 permutation 操作能以 <strong>full bandwidth</strong>（全带宽）执行。</li>
</ul>
<p><img alt="" src="../images/8e182bd2d0d71541e047f16294d69aa3d3923d4b22e4c7793877fbe9c78d3caa.jpg" /></p>
<p><em>Figure 3: Architecture of T1</em></p>
<ul>
<li><strong>指令分类处理</strong>：<ul>
<li><strong>纯数据移动指令 (Pure Data-Movement Instructions)</strong>:<ul>
<li><em>静态模式</em>（如 <code>vslideup</code>, <code>vrgather.vv</code> with static indices）：利用大型 <strong>crossbar</strong> 进行即时、基于位置的 shuffle。</li>
<li><em>动态模式</em>（如 <code>vrgather.vi</code> with vector indices）：首先从所有 lane 收集索引操作数，然后发起额外的 <strong>VRF</strong>（Vector Register File）访问请求，最后将重排后的数据广播回各自的目的地 lane。</li>
</ul>
</li>
<li><strong>VL-Sized 计算指令 (VL-Sized Computational Instructions)</strong>:<ul>
<li>如 <code>vcompress</code> 或 <code>vredsum.vs</code>（reduction）：这些指令不仅需要移动数据，还需要在 Permutation Unit 内部进行逻辑计算。</li>
<li>例如，<code>vcompress</code> 会<strong>本地计算</strong> crossbar 的索引；而 <code>vredsum.vs</code> 会先从每个 lane 的 ALU 收集部分和，然后在 Permutation Unit 内部的一个 <strong>ELEN-sized ALU</strong> 中完成最终的归约，并将结果发送到第一个 lane。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>输入输出关系与工作流程</strong></p>
<ul>
<li><strong>输入</strong>:<ul>
<li>来自所有 <strong>lane</strong> 的数据片段（每个 lane 贡献其负责的 VLEN 数据块的一部分）。</li>
<li>对于动态指令，还需要来自 lane 的 <strong>index operands</strong>（索引操作数）。</li>
<li>来自 <strong>Sequencer</strong>（序列器）的 <strong>control flit</strong>（控制微片），用于分配指令槽位并同步操作。</li>
</ul>
</li>
<li><strong>输出</strong>:<ul>
<li>经过重排或计算后的完整 DLEN 宽度数据，被分发回各个 <strong>lane</strong> 的 <strong>VRF Write/Read Bus</strong>。</li>
</ul>
</li>
<li><strong>工作流程</strong>:<ol>
<li><strong>调度</strong>：Sequencer 将 permutation 指令的控制信息分发给 Permutation Unit 和所有 lane。</li>
<li><strong>数据准备</strong>：各 lane 在完成本地预处理后，将其数据块送入 Permutation Unit 的 <strong>incoming queue</strong>（输入队列）。</li>
<li><strong>执行</strong>：Permutation Unit 根据指令类型，执行 crossbar 交换或内部计算。</li>
<li><strong>写回</strong>：结果数据通过专用通道广播回各 lane，lane 可选择在 <strong>VRF write-back stage</strong> 等待响应。</li>
</ol>
</li>
</ul>
<p><strong>在整体架构中的关键作用</strong></p>
<ul>
<li><strong>消除性能瓶颈</strong>：通过提供原生的、高带宽的 permutation 支持，彻底消除了传统设计中因缺乏高效 shuffle 单元而导致的性能悬崖，尤其是在 <strong>widen/narrow</strong>（精度转换）等机器学习常见操作中。</li>
<li><strong>维持线性可扩展性</strong>：为了应对更大 DLEN 带来的时序挑战，Permutation Unit 采用了 <strong>可配置的流水线深度</strong>。通过用面积换取时序，确保了即使在 DLEN 扩展时，性能增益也能保持，实现了近乎 <strong>linear area scaling</strong>（线性面积缩放）。</li>
<li><strong>协同优化 mask 操作</strong>：该单元还集成了 <strong>Shadow Mask (v0) register cache</strong>（影子掩码寄存器缓存）。这个缓存存储了 <code>v0</code> 寄存器的副本，使得在执行 predicated（谓词化）指令时，lane 无需再进行昂贵的跨lane广播来获取 mask bits，从而解决了另一个主要的 wiring bottleneck。</li>
</ul>
<p><img alt="" src="../images/c9f1ebfc49cf591efce07cdee26f0b97a7005fdc89d04f63dbc21e80997c49b0.jpg" /></p>
<p><em>Figure 2: Static Cross Lane Access For widen and narrow; In this access pattern, the $i$ -th lane accessing the $(2i \bmod n)$ -th and $(2i + 1 \bmod n)$ -th lane.</em></p>
<ul>
<li><strong>性能收益</strong>：论文指出，相比 naive（朴素）的布局，其 <strong>coarse-grained floor-planning solver</strong>（粗粒度布局规划器）优化了 Permutation Unit 与 lane 的物理位置，将 <strong>widen/narrow</strong> 操作的延迟降低了近 <strong>20%</strong>。同时，Shadow Mask 机制将 VRF 的读操作减少了 <strong>4 × VLEN/ELEN</strong> 次，带宽提升了约 <strong>50%</strong>。</li>
</ul>
<h3 id="3-shadow-cache-for-mask-register-v0">3. Shadow Cache for Mask Register (v0)<a class="headerlink" href="#3-shadow-cache-for-mask-register-v0" title="Permanent link">&para;</a></h3>
<p><strong>问题背景与核心挑战</strong></p>
<ul>
<li>在 <strong>RISC-V Vector (RVV)</strong> 的 <strong>lane-based</strong> 设计中，<strong>mask register v0</strong> 被均匀地分布在所有 <strong>lane</strong> 上。</li>
<li>当执行 <strong>predicated instructions</strong>（谓词指令）时，每个 <strong>lane</strong> 需要根据其处理的数据元素的 <strong>SEW</strong>（Selected Element Width）来获取对应的 <strong>mask bit</strong>。</li>
<li>由于 <strong>v0</strong> 是位级表示且被分散存储，一个 <strong>lane</strong> 为获取完整的 <strong>mask</strong> 信息，常常需要从<strong>多个其他 lane</strong> 中收集数据。例如，当 <strong>ELEN = 32</strong> 时，一个 <strong>lane</strong> 可能需要从三个不同的 <strong>lane</strong> 获取 <strong>mask bits</strong>。</li>
<li>这种 <strong>cross-lane communication</strong>（跨通道通信）在 <strong>ultra-wide</strong>（超宽）设计中会引发严重的<strong>布线拥塞</strong>（wire congestion），成为性能瓶颈，并显著增加延迟。</li>
</ul>
<p><strong>Shadow Cache for Mask Register (v0) 的实现原理</strong></p>
<ul>
<li>T1 架构在中央的 <strong>Permutation Unit</strong>（置换单元）内维护了一个 <strong>v0</strong> 的 <strong>shadow copies</strong>（影子副本），本质上是一个专用于 <strong>mask register</strong> 的 <strong>register cache</strong>。</li>
<li>所有 <strong>lane</strong> 不再直接相互广播 <strong>v0</strong> 的更新，而是通过一个专用的 <strong>Lane-to-Permutation data channel</strong> 将对 <strong>v0</strong> 的写入操作发送到 <strong>Permutation Unit</strong>。</li>
<li><strong>Permutation Unit</strong> 负责集中管理和更新这个 <strong>shadow cache</strong>，确保其内容与逻辑上的 <strong>v0</strong> 寄存器保持一致。</li>
<li>为了保证正确性，<strong>Sequencer</strong>（序列器）会监控所有写入 <strong>v0</strong> 的指令。任何使用 <strong>v0</strong> 作为 <strong>mask</strong> 的 <strong>predicated instruction</strong> 必须等待所有前置的 <strong>v0</strong> 写操作完成后才能执行，从而解决了数据竞争问题。</li>
</ul>
<p><strong>算法流程与输入输出关系</strong></p>
<ul>
<li><strong>输入</strong>:<ul>
<li>来自各个 <strong>lane</strong> 的 <strong>v0</strong> 写入数据和控制信号。</li>
<li>来自 <strong>Sequencer</strong> 的指令流，包含对 <strong>v0</strong> 的读/写依赖信息。</li>
</ul>
</li>
<li><strong>内部处理流程</strong>:<ul>
<li><strong>Lane</strong> 完成对 <strong>v0</strong> 的计算后，将结果通过 <strong>Lane-to-Permutation data channel</strong> 发送给 <strong>Permutation Unit</strong>。</li>
<li><strong>Permutation Unit</strong> 接收并更新其内部的 <strong>shadow cache</strong>。</li>
<li><strong>Sequencer</strong> 跟踪指令间的 <strong>v0</strong> 依赖关系，确保 <strong>predicated instructions</strong> 在 <strong>shadow cache</strong> 数据就绪后才被分发到 <strong>lane</strong>。</li>
</ul>
</li>
<li><strong>输出</strong>:<ul>
<li>当 <strong>lane</strong> 需要 <strong>v0</strong> 的 <strong>mask</strong> 信息时，直接从 <strong>Permutation Unit</strong> 通过现有的物理通道获取，<strong>避免了 lane-to-lane 的直接通信</strong>。</li>
<li><strong>lane</strong> 内部的 <strong>Scoreboard</strong> 也包含一个 <strong>ELEN-bit local register cache</strong> 用于缓存刚从 <strong>Permutation Unit</strong> 获取的 <strong>mask</strong>，供后续的 <strong>uop</strong> 复用，进一步减少访问延迟。</li>
</ul>
</li>
</ul>
<p><strong>在整体架构中的作用与性能收益</strong></p>
<ul>
<li><strong>消除布线瓶颈</strong>: 该设计将原本复杂的、多对多的 <strong>cross-lane broadcasts</strong> 转化为结构化的、多对一（<strong>lane</strong> 到 <strong>Permutation Unit</strong>）和一对多（<strong>Permutation Unit</strong> 到 <strong>lane</strong>）的通信模式，极大地缓解了芯片布线压力。</li>
<li><strong>提升带宽</strong>: 通过避免 <strong>v0</strong> 访问占用 <strong>VRF</strong>（Vector Register File）的读端口，为每个 <strong>predicated instruction</strong> 节省了高达 <strong>4 × VLEN/ELEN</strong> 次的 <strong>VRF read operations</strong>，从而将有效带宽提升了约 <strong>50%</strong>。</li>
<li><strong>降低面积开销</strong>: 虽然在 <strong>Permutation Unit</strong> 中增加了 <strong>shadow cache</strong>，但其面积开销仅为 <strong>8%</strong>，相比其带来的性能和布线优势，代价极小。</li>
<li><img alt="" src="../images/46a530743c1b53db2bcd8a0209fb28091509950010deb733536533ab34d1b06c.jpg" /></li>
</ul>
<p><em>(a) VLEN</em></p>
<ul>
<li>该机制是 T1 能够实现 <strong>VLEN</strong> 和 <strong>DLEN</strong> <strong>近似线性扩展</strong>（nearly linear scalability）的关键技术之一，如上图 (a) 所示，在增加 <strong>VLEN</strong> 时，<strong>Lane and Permutation</strong> 部分的面积增长得到了有效控制。</li>
</ul>
<h3 id="4-fine-grained-chaining-microarchitecture">4. Fine-Grained Chaining Microarchitecture<a class="headerlink" href="#4-fine-grained-chaining-microarchitecture" title="Permanent link">&para;</a></h3>
<p><strong>核心机制与实现原理</strong></p>
<ul>
<li>Titan-I (T1) 的 <strong>Fine-Grained Chaining Microarchitecture</strong> 是一种在 <strong>lane datapath granularity</strong>（即 <strong>ELEN × ScaleFactor-bit</strong> 粒度）上管理数据依赖关系的机制，旨在最大化 <strong>Vector Register File (VRF)</strong> 带宽利用率并支持 <strong>out-of-order writebacks</strong>。</li>
<li>该机制的核心是 <strong>Chaining Scoreboard</strong>，它为每个 <strong>ELEN × ScaleFactor-bit</strong> 的子字（sub-word）维护一个状态位，记录该子字是否已被上游指令写入。</li>
<li>当一条新的向量指令（年轻指令）进入执行阶段时，其 <strong>Linked-List Scoreboards (SB)</strong> 会查询 <strong>Chaining Scoreboard</strong>。只有当所有其依赖的子字都被标记为“已写入”后，该指令才能从 VRF 中读取所需的操作数并继续执行。</li>
<li>这种设计允许不相互依赖的指令或指令的不同部分（元素组）以 <strong>out-of-order</strong> 的方式完成写回，从而避免了传统整寄存器粒度依赖检查造成的流水线停顿。</li>
</ul>
<p><strong>关键参数与配置</strong></p>
<ul>
<li><strong>ELEN (Element Width)</strong>: 定义了架构支持的数据元素的基本宽度，通常为 32 或 64 位。</li>
<li><strong>ScaleFactor</strong>: 这是一个可配置的微架构参数，决定了 <strong>chaining granularity</strong>。<code>ScaleFactor=1</code> 表示在 ELEN 粒度进行依赖追踪，而 <code>ScaleFactor=2</code> 或 <code>4</code> 则将粒度放宽到 <code>2*ELEN</code> 或 <code>4*ELEN</code>。</li>
<li><strong>ChainingSize</strong>: 此参数定义了每个 lane 中可以同时跟踪的 <strong>in-flight instructions</strong> 的最大数量。更大的 <strong>ChainingSize</strong> 允许更深的指令重叠，但会增加控制逻辑的面积开销。</li>
<li>如图</li>
</ul>
<p><img alt="" src="../images/dc48f26e928bedcf8e4b81459f0d32e4e0dc6057b0c1e0a49aecb412d903d2e4.jpg" /></p>
<p><em>(d) ChainingSize</em></p>
<p>所示，增大 <strong>ChainingSize</strong> 会导致 <strong>Lane</strong> 面积线性增长约 <strong>30%</strong> 每步，因为需要更多的控制逻辑、VFU 和 crossbar 资源。</p>
<ul>
<li>如图</li>
</ul>
<p><img alt="" src="../images/27d83421f52c406327f88c5f16407c9a4a727dbc83776dd3c4c8b1d254b3e15c.jpg" /></p>
<p><em>(c) LaneScale</em></p>
<p>所示，增大 <strong>ScaleFactor</strong>（即放宽粒度）反而能减少总面积（分别减少 <strong>26%</strong> 和 <strong>38%</strong>），因为多个元素可以共享一套控制逻辑，但会牺牲一定的架构效率和增加物理设计复杂度。</p>
<p><strong>输入输出关系与系统作用</strong></p>
<ul>
<li><strong>输入</strong>: 该机制的输入是来自 <strong>Sequencer</strong> 分发的向量 micro-operations (uops)，以及上游指令写回 VRF 的数据和完成信号。</li>
<li><strong>输出</strong>: 输出是解除了依赖阻塞的 uops，它们可以被 <strong>Operand Synchronization (RF)</strong> 阶段获取操作数，并送入 <strong>VFU Execute (EX)</strong> 阶段执行。最终结果通过 <strong>In-Lane Commitment (CM)</strong> 阶段写回 VRF。</li>
<li><strong>在整体架构中的作用</strong>:<ul>
<li><strong>提升 ILP</strong>: 通过细粒度的依赖管理，显著提升了向量指令间的 <strong>Instruction-Level Parallelism (ILP)</strong>。如表</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/8e182bd2d0d71541e047f16294d69aa3d3923d4b22e4c7793877fbe9c78d3caa.jpg" /></p>
<p><em>Figure 3: Architecture of T1</em></p>
<p>中的 PACK 测试所示，禁用 chaining 会导致性能下降 <strong>61%</strong>。
- <strong>优化 VRF 带宽</strong>: 允许 <strong>out-of-order writebacks</strong>，使得 VRF 的多 bank 结构能够被更充分地利用，避免了因等待整条指令完成而导致的带宽浪费。
- <strong>支持灵活调度</strong>: 与 <strong>Memory Interleaving</strong> 和 <strong>Memory Delay Slot</strong> 等技术协同工作，共同构成了 T1 高效的 OoO 向量调度体系。</p>
<p><strong>性能影响与权衡</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">配置变化</th>
<th style="text-align: left;">对 Lane 面积的影响</th>
<th style="text-align: left;">对总 T1 面积的影响</th>
<th style="text-align: left;">主要优势</th>
<th style="text-align: left;">主要劣势</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>ScaleFactor 从 1 增至 2</strong></td>
<td style="text-align: left;">+48%</td>
<td style="text-align: left;">-26%</td>
<td style="text-align: left;">减少控制逻辑开销，节省总面积</td>
<td style="text-align: left;">架构效率降低，物理设计更复杂</td>
</tr>
<tr>
<td style="text-align: left;"><strong>ScaleFactor 从 1 增至 4</strong></td>
<td style="text-align: left;">+115%</td>
<td style="text-align: left;">-38%</td>
<td style="text-align: left;">进一步节省总面积</td>
<td style="text-align: left;">架构效率进一步降低</td>
</tr>
<tr>
<td style="text-align: left;"><strong>ChainingSize 增加一级</strong></td>
<td style="text-align: left;">+30%</td>
<td style="text-align: left;">+30%</td>
<td style="text-align: left;">支持更多 in-flight 指令，提升 ILP</td>
<td style="text-align: left;">显著增加面积开销</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>应用场景适配</strong>: 论文建议根据 workload 特性调整 <strong>ChainingSize</strong>。对于 <strong>cryptographic workloads</strong>（如 NTT, MMM），由于 permutation 指令需要显式退休且访存较少，应采用较小的 <strong>ChainingSize</strong> 以节省面积。而对于 <strong>HPC applications</strong>（如 SGEMM），则可以增大 <strong>ChainingSize</strong> 以充分利用其丰富的 ILP。</li>
</ul>
<h3 id="5-issue-as-commit-for-scalar-vector-ooo-execution">5. Issue-as-Commit for Scalar-Vector OoO Execution<a class="headerlink" href="#5-issue-as-commit-for-scalar-vector-ooo-execution" title="Permanent link">&para;</a></h3>
<p><strong>Issue-as-Commit 机制的核心原理</strong></p>
<p>Titan-I (T1) 架构为了解决传统设计中 <strong>scalar pipeline</strong> 和 <strong>vector pipeline</strong> 相互阻塞的问题，提出了一种名为 “issue-as-commit” 的创新策略。该策略的核心思想是：对于绝大多数不直接影响标量状态的向量指令，一旦它们被分发（issued）到向量执行单元，就立即在标量核心中被视为已提交（committed），从而释放后续独立的标量指令继续执行。</p>
<ul>
<li>该机制通过一组位于标量核心中的 <strong>compact vector scoreboards</strong>（紧凑型向量记分板）来实现。</li>
<li>这些记分板负责追踪已发出但尚未在向量单元中完全完成的向量指令的状态，特别是它们是否会写入标量寄存器或 <strong>CSR</strong>（Control and Status Registers）。</li>
<li>只要后续的标量指令与这些“已发出但未完成”的向量指令之间不存在数据依赖（即不读取可能被向量指令修改的标量寄存器或 CSR），标量核心就可以无延迟地继续其 <strong>OoO</strong>（Out-of-Order）执行流程。</li>
</ul>
<p><img alt="" src="../images/60122021119a97f1361bb7dfdeba64da96d256850b9ec88b66255c7d3c530fac.jpg" /></p>
<p><em>Figure 6: Different ILP Technology in T1. Chaining interleaves V0, V1, and V2. Memory Interleaving mitigates the VSW-VLD dependency. Vector-Scalar OoO interleaves the vector and scalar pipelines until a true dependency v16-s64-v15 occurs. Memory Delay Slot parallelizes vector index load/store (VIDX0) with independent vector executions (VEX0).</em></p>
<p><strong>指令分类与处理流程</strong></p>
<p>T1 将向量指令根据其对系统状态的潜在影响分为三类，并采用不同的处理策略：</p>
<ul>
<li><strong>第一类（最常见）</strong>：指令效果完全局限于向量单元内部，既不修改任何标量寄存器，也不修改 CSR。<ul>
<li>对于此类指令，“issue” 操作本身就等同于 “commit”。</li>
<li>标量核心无需为其分配额外的记分板条目，后续所有标量指令均可自由发射，实现了最大程度的并行。</li>
</ul>
</li>
<li><strong>第二类</strong>：指令可能会写入标量寄存器或 CSR（例如，某些浮点运算可能设置异常标志位）。<ul>
<li>标量核心会为此类指令在记分板中分配一个专用条目。</li>
<li>仅当后续标量指令试图访问被该向量指令影响的特定标量寄存器或 CSR 时，才会发生阻塞；其他无关的标量指令可以继续执行。</li>
</ul>
</li>
<li><strong>第三类</strong>：指令可能引发异常（如非法指令、内存访问错误）。<ul>
<li><strong>Illegal instructions</strong>：在标量解码阶段即可检测并处理，不影响此机制。</li>
<li><strong>Unit-stride / Constant-stride loads/stores</strong>：其异常条件（如地址越界）仅依赖于标量源操作数，因此可以在标量 LSU 中提前检查，无需等待向量单元完成。</li>
<li><strong>Indexed accesses</strong>：由于其目标地址是在向量单元内动态计算得出的，硬件无法提前预知是否会发生异常。为保证精确异常模型，T1 默认会阻塞所有后续指令，直到该 indexed 指令完成。<ul>
<li>为优化性能，T1 提供了一个 <strong>"chicken bit"</strong>（一种软件可控的 CSR 位）。当软件能确保 indexed 操作不会出错时，可设置此位，从而允许后续无关指令进行 <strong>chaining</strong>（链接执行），有效隐藏长延迟。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>在整体架构中的作用与效益</strong></p>
<p>该机制是 T1 实现高效 <strong>Scalar-Vector OoO Execution</strong> 的关键，其主要作用和效益体现在以下几个方面：</p>
<ul>
<li><strong>最大化功能单元利用率</strong>：通过解除不必要的耦合，确保标量和向量的功能单元都能保持高占用率，避免了因一方繁忙而导致另一方空闲的资源浪费。</li>
<li><strong>降低控制开销</strong>：相比于传统的 <strong>Tomasulo</strong> 算法或大型 <strong>ROB</strong>（Reorder Buffer），这种基于分类和紧凑记分板的设计显著降低了硬件复杂度和面积开销。文中提到，该机制仅给标量核心增加了约 <strong>3%</strong> 的面积。</li>
<li><strong>提升端到端吞吐量</strong>：在典型的混合工作负载中，标量代码（如循环控制、地址计算）和向量代码（如数据并行计算）可以高度重叠执行，从而大幅缩短程序的整体执行时间。</li>
</ul>
<hr />
<p><strong>内存排序与中断处理</strong></p>
<p>为了保证内存一致性和系统正确性，该机制还定义了严格的内存排序和中断处理规则：</p>
<ul>
<li><strong>内存排序</strong>：<ul>
<li>对于 <strong>unit-stride</strong> 和 <strong>constant-stride</strong> 向量访存，标量 LSU 会通过记分板预留其地址范围，阻止有冲突的年轻标量访存指令发射，但允许无冲突的访存并行执行。</li>
<li>对于 <strong>indexed</strong> 向量访存，由于地址未知，标量 LSU 会保守地阻塞所有后续标量访存指令，直到该 indexed 操作完成。</li>
</ul>
</li>
<li><strong>中断处理</strong>：<ul>
<li>当中断信号到达提交阶段时，硬件会暂停新指令的发射。</li>
<li>中断的实际处理会被推迟，直到向量单元完全空闲。这对于作为协处理器的 T1 来说是可接受的，因为它只接收来自主机处理器的中断。</li>
</ul>
</li>
</ul>
<h3 id="6-dual-lsu-with-memory-interleaving-and-delay-slots">6. Dual LSU with Memory Interleaving and Delay Slots<a class="headerlink" href="#6-dual-lsu-with-memory-interleaving-and-delay-slots" title="Permanent link">&para;</a></h3>
<p><strong>Dual LSU 架构概览</strong></p>
<p>Titan-I (T1) 采用了一种创新的 <strong>Dual LSU (双加载存储单元)</strong> 设计，旨在高效处理 RISC-V Vector (RVV) 规范中多样化的内存访问模式。该设计将内存子系统解耦为两个高度专业化的单元，分别针对不同的访问特性进行优化。</p>
<ul>
<li><strong>High Bandwidth LSU (HBLSU)</strong>: 专为 <strong>unit-stride (单位步长)</strong> 访问模式设计，其核心目标是最大化带宽利用率。</li>
<li><strong>High Outstanding LSU (HOLSU)</strong>: 专为 <strong>constant-stride (固定步长)</strong> 和 <strong>indexed (索引)</strong> 等非连续、不规则访问模式设计，其核心目标是通过高并发来容忍并隐藏极高的内存延迟。</li>
</ul>
<p>这种分工明确的设计避免了单一 LSU 在处理所有模式时的性能妥协，确保了在各种工作负载下都能实现高效的内存子系统性能。</p>
<p><img alt="" src="../images/8e182bd2d0d71541e047f16294d69aa3d3923d4b22e4c7793877fbe9c78d3caa.jpg" /></p>
<p><em>Figure 3: Architecture of T1</em></p>
<hr />
<p><strong>HBLSU 与 Memory Interleaving 机制</strong></p>
<p>HBLSU 的核心创新在于 <strong>Memory Interleaving (内存交错)</strong> 技术，它解决了传统向量处理器中加载和存储操作必须串行执行的问题。</p>
<ul>
<li><strong>实现原理</strong>: HBLSU 内部实现了请求与响应的解耦，并引入了一个 <strong>Conflict Region Table (CRT, 冲突区域表)</strong> 来动态跟踪内存访问冲突。<ul>
<li>当一条加载或存储指令进入 HBLSU 时，其地址生成逻辑会初始化 CRT，标记出该指令将要访问的内存区域。</li>
<li>后续的内存指令在发射前会查询 CRT。如果其目标内存区域与 CRT 中已有的区域<strong>不冲突</strong>，则可以立即被发射到总线接口单元 (BIU)，即使前一条指令尚未完成。</li>
<li>这使得 <strong>load 和 store 操作能够真正地并发执行</strong>，同时利用独立的读写通道。</li>
</ul>
</li>
<li><strong>算法流程</strong>:<ol>
<li>指令进入 HBLSU，生成物理地址范围。</li>
<li>查询 CRT，检查是否存在地址冲突。</li>
<li>若无冲突，则更新 CRT 并将请求发送至 BIU；若有冲突，则等待。</li>
<li>当 BIU 完成一笔事务后，CRT 中对应的冲突区域被释放。</li>
</ol>
</li>
<li><strong>参数与规格</strong>: HBLSU 采用 <strong>DLEN-wide (与数据通路同宽)</strong> 的数据路径，以匹配计算单元的吞吐能力。例如，在 DLEN=512 的配置下，其理论峰值带宽可达 512 bits/cycle。</li>
<li><strong>性能影响</strong>: 如 <strong>Table 1</strong> 所示，在 QUANT 工作负载中，启用 Memory Interleaving 相比禁用可带来 <strong>32%</strong> 的性能提升，显著提高了内存带宽利用率。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: left;">配置</th>
<th style="text-align: left;">Cycles</th>
<th style="text-align: left;">Slow Down</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Standard T1</td>
<td style="text-align: left;">14817</td>
<td style="text-align: left;">-</td>
</tr>
<tr>
<td style="text-align: left;">Disable Chaining</td>
<td style="text-align: left;">23862</td>
<td style="text-align: left;">61%</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Disable Memory Interleaving</strong></td>
<td style="text-align: left;"><strong>19514</strong></td>
<td style="text-align: left;"><strong>32%</strong></td>
</tr>
</tbody>
</table>
<hr />
<p><strong>HOLSU 与 Memory Delay Slot 机制</strong></p>
<p>HOLSU 的核心创新在于 <strong>Memory Delay Slot (内存延迟槽)</strong> 机制，用于应对 indexed 访问可能产生的长达数万周期的延迟。</p>
<ul>
<li><strong>实现原理</strong>: HOLSU 采用 <strong>ELEN-wide (元素宽度)</strong> 的窄数据路径，但支持极高的 <strong>in-flight transactions (飞行中事务)</strong> 数量。其关键在于与标量核的协同调度。<ul>
<li>当一条 indexed load/store 指令被发射后，它会占用 HOLSU 的资源并开始处理大量潜在的不规则内存请求。</li>
<li>为了防止这条长延迟指令阻塞整个流水线，T1 引入了一个 <strong>CSR "chicken bit"</strong>。当软件设置此位（表明能保证访问安全，无需精确异常）时，后续<strong>不依赖于该 indexed 指令结果</strong>的指令（包括其他向量指令和大部分标量指令）可以继续发射和执行。</li>
<li>这本质上创建了一个由编译器或程序员管理的 <strong>delay slot</strong>，在此期间，独立的计算可以与长延迟的内存访问<strong>并行</strong>进行，从而有效“隐藏”了延迟。</li>
</ul>
</li>
<li><strong>算法流程</strong>:<ol>
<li>发射 indexed load/store 指令。</li>
<li>检查 CSR chicken bit。若已设置，则标量核解除对该指令后续指令的阻塞。</li>
<li>编译器/软件将不相关的独立指令调度到该 indexed 指令之后。</li>
<li>HOLSU 在后台处理所有内存事务，而前端继续执行 delay slot 中的指令。</li>
</ol>
</li>
<li><strong>参数与规格</strong>: HOLSU 支持 <code>LaneScale × ELEN × (SEW/8)</code> 个 in-flight 事务，使其能够充分压榨内存系统的并发能力。</li>
<li><strong>在整体中的作用</strong>: 该机制极大地提升了 T1 对<strong>稀疏计算</strong>和<strong>不规则访存</strong>工作负载（如图计算、某些密码学原语）的容忍度。<strong>Figure 6</strong> 清晰地展示了 VIDX0 (indexed load) 与 VEX0-VEX63 (独立计算) 的并行执行。</li>
</ul>
<p><img alt="" src="../images/60122021119a97f1361bb7dfdeba64da96d256850b9ec88b66255c7d3c530fac.jpg" /></p>
<p><em>Figure 6: Different ILP Technology in T1. Chaining interleaves V0, V1, and V2. Memory Interleaving mitigates the VSW-VLD dependency. Vector-Scalar OoO interleaves the vector and scalar pipelines until a true dependency v16-s64-v15 occurs. Memory Delay Slot parallelizes vector index load/store (VIDX0) with independent vector executions (VEX0).</em></p>
<hr />
<p><strong>输入输出关系与协同工作</strong></p>
<p>Dual LSU 架构的输入是来自 Sequencer 分发的向量内存微操作 (uops)，输出是写回向量寄存器文件 (VRF) 的数据或从 VRF 读取的数据。</p>
<ul>
<li><strong>输入分流</strong>: Sequencer 根据指令的访问模式（unit-stride vs. strided/indexed）将 uops 路由到 HBLSU 或 HOLSU。</li>
<li><strong>输出整合</strong>: 两个 LSU 的结果最终都通过各自的通道写回到 Lane 内的 Banked VRF 中。</li>
<li><strong>整体作用</strong>: 这种专业化分工确保了 T1 能够在 <strong>unit-stride</strong> 场景下榨干内存带宽，同时在 <strong>indexed/strided</strong> 场景下通过高并发和延迟隐藏维持较高的计算单元利用率。这使得 T1 在 <strong>HPC</strong> 和 <strong>Cryptography</strong> 等混合访存模式的工作负载中表现出色，如 <strong>Figure 9b</strong> 所示，即使在纯 DDR 模式下（无本地 SRAM 缓存），T1 也能凭借其强大的内存子系统和大 VLEN 带来的数据局部性，展现出对内存延迟的<strong>强大耐受性</strong>，性能远超 SpacemiT X60 (K1)。</li>
</ul>
<p><img alt="" src="../images/03e30d83e126ab5a068e779b88cf90c08b6a7dfa3df2691e4575728e0c4f4437.jpg" /></p>
<p><em>(b) T1 Memory Scalability</em></p>
<hr />
<h2 id="4">4. 实验方法与实验结果<a class="headerlink" href="#4" title="Permanent link">&para;</a></h2>
<p><strong>实验设置</strong></p>
<ul>
<li>
<p><strong>评估平台与基线</strong>：</p>
<ul>
<li><strong>Cryptographic Workloads</strong>: 与 <strong>NVIDIA GA102 (RTX 3090)</strong> 和 <strong>NVIDIA GB202 (RTX 5090)</strong> 进行对比。T1 配置为 <strong>VLEN=16384, DLEN=1024</strong>，在 <strong>TSMC 7nm</strong> 工艺下综合，频率 <strong>2.45 GHz</strong>。GPU 基线在单个 <strong>Streaming Multiprocessor (SM)</strong> 上运行，以消除多核干扰。</li>
<li><strong>HPC Workloads</strong>: 与 <strong>HiSilicon TaiShan V120 (KP920)</strong> (ARM SVE) 和 <strong>SpacemiT X60 (K1)</strong> (RVV) 进行对比。T1 的 <strong>VLEN/DLEN 比值固定为 4</strong>，并启用了浮点支持。</li>
<li><strong>内存子系统</strong>: T1 在模拟中使用 <strong>DDR4-3200</strong>，不依赖本地 SRAM 或大型缓存，以测试其对内存延迟的容忍度。</li>
</ul>
</li>
<li>
<p><strong>软件栈</strong>：</p>
<ul>
<li>提供了基于 <strong>MLIR</strong> 的完整软件栈，包含专用的 <strong>RVV dialect</strong> 以支持动态向量长度语义。</li>
<li>加密和 HPC 内核均经过手工优化或通过 MLIR 自动向量化生成。</li>
</ul>
</li>
<li>
<p><strong>物理实现</strong>：</p>
<ul>
<li>论文展示了两款基于 <strong>T1</strong> 的流片芯片：一款用于 <strong>Zero-Knowledge Proof (ZKP)</strong> 的 <strong>TSMC 28nm</strong> 芯片和一款用于 <strong>Edge AI</strong> 的 <strong>HLMC 28nm SONOS</strong> 芯片，验证了设计的可实现性。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/c3a199856092005e667eaaa6bd524d23601f04a075c22f8f8603ed2eb32f2e9a.jpg" /></p>
<p><em>Edge AI Chip SoC Top GDS</em></p>
<p><img alt="" src="../images/afe80b669e47b60ec3776928872d615689c866a61449d4ec0c1a954497875c44.jpg" /></p>
<p><em>T1 Top (Edge AI Chip)</em></p>
<p><strong>结果数据</strong></p>
<ul>
<li><strong>加密性能 (Cryptographic Performance)</strong>:<ul>
<li>在 <strong>Montgomery Modular Multiplication (MMM)</strong> 任务上，T1 相比 <strong>GA102</strong> 实现了 <strong>1.98x - 2.41x</strong> 的加速，相比 <strong>GB202</strong> 实现了 <strong>1.41x - 1.64x</strong> 的加速。</li>
<li>在 <strong>Number-Theoretic Transform (NTT)</strong> 任务（输入大小512）上，T1 相比 <strong>GA102</strong> 和 <strong>GB202</strong> 分别实现了 <strong>1.74x</strong> 和 <strong>1.85x</strong> 的加速。</li>
<li><strong>关键优势</strong>: T1 通过 <strong>in-register computation</strong> 和高效的 <strong>DLEN-sized Permutation Unit</strong>，显著减少了对内存子系统的依赖，尽管其硬件资源（如 datapath 宽度）仅为 GPU 的四分之一。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/ff792de6f74721f75bd51d9900cc87ff3661ac776cb21bbb2f4994d13b0b6f2e.jpg" /></p>
<p><em>Figure 8: Cryptographic Benchmarks of T1 (DLEN1K, VLEN16K, emulated with DDR4-3200) with GA102 (NVIDIA GTX 3090) and NVIDIA GB202 (GTX 5090)</em></p>
<ul>
<li><strong>高性能计算 (HPC) 性能</strong>:<ul>
<li><strong>vs. HiSilicon KP920</strong>: 在相同 datapath 宽度下，T1 性能与 KP920 <strong>相当 (51% - 213%)</strong>，但面积仅为其 <strong>19%</strong>。当 T1 的 datapath 宽度扩展 <strong>4x</strong> 后，在 <strong>PACK</strong> 工作负载上实现了 <strong>4.59x</strong> 的加速。</li>
<li><strong>vs. SpacemiT X60</strong>: 在 <strong>256-bit datapath</strong> 下，T1 性能是 X60 的 <strong>2.02x - 6.36x</strong>。当 T1 扩展到 <strong>1024-bit datapath</strong> 后，性能优势扩大到 <strong>8.05x</strong>。</li>
<li><strong>内存延迟容忍度</strong>: 即使在纯 <strong>DDR4-3200</strong> 模式下（无本地缓存），1024-bit T1 在 <strong>QUANT</strong> 工作负载上的性能仍能达到 KP920 的 <strong>154%</strong>，证明了其通过 <strong>strip-mining</strong> 和大 <strong>VLEN</strong> 有效隐藏内存延迟的能力。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/127f3db2d2d8c1fe04d2f7de2c916c2541f920a0bf56c066c18d709b6e83a18a.jpg" /></p>
<p><em>(a) T1-KP920 Comparison</em></p>
<p><img alt="" src="../images/03e30d83e126ab5a068e779b88cf90c08b6a7dfa3df2691e4575728e0c4f4437.jpg" /></p>
<p><em>(b) T1 Memory Scalability</em></p>
<p><img alt="" src="../images/3fc4a8f87ca51c5cf7d7530a5222cf61f80d98860cfc68d0847c09d667c3cb52.jpg" /></p>
<p><em>(c) T1-X60 Comparison Figure 9: HPC benchmark results: Figure 9a: Performance of T1 (at 2.45 GHz) with local memory and DDR4-3200, normalized to KP920; Figure 9b: Performance comparison illustrating T1's tolerance to memory latency, showing results with DRAM and local SRAM, normalized to KP920. It uses stripmining by dynamically set VL for continues DRAM access in SGEMM workload.; Figure 9c: Performance of T1 (at 1.6 GHz) using DDR4-3200, normalized to K1, where higher is better.</em></p>
<p><strong>消融实验 (Ablation Study)</strong></p>
<ul>
<li><strong>核心微架构特性影响</strong>:<ul>
<li>消融实验在 <strong>DLEN=256, VLEN=4096</strong> 的 T1 配置上进行，使用 <strong>PACK</strong> 测试集。</li>
<li><strong>禁用 Chaining</strong>: 导致性能下降 <strong>61%</strong>，从 <strong>14817</strong> cycles 增加到 <strong>23862</strong> cycles，凸显了 <strong>fine-grained chaining</strong> 对于重叠指令生命周期、提升 <strong>ILP</strong> 的关键作用。</li>
<li><strong>禁用 Memory Interleaving</strong>: 导致性能下降 <strong>32%</strong>，证明了该技术对于同时利用 <strong>load/store</strong> 通道、提升内存带宽利用率的有效性。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: left;">配置</th>
<th style="text-align: left;">Cycles</th>
<th style="text-align: left;">Slow Down</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Standard T1</td>
<td style="text-align: left;">14817</td>
<td style="text-align: left;">-</td>
</tr>
<tr>
<td style="text-align: left;">Disable Chaining</td>
<td style="text-align: left;">23862</td>
<td style="text-align: left;">61%</td>
</tr>
<tr>
<td style="text-align: left;">Disable Memory Interleaving</td>
<td style="text-align: left;">19514</td>
<td style="text-align: left;">32%</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>微架构参数缩放分析</strong>:<ul>
<li><strong>VLEN &amp; DLEN Scaling</strong>: 如图所示，T1 的面积随 <strong>VLEN</strong> 和 <strong>DLEN</strong> 呈现出近乎线性的增长，验证了其 <strong>lane-based</strong> 设计的可扩展性。</li>
</ul>
</li>
</ul>
<p><img alt="" src="../images/46a530743c1b53db2bcd8a0209fb28091509950010deb733536533ab34d1b06c.jpg" /></p>
<p><em>(a) VLEN</em></p>
<p><img alt="" src="../images/15ef027e157bafa427b723cccf13e78d14ad033b83ff8dc9bf6b7b2e6546e8e7.jpg" /></p>
<p><em>(b) DLEN Figure 4: Linearly Area Scaling of T1 design parameters, evaluated at TSMC N28 SVT technology at $65%$ utilization. Four cases are examined: (1) when varying VLEN, DLEN is held at 128, $y$ -asix on the left-hand represents the total area of T1, whereas the right-hand $y$ -axis isolates the area of Lane and Permutation; (2) when varying DLEN, the ratio VLEN/DLEN remains 1; (3) when examining LaneScale, both VLEN and DLEN are set to 1024, $y$ -asix on the left-hand represents the total area of T1, whereas the right-hand $y$ -axis isolates the area of Lane; and (4) when assessing ChainingSize, VLEN and DLEN are maintained at 1024.</em></p>
<ul>
<li><strong>LaneScale</strong>: 增加 <strong>LaneScale</strong>（将多个物理 lane 聚合为一个逻辑单元）可以在牺牲部分架构效率的情况下，显著减少控制逻辑开销，从而降低总面积。</li>
</ul>
<p><img alt="" src="../images/27d83421f52c406327f88c5f16407c9a4a727dbc83776dd3c4c8b1d254b3e15c.jpg" /></p>
<p><em>(c) LaneScale</em></p>
<ul>
<li><strong>ChainingSize</strong>: 增大 <strong>ChainingSize</strong>（即链式操作的粒度）可以支持更多飞行中的指令，但会线性增加 <strong>Lane</strong> 的面积开销，需要根据工作负载（如加密 vs HPC）进行权衡。</li>
</ul>
<p><img alt="" src="../images/dc48f26e928bedcf8e4b81459f0d32e4e0dc6057b0c1e0a49aecb412d903d2e4.jpg" /></p>
<p><em>(d) ChainingSize</em></p>
<hr />












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.sections", "navigation.top", "navigation.indexes", "search.suggest", "search.highlight", "content.code.copy"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../../../javascripts/switcher.js"></script>
      
    
  </body>
</html>